{"version":3,"sources":["webpack://dataForge/webpack/bootstrap","webpack://dataForge/./src/lib/series.ts","webpack://dataForge/./src/lib/dataframe.ts","webpack://dataForge/./src/index.ts","webpack://dataForge/./src/lib/utils.ts","webpack://dataForge/./src/lib/index.ts","webpack://dataForge/./src/lib/iterators/array-iterator.ts","webpack://dataForge/./node_modules/dayjs/dayjs.min.js","webpack://dataForge/./src/lib/iterables/empty-iterable.ts","webpack://dataForge/./src/lib/iterables/count-iterable.ts","webpack://dataForge/./src/lib/iterables/multi-iterable.ts","webpack://dataForge/./src/lib/iterables/select-iterable.ts","webpack://dataForge/./src/lib/iterables/select-many-iterable.ts","webpack://dataForge/./src/lib/iterables/take-iterable.ts","webpack://dataForge/./src/lib/iterables/take-while-iterable.ts","webpack://dataForge/./src/lib/iterables/where-iterable.ts","webpack://dataForge/./src/lib/iterables/concat-iterable.ts","webpack://dataForge/./src/lib/iterables/reverse-iterable.ts","webpack://dataForge/./src/lib/iterables/zip-iterable.ts","webpack://dataForge/./src/lib/iterables/distinct-iterable.ts","webpack://dataForge/./src/lib/iterables/ordered-iterable.ts","webpack://dataForge/./src/lib/iterables/extract-element-iterable.ts","webpack://dataForge/./src/lib/iterables/skip-iterable.ts","webpack://dataForge/./src/lib/iterables/skip-while-iterable.ts","webpack://dataForge/./node_modules/easy-table/table.js","webpack://dataForge/./node_modules/papaparse/papaparse.js","webpack://dataForge/./src/lib/iterators/empty-iterator.ts","webpack://dataForge/./src/lib/iterators/count-iterator.ts","webpack://dataForge/./src/lib/iterators/multi-iterator.ts","webpack://dataForge/./src/lib/iterators/select-iterator.ts","webpack://dataForge/./src/lib/iterators/select-many-iterator.ts","webpack://dataForge/./src/lib/iterators/take-iterator.ts","webpack://dataForge/./src/lib/iterators/take-while-iterator.ts","webpack://dataForge/./src/lib/iterators/where-iterator.ts","webpack://dataForge/./src/lib/iterators/concat-iterator.ts","webpack://dataForge/./src/lib/iterables/series-window-iterable.ts","webpack://dataForge/./src/lib/iterators/series-window-iterator.ts","webpack://dataForge/./src/lib/iterators/zip-iterator.ts","webpack://dataForge/./src/lib/iterators/distinct-iterator.ts","webpack://dataForge/./src/lib/iterables/series-rolling-window-iterable.ts","webpack://dataForge/./src/lib/iterators/series-rolling-window-iterator.ts","webpack://dataForge/./src/lib/iterables/series-variable-window-iterable.ts","webpack://dataForge/./src/lib/iterators/series-variable-window-iterator.ts","webpack://dataForge/./src/lib/iterators/extract-element-iterator.ts","webpack://dataForge/./src/lib/iterators/skip-iterator.ts","webpack://dataForge/./src/lib/iterators/skip-while-iterator.ts","webpack://dataForge/./node_modules/wcwidth/index.js","webpack://dataForge/./node_modules/defaults/index.js","webpack://dataForge/./node_modules/clone/clone.js","webpack://dataForge/./node_modules/buffer/index.js","webpack://dataForge/(webpack)/buildin/global.js","webpack://dataForge/./node_modules/base64-js/index.js","webpack://dataForge/./node_modules/ieee754/index.js","webpack://dataForge/./node_modules/isarray/index.js","webpack://dataForge/./node_modules/wcwidth/combining.js","webpack://dataForge/./src/lib/iterables/dataframe-window-iterable.ts","webpack://dataForge/./src/lib/iterators/dataframe-window-iterator.ts","webpack://dataForge/./src/lib/iterables/csv-rows-iterable.ts","webpack://dataForge/./src/lib/iterators/csv-rows-iterator.ts","webpack://dataForge/./src/lib/iterables/dataframe-rolling-window-iterable.ts","webpack://dataForge/./src/lib/iterators/dataframe-rolling-window-iterator.ts","webpack://dataForge/./src/lib/iterables/dataframe-variable-window-iterable.ts","webpack://dataForge/./src/lib/iterators/dataframe-variable-window-iterator.ts","webpack://dataForge/./src/lib/iterables/column-names-iterable.ts","webpack://dataForge/./src/lib/iterators/column-names-iterator.ts","webpack://dataForge/./node_modules/typy/lib/index.js","webpack://dataForge/./node_modules/typy/lib/typy.js","webpack://dataForge/./node_modules/typy/lib/util.js","webpack://dataForge/./node_modules/dayjs/plugin/customParseFormat.js","webpack://dataForge/./node_modules/numeral/numeral.js","webpack://dataForge/./node_modules/util/util.js","webpack://dataForge/./node_modules/process/browser.js","webpack://dataForge/./node_modules/util/support/isBufferBrowser.js","webpack://dataForge/./node_modules/inherits/inherits_browser.js"],"names":["installedModules","__webpack_require__","moduleId","exports","module","i","l","modules","call","m","c","d","name","getter","o","Object","defineProperty","enumerable","get","r","Symbol","toStringTag","value","t","mode","__esModule","ns","create","key","bind","n","object","property","prototype","hasOwnProperty","p","s","empty_iterable_1","count_iterable_1","multi_iterable_1","select_iterable_1","select_many_iterable_1","take_iterable_1","take_while_iterable_1","where_iterable_1","concat_iterable_1","series_window_iterable_1","reverse_iterable_1","zip_iterable_1","distinct_iterable_1","series_rolling_window_iterable_1","series_variable_window_iterable_1","ordered_iterable_1","index_1","extract_element_iterable_1","skip_iterable_1","skip_while_iterable_1","Table","dataframe_1","moment","customParseFormat","extend","utils_1","__1","numeral","Series","config","this","configFn","content","isFunction","isArray","iterator","initFromArray","initFromConfig","initEmpty","arr","index","defaultCountIterable","values","pairs","MultiIterable","isBaked","defaultEmptyIterable","checkIterable","input","fieldName","Error","ExtractElementIterable","undefined","baked","lazyInit","getContent","cast","getIndex","_this","Index","withIndex","newIndex","select","resetIndex","merge","series","rowMap","Map","numSeries","Array","from","length","seriesIndex","series_1","__values","series_1_1","next","done","workingSeries","_a","toPairs","_b","pair","has","set","mergedPairs","keys","map","sort","a","b","args","_i","arguments","concat","toArray","push","toObject","keySelector","valueSelector","toMap","selector","SelectIterable","selectMany","SelectManyIterable","outputPairs","transformed","window","period","isNumber","SeriesWindowIterable","rollingWindow","SeriesRollingWindowIterable","variableWindow","comparer","SeriesVariableWindowIterable","sequentialDistinct","first","aggregate","seedOrSelector","skip","accum","amountChange","last","proportionChange","pctChange","percentChange","v","proportionRank","latestValue","head","where","prevMomentum","count","percentRank","proportion","numValues","SkipIterable","skipWhile","predicate","SkipWhileIterable","skipUntil","take","numRows","TakeIterable","takeWhile","TakeWhileIterable","takeUntil","total","lastValue","at","none","toTake","Math","abs","tail","toSkip","WhereIterable","forEach","callback","all","any","startAt","indexValue","lessThan","getLessThan","endAt","lessThanOrEqualTo","getLessThanOrEqualTo","before","after","between","startIndexValue","endIndexValue","toString","header","rows","table","rowIndex","row","cellIndex","cell","newRow","parseInt","valueIndex","isString","parseInts","parseFloat","parseFloats","parseDate","formatString","toDate","parseDates","isDate","format","toStrings","bake","inflate","DataFrame","sum","prev","average","median","ordered","orderBy","floor","std","numberSeries","valueCount","mean","sumOfSquaredDiffs","diffFromMean","sqrt","min","max","invert","counter","groupSequentialBy","group","range","replicate","reverse","ReverseIterable","distinct","DistinctIterable","groupBy","groups","groupMap","groupKey","existingGroup","newGroup","contents","ConcatIterable","concatInput","series_2","series_2_1","input_1","input_1_1","subInput","zip","zipper","firstSeries","upcast","ZipIterable","slice","apply","__spread","OrderedSeries","direction","Direction","Ascending","parent","orderByDescending","Descending","union","other","intersection","inner","outerSelector","innerSelector","outerValue","outerKey","innerValue","except","join","outerKeySelector","innerKeySelector","resultSelector","outer","innerMap","output","outer_1","outer_1_1","innerGroup","innerGroup_1","innerGroup_1_1","joinOuter","outerResult","innerResult","intersectionResults","joinOuterLeft","joinOuterRight","truncateStrings","maxLength","substring","insertPair","appendPair","fillGaps","generator","pairA","pairB","generatedRows","defaultIfEmpty","defaultSequence","detectTypes","totalValues","typeFrequencies","valueType","accumulated","typeInfo","columnNames","detectValues","valueFrequencies","valueInfo","bucket","numBuckets","width","bucketMin","Value","Bucket","Min","Mid","Max","getTypeCode","CountIterable","EmptyIterable","_super","valueSortSpecs","pairSortSpecs","sortLevel","parentConfig","makeSortSpec","makePairsSelector","OrderedIterable","__extends","thenBy","thenByDescending","dataframe_window_iterable_1","csv_rows_iterable_1","dataframe_rolling_window_iterable_1","dataframe_variable_window_iterable_1","column_names_iterable_1","PapaParse","firstResult","initColumnNames","inputColumnNames","outputColumnNames","columnNamesMap","inputColumnNames_1","inputColumnNames_1_1","columnNameLwr","columnName","toLowerCase","columnNoMap","inputColumnNames_2","inputColumnNames_2_1","curColumnNo","columns","columnsConfig","iterableColumnsConfig","column","isObject","columnIterables","columnNames_1","columnNames_1_1","CsvRowsIterable","ColumnNamesIterable","considerAllRows","getColumnNames","getColumns","getSeries","firstValue","type","determineType","setIndex","deflate","hasSeries","expectSeries","withSeries","columnNameOrSpec","isUndefined","columnSpec","workingDataFrame","columnNames_2","columnNames_2_1","columnName_1","importSeries","seriesValueMap","toMap2","makeDistinct","modified","assign","dataFrames","dataFrames_1","dataFrames_1_1","dataFrame","clone","allColumnNames","reduce","newColumnNames","otherDataFrames","ensureSeries","columnNames_3","columnNames_3_1","columnName_2","subset","columnNames_4","columnNames_4_1","columnNames_5","columnNames_5_1","dropSeries","columnOrColumns","indexOf","columnOrColumns_1","columnOrColumns_1_1","columnOrColumns_2","columnOrColumns_2_1","reorderSeries","columnNames_6","columnNames_6_1","columnNames_7","columnNames_7_1","columnNames_8","columnNames_8_1","bringToFront","columnOrColumns_3","columnOrColumns_3_1","existingColumns","columnsToMove","columnOrColumns_4","columnOrColumns_4_1","columnToMove","untouchedColumnNames","existingColumns_1","existingColumns_1_1","existingColumnName","bringToBack","columnOrColumns_5","columnOrColumns_5_1","columnOrColumns_6","columnOrColumns_6_1","existingColumns_2","existingColumns_2_1","renameSeries","existingColumnsToRename","existingColumnsToRename_1","existingColumnsToRename_1_1","renamedColumns","remapValue","existingColumnsToRename_2","existingColumnsToRename_2_1","existingColumName","toRows","columnIndex","transformSeries","columnSelectors","working","generateSeries","columnTransformSpec","newColumnNames_2","newColumnNames_2_1","newColumnName","newColumns","newColumnNames_1","newColumnNames_1_1","inflateSeries","row1","row2","DataFrameWindowIterable","DataFrameRollingWindowIterable","DataFrameVariableWindowIterable","columnAggregateSpec_1","aggregatedColumns","columnSelector","columnNameOrNames","columnNameOrNames_1","columnNameOrNames_1_1","columnNameOrNames_2","columnNameOrNames_2_1","columnNameOrNames_3","columnNameOrNames_3_1","_d","_e","columnNames_9","columnNames_9_1","columnFormatString","singleColumnName","dataframes","dataframe","contents_1","contents_1_1","dataframes_1","dataframes_1_1","OrderedDataFrame","summarize","spec","inputColumnName","inputSpec","outputFieldsMap","valueColumnName","inputColumnNames_3","inputColumnNames_3_1","outputFieldNames","outputFieldNames_1","outputFieldNames_1_1","outputFieldName","aggregatorFn","pivot","valueColumnNameOrSpec","aggregator","aggSpec","columnNames_10","columnNames_10_1","_c","columnAggSpec","aggColumnName","outputSpec","firstColumnName","src","columnNameIndex","nextColumnName","parentGroup","subGroup","valueColumnNames","outputColumnsMap","outputColumnNames_1","outputColumnNames_1_1","outputColumName","srcRow","valueColumnNames_1","valueColumnNames_1_1","defaultDataFrame","typeFrequency","Column","valueFrequency","toJSON","JSON","stringify","toCSV","options","unparse","toHTML","columNames","columName","serialize","indexValues","serializedColumns","indexType","getType","toISOString","cloned","columns_1","columns_1_1","rows_1","rows_1_1","columnOrder","deserialize","rows_2","rows_2_1","parents","parents_1","parents_1_1","_1","_2","util_1","fromObject","obj","Field","fromJSON","jsonTextString","parse","fromCSV","csvTextString","skipEmptyLines","data","trim","shift","concatSeries","zipSeries","start","matrix","numColumns","increment","nextValue","colIndex","default","isBoolean","mapIterable","items","mapFn","result","sent","items_1","items_1_1","item","items_2","items_2_1","items_3","items_3_1","Date","_type","d1","d2","isBefore","v1","v2","getGreaterThan","isAfter","ArrayIterator","e","u","h","f","String","z","utcOffset","year","month","add","Number","ceil","M","y","w","ms","Q","replace","$","weekdays","split","months","S","g","pl","date","D","locale","$L","utc","$u","$d","NaN","test","match","UTC","init","$y","getFullYear","$M","getMonth","$D","getDate","$W","getDay","$H","getHours","$m","getMinutes","$s","getSeconds","$ms","getMilliseconds","$utils","isValid","isSame","startOf","endOf","$g","day","hour","minute","second","millisecond","unix","valueOf","getTime","$locale","weekStart","$set","daysInMonth","setDate","subtract","substr","YY","YYYY","MM","MMM","monthsShort","MMMM","DD","dd","weekdaysMin","ddd","weekdaysShort","dddd","H","HH","hh","A","mm","ss","SSS","Z","round","getTimezoneOffset","diff","toUTCString","isDayjs","en","Ls","empty_iterator_1","EmptyIterator","count_iterator_1","CountIterator","multi_iterator_1","iterables","iterators","iterable","MultiIterator","select_iterator_1","SelectIterator","select_many_iterator_1","SelectManyIterator","take_iterator_1","childIterable","numElements","childIterator","TakeIterator","take_while_iterator_1","TakeWhileIterator","where_iterator_1","WhereIterator","concat_iterator_1","ConcatIterator","array_iterator_1","zip_iterator_1","ZipIterator","distinct_iterator_1","DistinctIterator","SortOperation","sortSpec","genKeys","compare","indexA","indexB","keyA","keyB","comparison","indexes","sortOperations","sortOperations_1","sortOperations_1_1","sortedValues","indexes_1","indexes_1_1","extract_element_iterator_1","arrayIterable","extractIndex","arrayIterator","ExtractElementIterator","skip_iterator_1","SkipIterator","skip_while_iterator_1","SkipWhileIterator","wcwidth","__printers","string","val","str","leftPadder","ch","len","col","printer","separator","padLeft","rightPadder","padRight","each","fn","number","digits","toFixed","cols","idx","print","widths","out","line","pushDelimeter","totals","forEachTotal","cb","aggr","acc","printTransposed","opts","namePrinter","cmp","comparators","order","exec","prefix","avg","params","log","console","__WEBPACK_AMD_DEFINE_FACTORY__","__WEBPACK_AMD_DEFINE_ARRAY__","__WEBPACK_AMD_DEFINE_RESULT__","AUTO_SCRIPT_PATH","scripts","global","self","IS_WORKER","document","postMessage","IS_PAPA_WORKER","location","search","LOADED_SYNC","workers","workerIdCounter","Papa","_input","_config","dynamicTyping","dynamicTypingFunction","worker","WORKERS_SUPPORTED","SCRIPT_PATH","workerUrl","Worker","onmessage","mainThreadReceivedMessage","id","newWorker","userStep","step","userChunk","chunk","userComplete","complete","userError","error","workerId","streamer","download","NetworkStreamer","StringStreamer","readable","read","on","ReadableStreamStreamer","File","FileStreamer","stream","_quotes","_writeHeader","_delimiter","_newline","_quoteChar","delimiter","BAD_DELIMITERS","quotes","newline","quoteChar","quoteCharRegex","RegExp","objectKeys","fields","meta","csv","hasHeader","dataKeyedByField","safe","maxCol","colIdx","needsQuotes","substrings","hasAny","charAt","RECORD_SEP","fromCharCode","UNIT_SEP","BYTE_ORDER_MARK","LocalChunkSize","RemoteChunkSize","DefaultDelimiter","Parser","ParserHandle","jQuery","queue","supported","prop","toUpperCase","attr","FileReader","files","file","inputElem","instanceConfig","parseNextFile","elem","reason","returned","action","fileComplete","userCompleteFunc","results","splice","ChunkStreamer","_handle","_finished","_completed","_baseIndex","_partialLine","_rowCount","_start","_nextChunk","isFirstChunk","_completeResults","errors","configCopy","copy","chunkSize","parseChunk","isFakeChunk","beforeFirstChunk","modifiedChunk","paused","aborted","lastIndex","cursor","finishedIncludingPreview","preview","WORKER_ID","finished","_sendError","xhr","_readChunk","_chunkLoaded","url","XMLHttpRequest","withCredentials","onload","bindFunction","onerror","_chunkError","open","downloadRequestHeaders","headers","headerName","setRequestHeader","end","send","err","message","status","readyState","contentRange","getResponseHeader","lastIndexOf","getFileSize","responseText","errorMessage","errorText","statusText","reader","usingAsyncReader","webkitSlice","mozSlice","FileReaderSync","size","txt","readAsText","encoding","target","event","remaining","parseOnData","streamHasEnded","pause","resume","_streamData","_streamEnd","_streamError","_checkIsFinished","_streamCleanUp","removeListener","_parser","_delimiterError","FLOAT","_stepCounter","_paused","_aborted","_fields","_results","needsHeaderRow","processResults","abort","addError","j","trimHeaders","fillHeaderFields","field","parseDynamic","applyHeaderAndDynamicTyping","shouldApplyDynamicTyping","code","msg","baseIndex","ignoreLastRow","nAppearsFirst","numWithN","guessLineEndings","delimGuess","bestDelim","bestDelta","fieldCountPrevRow","delimChoices","delim","delta","avgFieldCount","emptyLinesCount","fieldCount","successful","bestDelimiter","guessDelimiter","parserConfig","getCharIndex","comments","fastMode","escapeChar","inputLen","delimLen","newlineLen","commentsLen","stepIsFunction","lastCursor","returnable","pushRow","doStep","quoteSearch","nextDelim","nextNewline","saveRow","finish","spacesBetweenQuoteAndDelimiter","extraSpaces","spacesBetweenQuoteAndNewLine","spaceLength","textBetweenClosingQuoteAndIndex","newCursor","stopped","linebreak","truncated","handle","completeWorker","notImplemented","terminate","cpy","func","getElementsByTagName","body","addEventListener","constructor","multiResult","outputIterator","outputIterable","outputResult","curIterator","moveToNextIterable","nextIterable","series_window_iterator_1","SeriesWindowIterator","curWindow","curPos","results_1","results_1_1","zippedValues","zipperInput","valuesAlreadySeen","Set","potentialOutput","series_rolling_window_iterator_1","SeriesRollingWindowIterator","series_variable_window_iterator_1","SeriesVariableWindowIterator","prevValue","doneSkipping","defaults","combining","DEFAULTS","nul","control","wcswidth","charCodeAt","ucs","mid","bisearch","Buffer","circular","depth","filter","allParents","allChildren","useBuffer","Infinity","_clone","child","proto","__isArray","__isRegExp","source","__getRegExpFlags","__isDate","isBuffer","allocUnsafe","getPrototypeOf","attrs","getOwnPropertyDescriptor","__objToStr","re","flags","ignoreCase","multiline","clonePrototype","base64","ieee754","kMaxLength","TYPED_ARRAY_SUPPORT","createBuffer","that","RangeError","Uint8Array","__proto__","arg","encodingOrOffset","TypeError","ArrayBuffer","array","byteOffset","byteLength","fromArrayLike","fromArrayBuffer","isEncoding","actual","write","fromString","checked","buffer","assertSize","isView","loweredCase","utf8ToBytes","base64ToBytes","swap","bidirectionalIndexOf","dir","isNaN","arrayIndexOf","indexSize","arrLength","valLength","buf","readUInt16BE","foundIndex","found","hexWrite","offset","strLen","parsed","utf8Write","blitBuffer","asciiWrite","byteArray","asciiToBytes","latin1Write","base64Write","ucs2Write","units","hi","lo","utf16leToBytes","base64Slice","fromByteArray","utf8Slice","res","secondByte","thirdByte","fourthByte","tempCodePoint","firstByte","codePoint","bytesPerSequence","codePoints","MAX_ARGUMENTS_LENGTH","decodeCodePointsArray","SlowBuffer","alloc","INSPECT_MAX_BYTES","foo","subarray","typedArraySupport","poolSize","_augment","species","configurable","fill","allocUnsafeSlow","_isBuffer","x","list","pos","swap16","swap32","swap64","hexSlice","asciiSlice","latin1Slice","utf16leSlice","equals","inspect","thisStart","thisEnd","thisCopy","targetCopy","includes","isFinite","_arr","ret","toHex","bytes","checkOffset","ext","checkInt","objectWriteUInt16","littleEndian","objectWriteUInt32","checkIEEE754","writeFloat","noAssert","writeDouble","newBuf","sliceLen","readUIntLE","mul","readUIntBE","readUInt8","readUInt16LE","readUInt32LE","readUInt32BE","readIntLE","pow","readIntBE","readInt8","readInt16LE","readInt16BE","readInt32LE","readInt32BE","readFloatLE","readFloatBE","readDoubleLE","readDoubleBE","writeUIntLE","writeUIntBE","writeUInt8","writeUInt16LE","writeUInt16BE","writeUInt32LE","writeUInt32BE","writeIntLE","limit","sub","writeIntBE","writeInt8","writeInt16LE","writeInt16BE","writeInt32LE","writeInt32BE","writeFloatLE","writeFloatBE","writeDoubleLE","writeDoubleBE","targetStart","INVALID_BASE64_RE","leadSurrogate","toByteArray","stringtrim","base64clean","dst","Function","b64","lens","getLens","validLen","placeHoldersLen","tmp","Arr","_byteLength","curByte","revLookup","uint8","extraBytes","parts","len2","encodeChunk","lookup","num","isLE","mLen","nBytes","eLen","eMax","eBias","nBits","rt","LN2","dataframe_window_iterator_1","DataFrameWindowIterator","csv_rows_iterator_1","CsvRowsIterator","rowsIterable","rowsIterator","dataframe_rolling_window_iterator_1","DataFrameRollingWindowIterator","dataframe_variable_window_iterator_1","DataFrameVariableWindowIterator","column_names_iterator_1","ColumnNamesIterator","columnNamesIterator","combinedFields","addCustomTypes","Schema","_typy","_typy2","__defineGetter__","_typeof","_createClass","writable","_util","Typy","_classCallCheck","schemaCheck","getNestedObject","convertSchemaAndGetMatch","isNull","Boolean","Null","Undefined","_arguments","buildSchema","getSchemaMatch","zone","afternoon","milliseconds","SS","Do","ordinal","findIndex","Y","ZZ","regex","parser","hours","minutes","seconds","_","decimal","binary","unformatRegex","formats","locales","currentLocale","zeroFormat","nullFormat","defaultFormat","scalePercentBy100","Numeral","_value","kind","unformatFunction","regexp","isNumeral","regexps","unformat","stringToNumber","version","numberToFormat","roundingFunction","leadingCount","abbrForce","int","precision","signed","thousands","negP","optDec","abbr","neg","abbreviations","trillion","billion","million","thousand","delimiters","abbreviation","stringOriginal","currency","symbol","insert","subString","k","multiplier","correctionFactor","mn","maxDecimals","optionals","boundedPrecision","optionalsRegExp","power","splitValue","minDecimals","localeData","reset","register","validate","culture","_decimalSep","_thousandSep","_currSymbol","_valArray","_abbrObj","_thousandRegEx","temp","warn","inputString","formatFunction","corrFactor","curr","currI","O","multiply","divide","difference","space","base","suffixes","suffix","bytesMultiplier","symbols","toExponential","timeArray","process","getOwnPropertyDescriptors","descriptors","formatRegExp","objects","deprecate","noDeprecation","warned","throwDeprecation","traceDeprecation","trace","debugEnviron","debugs","ctx","seen","stylize","stylizeNoColor","colors","showHidden","_extend","customInspect","stylizeWithColor","formatValue","styleType","style","styles","recurseTimes","primitive","simple","formatPrimitive","visibleKeys","hash","arrayToHash","getOwnPropertyNames","isError","formatError","isRegExp","braces","formatProperty","formatArray","pop","cur","numLinesEst","reduceToSingleString","desc","ar","objectToString","pad","debuglog","env","NODE_DEBUG","pid","bold","italic","underline","inverse","white","grey","black","blue","cyan","green","magenta","red","yellow","special","boolean","null","isNullOrUndefined","isSymbol","isPrimitive","time","inherits","origin","kCustomPromisifiedSymbol","callbackifyOnRejected","newReason","promisify","original","promiseResolve","promiseReject","promise","Promise","resolve","reject","setPrototypeOf","defineProperties","custom","callbackify","callbackified","maybeCb","then","nextTick","rej","cachedSetTimeout","cachedClearTimeout","defaultSetTimout","defaultClearTimeout","runTimeout","fun","setTimeout","clearTimeout","currentQueue","draining","queueIndex","cleanUpNextTick","drainQueue","timeout","run","marker","runClearTimeout","Item","noop","title","browser","argv","versions","addListener","once","off","removeAllListeners","emit","prependListener","prependOnceListener","listeners","binding","cwd","chdir","umask","ctor","superCtor","super_","TempCtor"],"mappings":"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","file":"index.js","sourcesContent":[" \t// The module cache\n \tvar installedModules = {};\n\n \t// The require function\n \tfunction __webpack_require__(moduleId) {\n\n \t\t// Check if module is in cache\n \t\tif(installedModules[moduleId]) {\n \t\t\treturn installedModules[moduleId].exports;\n \t\t}\n \t\t// Create a new module (and put it into the cache)\n \t\tvar module = installedModules[moduleId] = {\n \t\t\ti: moduleId,\n \t\t\tl: false,\n \t\t\texports: {}\n \t\t};\n\n \t\t// Execute the module function\n \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n \t\t// Flag the module as loaded\n \t\tmodule.l = true;\n\n \t\t// Return the exports of the module\n \t\treturn module.exports;\n \t}\n\n\n \t// expose the modules object (__webpack_modules__)\n \t__webpack_require__.m = modules;\n\n \t// expose the module cache\n \t__webpack_require__.c = installedModules;\n\n \t// define getter function for harmony exports\n \t__webpack_require__.d = function(exports, name, getter) {\n \t\tif(!__webpack_require__.o(exports, name)) {\n \t\t\tObject.defineProperty(exports, name, { enumerable: true, get: getter });\n \t\t}\n \t};\n\n \t// define __esModule on exports\n \t__webpack_require__.r = function(exports) {\n \t\tif(typeof Symbol !== 'undefined' && Symbol.toStringTag) {\n \t\t\tObject.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });\n \t\t}\n \t\tObject.defineProperty(exports, '__esModule', { value: true });\n \t};\n\n \t// create a fake namespace object\n \t// mode & 1: value is a module id, require it\n \t// mode & 2: merge all properties of value into the ns\n \t// mode & 4: return value when already ns object\n \t// mode & 8|1: behave like require\n \t__webpack_require__.t = function(value, mode) {\n \t\tif(mode & 1) value = __webpack_require__(value);\n \t\tif(mode & 8) return value;\n \t\tif((mode & 4) && typeof value === 'object' && value && value.__esModule) return value;\n \t\tvar ns = Object.create(null);\n \t\t__webpack_require__.r(ns);\n \t\tObject.defineProperty(ns, 'default', { enumerable: true, value: value });\n \t\tif(mode & 2 && typeof value != 'string') for(var key in value) __webpack_require__.d(ns, key, function(key) { return value[key]; }.bind(null, key));\n \t\treturn ns;\n \t};\n\n \t// getDefaultExport function for compatibility with non-harmony modules\n \t__webpack_require__.n = function(module) {\n \t\tvar getter = module && module.__esModule ?\n \t\t\tfunction getDefault() { return module['default']; } :\n \t\t\tfunction getModuleExports() { return module; };\n \t\t__webpack_require__.d(getter, 'a', getter);\n \t\treturn getter;\n \t};\n\n \t// Object.prototype.hasOwnProperty.call\n \t__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };\n\n \t// __webpack_public_path__\n \t__webpack_require__.p = \"\";\n\n\n \t// Load entry module and return exports\n \treturn __webpack_require__(__webpack_require__.s = 2);\n","import { ArrayIterable }  from './iterables/array-iterable';\nimport { EmptyIterable }  from './iterables/empty-iterable';\nimport { CountIterable }  from './iterables/count-iterable';\nimport { MultiIterable }  from './iterables/multi-iterable';\nimport { SelectIterable }  from './iterables/select-iterable';\nimport { SelectManyIterable }  from './iterables/select-many-iterable';\nimport { TakeIterable }  from './iterables/take-iterable';\nimport { TakeWhileIterable }  from './iterables/take-while-iterable';\nimport { WhereIterable }  from './iterables/where-iterable';\nimport { ConcatIterable }  from './iterables/concat-iterable';\nimport { SeriesWindowIterable }  from './iterables/series-window-iterable';\nimport { ReverseIterable }  from './iterables/reverse-iterable';\nimport { ZipIterable }  from './iterables/zip-iterable';\nimport { DistinctIterable }  from './iterables/distinct-iterable';\nimport { SeriesRollingWindowIterable }  from './iterables/series-rolling-window-iterable';\nimport { SeriesVariableWindowIterable }  from './iterables/series-variable-window-iterable';\nimport { OrderedIterable, Direction, ISortSpec, SelectorFn as SortSelectorFn }  from './iterables/ordered-iterable';\nimport { IIndex, Index } from './index';\nimport { ExtractElementIterable } from './iterables/extract-element-iterable';\nimport { SkipIterable } from './iterables/skip-iterable';\nimport { SkipWhileIterable } from './iterables/skip-while-iterable';\nconst Table = require('easy-table');\nimport { IDataFrame, DataFrame } from './dataframe';\nimport * as moment from \"dayjs\";\nimport * as customParseFormat from 'dayjs/plugin/customParseFormat';\nmoment.extend(customParseFormat);\nimport { toMap, isArray, isFunction, isNumber, isString, isDate } from './utils';\nimport { range, replicate } from '..';\nimport * as numeral from 'numeral';\n\n/**\n * Used to configure a series.\n */\nexport interface ISeriesConfig<IndexT, ValueT> {\n    /**\n     * Values to put in the dataframe.\n     * This should be array or iterable of JavaScript values.\n     */\n    values?: Iterable<ValueT>,\n\n    /***\n     * The index for the serires.\n     * If omitted the index will default to a 0-based index.\n     */\n    index?: Iterable<IndexT>,\n\n    /**\n     * Array or iterable of index,value pairs to put in the series.\n     * If index and values are not separately specified they can be extracted\n     * from the pairs.\n     */\n    pairs?: Iterable<[IndexT, ValueT]>\n\n    /***\n     * Set to true when the series has been baked into memory\n     * and does not need to be lazily evaluated.\n     */\n    baked?: boolean,\n};\n\n/**\n * A user-defined callback function that can be applied to each value.\n */\nexport type CallbackFn<ValueT> = (value: ValueT, index: number) => void;\n\n/**\n * A user-defined selector function. \n * Transforms a value into another kind of value.\n */\nexport type SelectorWithIndexFn<FromT, ToT> = (value: FromT, index: number) => ToT;\n\n/**\n * User-defined zipper functions.\n * Used to 'zip together' multiple series or dataframes.\n */\n//TODO: The Zip function should actually be necessary. Should really just output a series of arrays, collecting each value into one array.\n// The caller can then run select on it and this means th the zipper function is unecessary.\nexport type ZipNFn<ValueT, ReturnT> = (input: ISeries<number, ValueT>) => ReturnT;\nexport type Zip2Fn<T1, T2, ReturnT> = (a: T1, b : T2) => ReturnT;\nexport type Zip3Fn<T1, T2, T3, ReturnT> = (a: T1, b: T2, c: T3) => ReturnT;\nexport type Zip4Fn<T1, T2, T3, T4, ReturnT> = (a: T1, b: T2, c: T3, d: T4) => ReturnT;\nexport type Zip5Fn<T1, T2, T3, T4, T5, ReturnT> = (a: T1, b: T2, c: T3, d: T4) => ReturnT;\n\n/**\n * A user-defined selector function with no index. \n * Transforms a value into another kind of value.\n */\nexport type SelectorFn<FromT, ToT> = (value: FromT) => ToT;\n\n/**\n * A user-defined function that joins two values and produces a result.\n */\nexport type JoinFn<ValueT1, ValueT2, ResultT> = (a: ValueT1, b: ValueT2) => ResultT;\n\n/**\n * A user-defined predicate function, returns true or false based on input.\n */\nexport type PredicateFn<ValueT> = (value: ValueT) => boolean;\n\n/**\n * A user-defined function that aggregtates a value into an accumulator\n * and returns the new result.\n */\nexport type AggregateFn<ValueT, ToT> = (accum: ToT, value: ValueT) => ToT;\n\n/**\n * A user-defined comparer function that Compares to values and \n * returns true (truthy) if they are equivalent or false (falsy) if not.\n */\nexport type ComparerFn<ValueT1, ValueT2> = (a: ValueT1, b: ValueT2) => boolean;\n\n/*\n * A user-defined function that generates a series config object.\n * Used to make it easy to create lazy evaluated series.\n */\nexport type SeriesConfigFn<IndexT, ValueT> = () => ISeriesConfig<IndexT, ValueT>;\n\n/*\n * A user-defined gap-filler function.\n * This function generates a sequence of values between to fill the gaps between two other values.\n */\nexport type GapFillFn<ValueT, ResultT> = (a: ValueT, b: ValueT) => ResultT[];\n\n/**\n * Represents the frequency of a type in a series or dataframe.\n */\nexport interface ITypeFrequency {\n\n    /**\n     * The name of the type.\n     */\n    Type: string; \n\n    /**\n     * The frequency of the type's appearance in the series or dataframe.\n     */\n    Frequency: number;\n}\n\n/**\n * Represents the frequency of a value in a series or dataframe.\n */\nexport interface IValueFrequency {\n\n    /**\n     * The value.\n     */\n    Value: any; \n\n    /**\n     * The frequency of the value's appearance in the series or dataframe.\n     */\n    Frequency: number;\n}\n\n/**\n * Places a value in a bucket or range of values.\n */\nexport interface IBucket {\n    /**\n     * The bucketed value.\n     */\n    Value: number;\n\n    /**\n     * The index of the bucket that contains the value.\n     */\n    Bucket: number;\n\n    /**\n     * The minimum value in the bucket.\n     */\n    Min: number;\n\n    /**\n     * The mid-point value in the bucket.\n     */\n    Mid: number;\n    \n    /**\n     * The maximum value in the bucket.\n     */\n    Max: number;\n}\n\n/**\n * Interface that represents a series.\n * A series contains an indexed sequence of values.\n * A series indexed by time is a timeseries.\n * \n * @typeparam IndexT The type to use for the index.\n * @typeparam ValueT The type to use for each value.\n */\nexport interface ISeries<IndexT = number, ValueT = any> extends Iterable<ValueT> {\n\n    /**\n     * Get an iterator to enumerate the values of the series.\n     * Enumerating the iterator forces lazy evaluation to complete.\n     * This function is automatically called by `for...of`.\n     * \n     * @return An iterator for the values in the series.\n     * \n     * @example\n     * <pre>\n     * \n     * for (const value of series) {\n     *     // ... do something with the value ...\n     * }\n     * </pre>\n     */\n    [Symbol.iterator] (): Iterator<ValueT>;\n\n    /**\n     * Cast the value of the series to a new type.\n     * This operation has no effect but to retype the values that the series contains.\n     * \n     * @return The same series, but with the type changed.\n     * \n     * @example\n     * <pre>\n     * \n     * const castSeries = series.cast<SomeOtherType>();\n     * </pre>\n     */\n    cast<NewValueT> (): ISeries<IndexT, NewValueT>;\n\n    /**\n     * Get the index for the series.\n     * \n     * @return The {@link Index} for the series.\n     * \n     * @example\n     * <pre>\n     * \n     * const index = series.getIndex();\n     * </pre>\n     */\n    getIndex (): IIndex<IndexT>;\n\n    /**\n     * Apply a new {@link Index} to the series.\n     * \n     * @param newIndex The new array or iterable to be the new {@link Index} of the series. Can also be a selector to choose the {@link Index} for each value in the series.\n     * \n     * @return Returns a new series with the specified {@link Index} attached.\n     * \n     * @example\n     * <pre>\n     * \n     * const indexedSeries = series.withIndex([10, 20, 30]);\n     * </pre>\n     * \n     * @example\n     * <pre>\n     * \n     * const indexedSeries = series.withIndex(someOtherSeries);\n     * </pre>\n     * \n     * @example\n     * <pre>\n     * \n     * const indexedSeries = series.withIndex(value => computeIndexFromValue(value));\n     * </pre>\n     * \n     * @example\n     * <pre>\n     * \n     * const indexedSeries = series.withIndex(value => value + 20);\n     * </pre>\n     */\n    withIndex<NewIndexT> (newIndex: Iterable<NewIndexT> | SelectorFn<ValueT, NewIndexT>): ISeries<NewIndexT, ValueT>;\n\n    /**\n     * Resets the {@link Index} of the series back to the default zero-based sequential integer index.\n     * \n     * @return Returns a new series with the {@link Index} reset to the default zero-based index. \n     * \n     * @example\n     * <pre>\n     * \n     * const seriesWithResetIndex = series.resetIndex();\n     * </pre>\n     */\n    resetIndex (): ISeries<number, ValueT>;\n\n   /**\n     * Merge one or more series into this series.\n     * Values are merged by index.\n     * Values at each index are combined into arrays in the resulting series.\n     * \n     * @param series... One or more other series to merge into the series.\n     * \n     * @returns The merged series.\n     * \n     * @example\n     * <pre>\n     * \n     * const mergedSeries = series1.merge(series2);\n     * </pre>\n     * \n     * <pre>\n     * \n     * const mergedSeries = series1.merge(series2, series3, etc);\n     * </pre>\n     */\n    merge<MergedValueT = any>(...args: any[]): ISeries<IndexT, MergedValueT[]>;\n\n    /**\n    * Extract values from the series as an array.\n    * This forces lazy evaluation to complete.\n    * \n    * @return Returns an array of the values contained within the series.\n    * \n    * @example\n    * <pre>\n    * const values = series.toArray();\n    * </pre>\n    */\n   toArray (): ValueT[];\n\n    /**\n     * Retreive the index, values pairs from the series as an array.\n     * Each pair is [index, value].\n     * This forces lazy evaluation to complete.\n     * \n     * @return Returns an array of pairs that contains the series values. Each pair is a two element array that contains an index and a value.\n     * \n     * @example\n     * <pre>\n     * const pairs = series.toPairs();\n     * </pre>\n     */\n    toPairs (): ([IndexT,ValueT])[];\n\n    /**\n     * Convert the series to a JavaScript object.\n     *\n     * @param keySelector User-defined selector function that selects keys for the resulting object.\n     * @param valueSelector User-defined selector function that selects values for the resulting object.\n     * \n     * @return Returns a JavaScript object generated from the series by applying the key and value selector functions. \n     * \n     * @example\n     * <pre>\n     * \n     * const someObject = series.toObject(\n     *      value => value, // Specify the value to use for field names in the output object.\n     *      value => value // Specify the value to use as the value for each field.\n     * );\n     * </pre>\n     */\n    toObject<KeyT = any, FieldT = any, OutT = any> (keySelector: (value: ValueT) => KeyT, valueSelector: (value: ValueT) => FieldT): OutT;\n\n    /**\n     * Generates a new series by repeatedly calling a user-defined selector function on each value in the original series.\n     *\n     * @param selector A user-defined selector function that transforms each row to create the new dataframe.\n     * \n     * @return Returns a new series with each value transformed by the selector function.\n     * \n     * @example\n     * <pre>\n     * \n     * function transformValue (inputValue) {\n     *      const outputValue = {\n     *          // ... construct output value derived from input value ...\n     *      };\n     *\n     *      return outputValue;\n     * }\n     *  \n     * const transformedSeries = series.select(value => transformValue(value));\n     * </pre>\n     */\n    select<ToT> (selector: SelectorWithIndexFn<ValueT, ToT>): ISeries<IndexT, ToT>;\n\n    /**\n     * Generates a new series by repeatedly calling a user-defined selector function on each row in the original series.\n     * \n     * Similar to the {@link select} function, but in this case the selector function produces a collection of output values that are flattened and merged to create the new series.\n     *\n     * @param selector A user-defined selector function that transforms each value into a collection of output values.\n     * \n     * @return Returns a new series where each value has been transformed into 0 or more new values by the selector function. \n     * \n     * @example\n     * <pre>\n     * \n     * function produceOutputValues (inputValue) {\n     *      const outputValues = [];\n     *      while (someCondition) {\n     *          // ... generate zero or more output values ...\n     *          outputValues.push(... some generated value ...);\n     *      }\n     *      return outputValues;\n     * }\n     * \n     * const modifiedSeries = series.selectMany(value => produceOutputValues(value));\n     * </pre>\n     */\n    selectMany<ToT> (selector: SelectorWithIndexFn<ValueT, Iterable<ToT>>): ISeries<IndexT, ToT>;\n        \n    /**\n     * Partition a series into a {@link Series} of *data windows*. \n     * Each value in the new series is a chunk of data from the original series.\n     *\n     * @param period The number of values to include in each data window.\n     * \n     * @return Returns a new series, each value of which is a chunk (data window) of the original series.\n     * \n     * @example\n     * <pre>\n     * \n     * const windows = series.window(2); // Get values in pairs.\n     * const pctIncrease = windows.select(pair => (pair.last() - pair.first()) / pair.first());\n     * console.log(pctIncrease.toString());\n     * </pre>\n     * \n     * @example\n     * <pre>\n     * \n     * const salesDf = ... // Daily sales data.\n     * const weeklySales = salesDf.window(7); // Partition up into weekly data sets.\n     * console.log(weeklySales.toString());\n     * </pre>\n     */\n    window (period: number): ISeries<number, ISeries<IndexT, ValueT>>;\n\n    /** \n     * Partition a series into a new series of *rolling data windows*. \n     * Each value in the new series is a rolling chunk of data from the original series.\n     *\n     * @param period The number of data values to include in each data window.\n     * \n     * @return Returns a new series, each value of which is a rolling chunk of the original series.\n     * \n     * @example\n     * <pre>\n     * \n     * const salesData = ... // Daily sales data.\n     * const rollingWeeklySales = salesData.rollingWindow(7); // Get rolling window over weekly sales data.\n     * console.log(rollingWeeklySales.toString());\n     * </pre>\n     */\n    rollingWindow (period: number): ISeries<number, ISeries<IndexT, ValueT>>;\n\n    /**\n     * Partition a series into a new series of variable-length *data windows* \n     * where the divisions between the data chunks are\n     * defined by a user-provided *comparer* function.\n     * \n     * @param comparer Function that compares two adjacent data values and returns true if they should be in the same window.\n     * \n     * @return Returns a new series, each value of which is a chunk of data from the original series.\n     * \n     * @example\n     * <pre>\n     * \n     * function rowComparer (valueA, valueB) {\n     *      if (... valueA should be in the same data window as valueB ...) {\n     *          return true;\n     *      }\n     *      else {\n     *          return false;\n     *      }\n     * };\n     * \n     * const variableWindows = series.variableWindow(rowComparer);\n     */\n    variableWindow (comparer: ComparerFn<ValueT, ValueT>): ISeries<number, ISeries<IndexT, ValueT>>;\n\n    /**\n     * Eliminates adjacent duplicate values.\n     * \n     * For each group of adjacent values that are equivalent only returns the last index/row for the group, \n     * thus ajacent equivalent values are collapsed down to the last value.\n     *\n     * @param [selector] Optional selector function to determine the value used to compare for equivalence.\n     * \n     * @return Returns a new series with groups of adjacent duplicate vlaues collapsed to a single value per group.\n     * \n     * @example\n     * <pre>\n     * \n     * const seriesWithDuplicateRowsRemoved = series.sequentialDistinct(value => value);\n     * \n     * // Or\n     * const seriesWithDuplicateRowsRemoved = series.sequentialDistinct(value => value.someNestedField);\n     * </pre>\n     */\n    sequentialDistinct<ToT> (selector: SelectorFn<ValueT, ToT>): ISeries<IndexT, ValueT>;\n    \n    /**\n     * Aggregate the values in the series to a single result.\n     *\n     * @param [seed] Optional seed value for producing the aggregation.\n     * @param selector Function that takes the seed and then each value in the series and produces the aggregated value.\n     * \n     * @return Returns a new value that has been aggregated from the series using the 'selector' function. \n     * \n     * @example\n     * <pre>\n     * \n     * const dailySales = ... daily sales figures for the past month ...\n     * const totalSalesForthisMonth = dailySales.aggregate(\n     *      0, // Seed - the starting value.\n     *      (accumulator, salesAmount) => accumulator + salesAmount // Aggregation function.\n     * );\n     * </pre>\n     * \n     * @example\n     * <pre>\n     * \n     * const totalSalesAllTime = 500; // We'll seed the aggregation with this value.\n     * const dailySales = ... daily sales figures for the past month ...\n     * const updatedTotalSalesAllTime = dailySales.aggregate(\n     *      totalSalesAllTime, \n     *      (accumulator, salesAmount) => accumulator + salesAmount\n     * );\n     * </pre>\n     * \n     * @example\n     * <pre>\n     * \n     * var salesDataSummary = salesData.aggregate({\n     *      TotalSales: series => series.count(),\n     *      AveragePrice: series => series.average(),\n     *      TotalRevenue: series => series.sum(), \n     * });\n     * </pre>\n    */\n    aggregate<ToT = ValueT> (seedOrSelector: AggregateFn<ValueT, ToT> | ToT, selector?: AggregateFn<ValueT, ToT>): ToT;\n\n    /**\n     * Compute the amount of change between pairs or sets of values in the series.\n     * \n     * @param [period] Optional period for computing the change - defaults to 2.\n     * \n     * @returns Returns a new series where each value indicates the amount of change from the previous number value in the original series.  \n     * \n     * @example\n     * <pre>\n     * \n     * const saleFigures = ... running series of daily sales figures ...\n     * const amountChanged = salesFigures.amountChanged(); // Amount that sales has changed, day to day.\n     * </pre>\n     * @example\n     * <pre>\n     * \n     * const saleFigures = ... running series of daily sales figures ...\n     * const amountChanged = salesFigures.amountChanged(7); // Amount that sales has changed, week to week.\n     * </pre>\n     */\n    amountChange (period?: number): ISeries<IndexT, number>;\n\n    /**\n     * Compute the proportion change between pairs or sets of values in the series.\n     * Proportions are expressed as 0-1 values.\n     * \n     * @param [period] Optional period for computing the proportion - defaults to 2.\n     * \n     * @returns Returns a new series where each value indicates the proportion change from the previous number value in the original series.\n     * \n     * @example\n     * <pre>\n     * \n     * const saleFigures = ... running series of daily sales figures ...\n     * const proportionChanged = salesFigures.amountChanged(); // Proportion that sales has changed, day to day.\n     * </pre>\n     * @example\n     * <pre>\n     * \n     * const saleFigures = ... running series of daily sales figures ...\n     * const proportionChanged = salesFigures.amountChanged(7); // Proportion that sales has changed, week to week.\n     * </pre>\n     */\n    proportionChange (period?: number): ISeries<IndexT, number>;\n\n    /**\n     * Compute the percentage change between pairs or sets of values in the series.\n     * Percentages are expressed as 0-100 values.\n     * \n     * @param [period] Optional period for computing the percentage - defaults to 2.\n     * \n     * @returns Returns a new series where each value indicates the percent change from the previous number value in the original series.\n     * \n     * @example\n     * <pre>\n     * \n     * const saleFigures = ... running series of daily sales figures ...\n     * const percentChanged = salesFigures.amountChanged(); // Percent that sales has changed, day to day.\n     * </pre>\n     * @example\n     * <pre>\n     * \n     * const saleFigures = ... running series of daily sales figures ...\n     * const percentChanged = salesFigures.amountChanged(7); // Percent that sales has changed, week to week.\n     * </pre>\n     */\n    percentChange (period?: number): ISeries<IndexT, number>;\n\n    /**\n     * For each period, compute the proportion of values that are less than the last value in the period.\n     * Proportions are expressed as 0-1 values.\n     * \n     * @param [period] Optional period for computing the proportion rank - defaults to 2.\n     * \n     * @returns Returns a new series where each value indicates the proportion rank value for that period.\n     * \n     * @example\n     * <pre>\n     * \n     * const proportionRank = series.proportionRank();\n     * </pre>\n     * @example\n     * <pre>\n     * \n     * const proportionRank = series.proportionRank(100);\n     * </pre>\n     */\n    proportionRank (period?: number): ISeries<IndexT, number>;\n\n    /**\n     * For each period, compute the percent of values that are less than the last value in the period.\n     * Percent are expressed as 0-100 values.\n     * \n     * @param [period] Optional period for computing the percent rank - defaults to 2.\n     * \n     * @returns Returns a new series where each value indicates the percent rank value for that period.\n     * \n     * @example\n     * <pre>\n     * \n     * const percentRank = series.percentRank();\n     * </pre>\n     * @example\n     * <pre>\n     * \n     * const percentRank = series.percentRank(100);\n     * </pre>\n     */\n    percentRank (period?: number): ISeries<IndexT, number>;\n    \n    /**\n     * Skip a number of values in the series.\n     *\n     * @param numValues Number of values to skip.\n     * \n     * @return Returns a new series with the specified number of values skipped.\n     * \n     * @example\n     * <pre>\n     * \n     * const seriesWithRowsSkipped = series.skip(10); // Skip 10 rows in the original series.\n     * </pre>\n     */\n    skip (numValues: number): ISeries<IndexT, ValueT>;\n\n    /**\n     * Skips values in the series while a condition evaluates to true or truthy.\n     *\n     * @param predicate Returns true/truthy to continue to skip values in the original series.\n     * \n     * @return Returns a new series with all initial sequential values removed while the predicate returned true/truthy.\n     * \n     * @example\n     * <pre>\n     * \n     * const seriesWithRowsSkipped = series.skipWhile(salesFigure => salesFigure > 100); // Skip initial sales figure that are less than 100.\n     * </pre>\n     */\n    skipWhile (predicate: PredicateFn<ValueT>): ISeries<IndexT, ValueT>;\n\n    /**\n     * Skips values in the series untils a condition evaluates to true or truthy.\n     *\n     * @param predicate Return true/truthy to stop skipping values in the original series.\n     * \n     * @return Returns a new series with all initial sequential values removed until the predicate returned true/truthy.\n     * \n     * @example\n     * <pre>\n     * \n     * const seriesWithRowsSkipped = series.skipUntil(salesFigure => salesFigure > 100); // Skip initial sales figures unitl we see one greater than 100.\n     * </pre>\n     */\n    skipUntil (predicate: PredicateFn<ValueT>): ISeries<IndexT, ValueT>;\n    \n    /**\n     * Take a number of  values from the series.\n     *\n     * @param numValues Number of values to take.\n     * \n     * @return Returns a new series with only the specified number of values taken from the original series.\n     * \n     * @example\n     * <pre>\n     * \n     * const seriesWithRowsTaken = series.take(15); // Take only the first 15 values from the original series.\n     * </pre>\n     */\n    take (numRows: number): ISeries<IndexT, ValueT>;\n    \n    /**\n     * Takes values from the series while a condition evaluates to true or truthy.\n     *\n     * @param predicate Returns true/truthy to continue to take values from the original series.\n     * \n     * @return Returns a new series with only the initial sequential values that were taken while the predicate returned true/truthy.\n     * \n     * @example\n     * <pre>\n     * \n     * const seriesWithRowsTaken = series.takeWhile(salesFigure => salesFigure > 100); // Take only initial sales figures that are greater than 100.\n     * </pre>\n     */\n    takeWhile (predicate: PredicateFn<ValueT>): ISeries<IndexT, ValueT>;\n\n    /**\n     * Takes values from the series until a condition evaluates to true or truthy.\n     *\n     * @param predicate Return true/truthy to stop taking values in the original series.\n     * \n     * @return Returns a new series with only the initial sequential values taken until the predicate returned true/truthy.\n     * \n     * @example\n     * <pre>\n     * \n     * const seriesWithRowsTaken = series.takeUntil(salesFigure => salesFigure > 100); // Take all initial sales figures until we see one that is greater than 100.\n     * </pre>\n     */\n    takeUntil (predicate: PredicateFn<ValueT>): ISeries<IndexT, ValueT>;\n    \n    /**\n     * Count the number of values in the seriese\n     *\n     * @return Returns the count of all values.\n     * \n     * @example\n     * <pre>\n     * \n     * const numValues = series.count();\n     * </pre>\n     */\n    count (): number;\n    \n    /**\n     * Get the first value of the series.\n     *\n     * @return Returns the first value of the series.\n     * \n     * @example\n     * <pre>\n     * \n     * const firstValue = series.first();\n     * </pre>\n     */\n    first (): ValueT;\n\n    /**\n     * Get the last value of the series.\n     *\n     * @return Returns the last value of the series.\n     * \n     * @example\n     * <pre>\n     * \n     * const lastValue = series.last();\n     * </pre>\n     */\n    last (): ValueT;\n\n    /**\n     * Get the value, if there is one, with the specified index.\n     *\n     * @param index Index to for which to retreive the value.\n     *\n     * @return Returns the value from the specified index in the series or undefined if there is no such index in the present in the series.\n     * \n     * @example\n     * <pre>\n     * \n     * const value = series.at(5); // Get the value at index 5 (with a default 0-based index).\n     * </pre>\n     * \n     * @example\n     * <pre>\n     * \n     * const date = ... some date ...\n     * // Retreive the value with specified date from a time-series (assuming date indexed has been applied).\n     * const value = series.at(date); \n     * </pre>\n     */\n    at (index: IndexT): ValueT | undefined;\n\n    /** \n     * Get X value from the start of the series.\n     * Pass in a negative value to get all values at the head except for X values at the tail.\n     *\n     * @param numValues Number of values to take.\n     * \n     * @return Returns a new series that has only the specified number of values taken from the start of the original series.\n     * \n     * @examples\n     * <pre>\n     * \n     * const sample = series.head(10); // Take a sample of 10 values from the start of the series.\n     * </pre>\n     */\n    head (numValues: number): ISeries<IndexT, ValueT>;\n\n    /** \n     * Get X values from the end of the series.\n     * Pass in a negative value to get all values at the tail except X values at the head.\n     *\n     * @param numValues Number of values to take.\n     * \n     * @return Returns a new series that has only the specified number of values taken from the end of the original series.  \n     * \n     * @examples\n     * <pre>\n     * \n     * const sample = series.tail(12); // Take a sample of 12 values from the end of the series.\n     * </pre>\n     */\n    tail (numValues: number): ISeries<IndexT, ValueT>;\n\n    /**\n     * Filter the series using user-defined predicate function.\n     *\n     * @param predicate Predicte function to filter values from the series. Returns true/truthy to keep values, or false/falsy to omit values.\n     * \n     * @return Returns a new series containing only the values from the original series that matched the predicate. \n     * \n     * @example\n     * <pre>\n     * \n     * const filtered = series.where(salesFigure => salesFigure > 100); // Filter so we only have sales figures greater than 100.\n     * </pre>\n     */\n    where (predicate: PredicateFn<ValueT>): ISeries<IndexT, ValueT>;\n\n    /**\n     * Invoke a callback function for each value in the series.\n     *\n     * @param callback The calback function to invoke for each value.\n     * \n     * @return Returns the original series with no modifications.\n     * \n     * @example\n     * <pre>\n     * \n     * series.forEach(value => {\n     *      // ... do something with the value ...\n     * });\n     * </pre>\n     */\n    forEach (callback: CallbackFn<ValueT>): ISeries<IndexT, ValueT>;\n\n    /**\n     * Evaluates a predicate function for every value in the series to determine \n     * if some condition is true/truthy for **all** values in the series.\n     * \n     * @param predicate Predicate function that receives each value. It should returns true/truthy for a match, otherwise false/falsy.\n     *\n     * @return Returns true if the predicate has returned true or truthy for every value in the series, otherwise returns false. Returns false for an empty series.\n     * \n     * @example\n     * <pre>\n     * \n     * const result = series.all(salesFigure => salesFigure > 100); // Returns true if all sales figures are greater than 100.\n     * </pre>\n     */\n    all (predicate: PredicateFn<ValueT>): boolean;\n    \n    /**\n     * Evaluates a predicate function for every value in the series to determine \n     * if some condition is true/truthy for **any** of values in the series.\n     * \n     * If no predicate is specified then it simply checks if the series contains more than zero values.\n     *\n     * @param [predicate] Optional predicate function that receives each value. It should return true/truthy for a match, otherwise false/falsy.\n     *\n     * @return Returns true if the predicate has returned truthy for any value in the series, otherwise returns false. \n     * If no predicate is passed it returns true if the series contains any values at all.\n     * Returns false for an empty series.\n     * \n     * @example\n     * <pre>\n     * \n     * const result = series.any(salesFigure => salesFigure > 100); // Do we have any sales figures greater than 100?\n     * </pre>\n     * \n     * @example\n     * <pre>\n     * \n     * const result = series.any(); // Do we have any sales figures at all?\n     * </pre>\n     */\n    any (predicate?: PredicateFn<ValueT>): boolean;\n\n    /**\n     * Evaluates a predicate function for every value in the series to determine \n     * if some condition is true/truthy for **none** of values in the series.\n     * \n     * If no predicate is specified then it simply checks if the series contains zero values.\n     *\n     * @param [predicate] Optional predicate function that receives each value. It should return true/truthy for a match, otherwise false/falsy.\n     *\n     * @return Returns true if the predicate has returned truthy for zero values in the series, otherwise returns false. Returns false for an empty series.\n     * \n     * @example\n     * <pre>\n     * \n     * const result = series.none(salesFigure => salesFigure > 100); // Do we have zero sales figures greater than 100?\n     * </pre>\n     * \n     * @example\n     * <pre>\n     * \n     * const result = series.none(); // Do we have zero sales figures?\n     * </pre>\n     */\n    none (predicate?: PredicateFn<ValueT>): boolean;\n\n    /**\n     * Gets a new series containing all values starting at or after the specified index value.\n     * \n     * @param indexValue The index value at which to start the new series.\n     * \n     * @return Returns a new series containing all values starting at or after the specified index value. \n     * \n     * @example\n     * <pre>\n     * \n     * const series = new Series({ \n     *      index: [0, 1, 2, 3], // This is the default index.\n     *      values: [10, 20, 30, 40],\n     * });\n     * \n     * const lastHalf = series.startAt(2);\n     * expect(lastHalf.toArray()).to.eql([30, 40]);\n     * </pre>\n     * \n     * @example\n     * <pre>\n     * \n     * const timeSeries = ... a series indexed by date/time ...\n     * \n     * // Get all values starting at (or after) a particular date.\n     * const result = timeSeries.startAt(new Date(2016, 5, 4)); \n     * </pre>\n     */\n    startAt (indexValue: IndexT): ISeries<IndexT, ValueT>;\n\n    /**\n     * Gets a new series containing all values up until and including the specified index value (inclusive).\n     * \n     * @param indexValue The index value at which to end the new series.\n     * \n     * @return Returns a new series containing all values up until and including the specified index value.\n     * \n     * @example\n     * <pre>\n     * \n     * const series = new Series({ \n     *      index: [0, 1, 2, 3], // This is the default index.\n     *      values: [10, 20, 30, 40],\n     * });\n     * \n     * const firstHalf = series.endAt(1);\n     * expect(firstHalf.toArray()).to.eql([10, 20]);\n     * </pre>\n     * \n     * @example\n     * <pre>\n     * \n     * const timeSeries = ... a series indexed by date/time ...\n     * \n     * // Get all values ending at a particular date.\n     * const result = timeSeries.endAt(new Date(2016, 5, 4)); \n     * </pre>\n     */\n    endAt (indexValue: IndexT): ISeries<IndexT, ValueT>;\n\n    /**\n     * Gets a new series containing all values up to the specified index value (exclusive).\n     * \n     * @param indexValue The index value at which to end the new series.\n     * \n     * @return Returns a new series containing all values up to (but not including) the specified index value. \n     * \n     * @example\n     * <pre>\n     * \n     * const series = new Series({ \n     *      index: [0, 1, 2, 3], // This is the default index.\n     *      values: [10, 20, 30, 40],\n     * });\n     * \n     * const firstHalf = series.before(2);\n     * expect(firstHalf.toArray()).to.eql([10, 20]);\n     * </pre>\n     * \n     * @example\n     * <pre>\n     * \n     * const timeSeries = ... a series indexed by date/time ...\n     * \n     * // Get all values before the specified date.\n     * const result = timeSeries.before(new Date(2016, 5, 4)); \n     * </pre>\n     */\n    before (indexValue: IndexT): ISeries<IndexT, ValueT>;\n\n    /**\n     * Gets a new series containing all values after the specified index value (exclusive).\n     * \n     * @param indexValue The index value after which to start the new series.\n     * \n     * @return Returns a new series containing all values after the specified index value.\n     * \n     * @example\n     * <pre>\n     * \n     * const series = new Series({ \n     *      index: [0, 1, 2, 3], // This is the default index.\n     *      values: [10, 20, 30, 40],\n     * });\n     * \n     * const lastHalf = df.before(1);\n     * expect(lastHalf.toArray()).to.eql([30, 40]);\n     * </pre>\n     * \n     * @example\n     * <pre>\n     * \n     * const timeSerie = ... a series indexed by date/time ...\n     * \n     * // Get all values after the specified date.\n     * const result = timeSeries.after(new Date(2016, 5, 4)); \n     * </pre>\n     */    \n    after (indexValue: IndexT): ISeries<IndexT, ValueT>;\n\n    /**\n     * Gets a new series containing all values between the specified index values (inclusive).\n     * \n     * @param startIndexValue The index at which to start the new series.\n     * @param endIndexValue The index at which to end the new series.\n     * \n     * @return Returns a new series containing all values between the specified index values (inclusive).\n     * \n     * @example\n     * <pre>\n     * \n     * const series = new Series({ \n     *      index: [0, 1, 2, 3, 4, 6], // This is the default index.\n     *      values: [10, 20, 30, 40, 50, 60],\n     * });\n     * \n     * const middleSection = series.between(1, 4);\n     * expect(middleSection.toArray()).to.eql([20, 30, 40, 50]);\n     * </pre>\n     * \n     * @example\n     * <pre>\n     * \n     * const timeSeries = ... a series indexed by date/time ...\n     * \n     * // Get all values between the start and end dates (inclusive).\n     * const result = timeSeries.after(new Date(2016, 5, 4), new Date(2016, 5, 22)); \n     * </pre>\n     */\n    between (startIndexValue: IndexT, endIndexValue: IndexT): ISeries<IndexT, ValueT>;\n\n    /** \n     * Format the series for display as a string.\n     * This forces lazy evaluation to complete.\n     * \n     * @return Generates and returns a string representation of the series.\n     * \n     * @example\n     * <pre>\n     * \n     * console.log(series.toString());\n     * </pre>\n     */\n    toString (): string;\n\n    /**\n     * Parse a series with string values and convert it to a series with int values.\n     *\n     * @return Returns a new series with values parsed from strings to ints.\n     * \n     * @example\n     * <pre>\n     * \n     * const parsed = series.parseInts();\n     * </pre>\n     */\n    parseInts (): ISeries<IndexT, number>;\n\n    /**\n     * Parse a series with string values and convert it to a series with float values.\n     *\n     * @return Returns a new series with values parsed from strings to floats.\n     * \n     * @example\n     * <pre>\n     * \n     * const parsed = series.parseFloats();\n     * </pre>\n     */\n    parseFloats (): ISeries<IndexT, number>;\n\n    /**\n     * Parse a series with string values and convert it to a series with date values.\n     *\n     * @param [formatString] Optional formatting string for dates.\n     * \n     * Moment is used for date parsing.\n     * https://momentjs.com\n     * \n     * @return Returns a new series with values parsed from strings to dates.\n     * \n     * @example\n     * <pre>\n     * \n     * const parsed = series.parseDates();\n     * </pre>\n     */\n    parseDates (formatString?: string): ISeries<IndexT, Date>;\n\n    /**\n     * Convert a series of values of different types to a series containing string values.\n     *\n     * @param [formatString] Optional formatting string for dates.\n     * \n     * Numeral.js is used for number formatting.\n     * http://numeraljs.com/\n     * \n     * Moment is used for date formatting.\n     * https://momentjs.com/docs/#/parsing/string-format/\n     * \n     * @return Returns a new series values converted from values to strings.\n     * \n     * @example\n     * <pre>\n     * \n     * const result = series.toStrings(\"YYYY-MM-DD\");\n     * </pre>\n     * \n     * @example\n     * <pre>\n     * \n     * const result = series.toStrings(\"0.00\");\n     * </pre>\n     */\n    toStrings (formatString?: string): ISeries<IndexT, string>;\n\n    /**\n     * Forces lazy evaluation to complete and 'bakes' the series into memory.\n     * \n     * @return Returns a series that has been 'baked', all lazy evaluation has completed.\n     * \n     * @example\n     * <pre>\n     * \n     * const baked = series.bake();\n     * </pre>\n     */\n    bake (): ISeries<IndexT, ValueT>;\n\n    /** \n     * Converts (inflates) a series to a {@link DataFrame}.\n     *\n     * @param [selector] Optional user-defined selector function that transforms each value to produce the dataframe.\n     *\n     * @returns Returns a dataframe that was created from the original series.\n     * \n     * @example\n     * <pre>\n     * \n     * const dataframe = series.inflate(); // Inflate a series of objects to a dataframe.\n     * </pre>\n     * \n     * @example\n     * <pre>\n     * \n     * const dataframe = series.inflate(value => { AColumn:  value }); // Produces a dataframe with 1 column from a series of values.\n     * </pre>\n     * \n     * @example\n     * <pre>\n     * \n     * const dataframe = series.inflate(value => { AColumn:  value.NestedValue }); // Extract a nested value and produce a dataframe from it.\n     * </pre>\n     */\n    inflate<ToT = ValueT> (selector?: SelectorWithIndexFn<ValueT, ToT>): IDataFrame<IndexT, ToT>;\n\n    /**\n     * Sum the values in a series and returns the result.\n     * \n     * @returns Returns the sum of the number values in the series.\n     * \n     * @example\n     * <pre>\n     * \n     * const totalSales = salesFigures.sum();\n     * </pre>\n     */\n    sum (): number;\n\n    /**\n     * Average the values in a series and returns the result\n     * \n     * @returns Returns the average of the number values in the series.\n     * \n     * @example\n     * <pre>\n     * \n     * const averageSales = salesFigures.average();\n     * </pre>\n     */\n    average (): number;\n\n    /**\n     * Get the median value in the series. \n     * Note that this sorts the series, which can be expensive.\n     * \n     * @returns Returns the median of the values in the series.\n     * \n     * @example\n     * <pre>\n     * \n     * const medianSales = salesFigures.median();\n     * </pre>\n     */\n    median (): number;\n\n    /**\n     * Get the standard deviation of number values in the series. \n     * \n     * @returns Returns the standard deviation of the values in the series.\n     * \n     * @example\n     * <pre>\n     * \n     * const salesStdDev = salesFigures.std();\n     * </pre>\n     */\n    std (): number;\n\n    /**\n     * Get the min value in the series.\n     * \n     * @returns Returns the minimum of the number values in the series.\n     * \n     * @example\n     * <pre>\n     * \n     * const minSales = salesFigures.min();\n     * </pre>\n     */\n    min (): number;\n\n    /**\n     * Get the max value in the series.\n     * \n     * @returns Returns the maximum of the number values in the series.\n     * \n     * @example\n     * <pre>\n     * \n     * const maxSales = salesFigures.max();\n     * </pre>\n     */\n    max (): number;\n\n    /**\n     * Invert the sign of every number value in the series.\n     * This assumes that the input series contains numbers.\n     * \n     * @returns Returns a new series with all number values inverted.\n     * \n     * @example\n     * <pre>\n     * \n     * const inverted = series.invert();\n     * </pre>\n     */\n    invert (): ISeries<IndexT, number>;\n\n    /**\n     * Counts the number of sequential values where the predicate evaluates to truthy.\n     * Outputs 0 for values when the predicate evaluates to falsy.\n     * \n     * @param predicate User-defined function. Should evaluate to truthy to activate the counter or falsy to deactivate it.\n     * \n     * @returns Returns a new series that counts up the number of sequential values where the predicate evaluates to truthy. 0 values appear when the prediate evaluates to falsy.\n     * \n     * @example\n     * <pre>\n     * \n     * const series = new Series([ 1, 10, 3, 15, 8, 5 ]);\n     * const counted = series.counter(value => value >= 3);\n     * console.log(counted.toString());\n     * </pre>\n     */\n    counter (predicate: PredicateFn<ValueT>): ISeries<IndexT, number>;\n\n    /** \n     * Gets a new series in reverse order.\n     * \n     * @return Returns a new series that is the reverse of the original.\n     * \n     * @example\n     * <pre>\n     * \n     * const reversed = series.reverse();\n     * </pre>\n     */\n    reverse (): ISeries<IndexT, ValueT>;\n\n    /**\n     * Returns only the set of values in the series that are distinct.\n     * Provide a user-defined selector to specify criteria for determining the distinctness.\n     * This can be used to remove duplicate values from the series.\n     *\n     * @param [selector] Optional user-defined selector function that specifies the criteria used to make comparisons for duplicate values.\n     * \n     * @return Returns a series containing only unique values in the series. \n     * \n     * @example\n     * <pre>\n     * \n     * const uniqueValues = series.distinct(); // Get only non-duplicated value in the series.\n     * </pre>\n     * \n     * @example\n     * <pre>\n     * \n     * const bucketedValues = series.distinct(value => Math.floor(value / 10)); // Lump values into buckets of 10.\n     * </pre>\n     */\n    distinct<ToT> (selector?: SelectorFn<ValueT, ToT>): ISeries<IndexT, ValueT>;\n\n    /**\n     * Collects values in the series into a new series of groups according to a user-defined selector function.\n     *\n     * @param selector User-defined selector function that specifies the criteriay to group by.\n     *\n     * @return Returns a new series of groups. Each group is a series with values that have been grouped by the 'selector' function.\n     * \n     * @example\n     * <pre>\n     * \n     * const sales = ... product sales ...\n     * const salesByProduct = sales.groupBy(sale => sale.ProductId);\n     * for (const productSalesGroup of salesByProduct) {\n     *      // ... do something with each product group ...\n     *      const productId = productSalesGroup.first().ProductId;\n     *      const totalSalesForProduct = productSalesGroup.deflate(sale => sale.Amount).sum();\n     *      console.log(totalSalesForProduct);\n     * }\n     * </pre>\n     */\n    groupBy<GroupT> (selector: SelectorFn<ValueT, GroupT>): ISeries<number, ISeries<IndexT, ValueT>>;\n\n    /**\n     * Collects values in the series into a new series of groups based on if the values are the same or according to a user-defined selector function.\n     *\n     * @param [selector] Optional selector that specifies the criteria for grouping.\n     *\n     * @return Returns a new series of groups. Each group is a series with values that are the same or have been grouped by the 'selector' function.\n     * \n     * @example\n     * <pre>\n     * \n     * // Some ultra simple stock trading strategy backtesting...\n     * const dailyStockPrice = ... daily stock price for a company ...\n     * const priceGroups  = dailyStockPrice.groupBy(day => day.close > day.movingAverage);\n     * for (const priceGroup of priceGroups) {\n     *      // ... do something with each stock price group ...\n     * \n     *      const firstDay = priceGroup.first();\n     *      if (firstDay.close > movingAverage) {\n     *          // This group of days has the stock price above its moving average.\n     *          // ... maybe enter a long trade here ...\n     *      }\n     *      else {\n     *          // This group of days has the stock price below its moving average.\n     *          // ... maybe enter a short trade here ...\n     *      }\n     * }\n     * </pre>\n     */    \n    groupSequentialBy<GroupT> (selector?: SelectorFn<ValueT, GroupT>): ISeries<number, ISeries<IndexT, ValueT>>;\n    \n    /**\n     * Concatenate multiple other series onto this series.\n     * \n     * @param series Multiple arguments. Each can be either a series or an array of series.\n     * \n     * @return Returns a single series concatenated from multiple input series. \n     * \n     * @example\n     * <pre>\n     * \n     * const concatenated = a.concat(b);\n     * </pre>\n     * \n     * @example\n     * <pre>\n     * \n     * const concatenated = a.concat(b, c);\n     * </pre>\n     * \n     * @example\n     * <pre>\n     * \n     * const concatenated = a.concat([b, c]);\n     * </pre>\n     * \n     * @example\n     * <pre>\n     * \n     * const concatenated = a.concat(b, [c, d]);\n     * </pre>\n     * \n     * @example\n     * <pre>\n     * \n     * const otherSeries = [... array of series...];\n     * const concatenated = a.concat(otherSeries);\n     * </pre>\n     */    \n    concat (...series: (ISeries<IndexT, ValueT>[]|ISeries<IndexT, ValueT>)[]): ISeries<IndexT, ValueT>;\n\n    /**\n    * Zip together multiple series to create a new series.\n    * Preserves the index of the first series.\n    * \n    * @param s2, s3, s4, s4 Multiple series to zip.\n    * @param zipper User-defined zipper function that merges rows. It produces values for the new series based-on values from the input series.\n    * \n    * @return Returns a single series merged from multiple input series. \n    * \n    * @example\n    * <pre>\n    * \n    * const a = new Series([1, 2, 3]);\n    * const b = new Series([10, 20, 30]);\n    * const zipped = a.zip(b (valueA, valueB) => valueA + valueB);\n    * </pre>\n    */    \n   zip<Index2T, Value2T, ResultT>  (s2: ISeries<Index2T, Value2T>, zipper: Zip2Fn<ValueT, Value2T, ResultT> ): ISeries<IndexT, ResultT>;\n   zip<Index2T, Value2T, Index3T, Value3T, ResultT>  (s2: ISeries<Index2T, Value2T>, s3: ISeries<Index3T, Value3T>, zipper: Zip3Fn<ValueT, Value2T, Value3T, ResultT> ): ISeries<IndexT, ResultT>;\n   zip<Index2T, Value2T, Index3T, Value3T, Index4T, Value4T, ResultT>  (s2: ISeries<Index2T, Value2T>, s3: ISeries<Index3T, Value3T>, s4: ISeries<Index4T, Value4T>, zipper: Zip3Fn<ValueT, Value2T, Value3T, ResultT> ): ISeries<IndexT, ResultT>;\n   zip<ResultT>  (...args: any[]): ISeries<IndexT, ResultT>;\n   \n    /**\n     * Sorts the series in ascending order by a value defined by the user-defined selector function. \n     * \n     * @param selector User-defined selector function that selects the value to sort by.\n     * \n     * @return Returns a new series that has been ordered accorrding to the value chosen by the selector function. \n     * \n     * @example\n     * <pre>\n     * \n     * const orderedSeries = series.orderBy(value => value); \n     * </pre>\n     * \n     * @example\n     * <pre>\n     * \n     * const orderedSeries = series.orderBy(value => value.NestedValue); \n     * </pre>\n     */\n    orderBy<SortT> (selector: SelectorWithIndexFn<ValueT, SortT>): IOrderedSeries<IndexT, ValueT, SortT>;\n\n    /**\n     * Sorts the series in descending order by a value defined by the user-defined selector function. \n     * \n     * @param selector User-defined selector function that selects the value to sort by.\n     * \n     * @return Returns a new series that has been ordered accorrding to the value chosen by the selector function. \n     * \n     * @example\n     * <pre>\n     * \n     * const orderedSeries = series.orderByDescending(value => value); \n     * </pre>\n     * \n     * @example\n     * <pre>\n     * \n     * const orderedSeries = series.orderByDescending(value => value.NestedValue); \n     * </pre>\n     */\n    orderByDescending<SortT> (selector: SelectorWithIndexFn<ValueT, SortT>): IOrderedSeries<IndexT, ValueT, SortT>;\n\n    /**\n     * Creates a new series by merging two input dataframes.\n     * The resulting series contains the union of value from the two input series.\n     * These are the unique combination of values in both series.\n     * This is basically a concatenation and then elimination of duplicates.\n     *\n     * @param other The other series to merge.\n     * @param [selector] Optional user-defined selector function that selects the value to compare to determine distinctness.\n     * \n     * @return Returns the union of the two series.\n     * \n     * @example\n     * <pre>\n     *\n     * const seriesA = ...\n     * const seriesB = ...\n     * const merged = seriesA.union(seriesB);\n     * </pre>\n     * \n     * @example\n     * <pre>\n     *\n     * // Merge two sets of customer records that may contain the same\n     * // customer record in each set. This is basically a concatenation\n     * // of the series and then an elimination of any duplicate records\n     * // that result.\n     * const customerRecordsA = ...\n     * const customerRecordsB = ...\n     * const mergedCustomerRecords = customerRecordsA.union(\n     *      customerRecordsB, \n     *      customerRecord => customerRecord.CustomerId\n     * );\n     * </pre>\n     * \n     * \n     * @example\n     * <pre>\n     *\n     * // Note that you can achieve the exact same result as the previous\n     * // example by doing a {@link Series.concat) and {@link Series.distinct}\n     * // of the input series and then an elimination of any duplicate records\n     * // that result.\n     * const customerRecordsA = ...\n     * const customerRecordsB = ...\n     * const mergedCustomerRecords = customerRecordsA\n     *      .concat(customerRecordsB)\n     *      .distinct(customerRecord => customerRecord.CustomerId);\n     * </pre>\n     * \n     */\n    union<KeyT = ValueT> (\n        other: ISeries<IndexT, ValueT>, \n        selector?: SelectorFn<ValueT, KeyT>): \n            ISeries<IndexT, ValueT>;\n\n    /**\n     * Creates a new series by merging two input series.\n     * The resulting series contains the intersection of values from the two input series.\n     * These are only the values that appear in both series.\n     *\n     * @param inner The inner series to merge (the series you call the function on is the 'outer' series).\n     * @param [outerSelector] Optional user-defined selector function that selects the key from the outer series that is used to match the two series.\n     * @param [innerSelector] Optional user-defined selector function that selects the key from the inner series that is used to match the two series.\n     * \n     * @return Returns a new series that contains the intersection of values from the two input series.\n     * \n     * @example\n     * <pre>\n     * \n     * const seriesA = ...\n     * const seriesB = ...\n     * const mergedDf = seriesA.intersection(seriesB);\n     * </pre>\n     * \n     * @example\n     * <pre>\n     *\n     * // Merge two sets of customer records to find only the\n     * // customers that appears in both.\n     * const customerRecordsA = ...\n     * const customerRecordsB = ...\n     * const intersectionOfCustomerRecords = customerRecordsA.intersection(\n     *      customerRecordsB, \n     *      customerRecord => customerRecord.CustomerId\n     * );\n     * </pre>     \n     */    \n    intersection<InnerIndexT = IndexT, InnerValueT = ValueT, KeyT = ValueT> (\n        inner: ISeries<InnerIndexT, InnerValueT>, \n        outerSelector?: SelectorFn<ValueT, KeyT>,\n        innerSelector?: SelectorFn<InnerValueT, KeyT>): \n            ISeries<IndexT, ValueT>;\n\n    /**\n     * Creates a new series by merging two input series.\n     * The resulting series contains only the values from the 1st series that don't appear in the 2nd series.\n     * This is essentially subtracting the values from the 2nd series from the 1st and creating a new series with the remaining values.\n     *\n     * @param inner The inner series to merge (the series you call the function on is the 'outer' series).\n     * @param [outerSelector] Optional user-defined selector function that selects the key from the outer series that is used to match the two series.\n     * @param [innerSelector] Optional user-defined selector function that selects the key from the inner series that is used to match the two series.\n     * \n     * @return Returns a new series that contains only the values from the 1st series that don't appear in the 2nd series.\n     * \n     * @example\n     * <pre>\n     * \n     * const seriesA = ...\n     * const seriesB = ...\n     * const remainingDf = seriesA.except(seriesB);\n     * </pre>\n     * \n     * @example\n     * <pre>\n     *\n     * // Find the list of customers haven't bought anything recently.\n     * const allCustomers = ... list of all customers ...\n     * const recentCustomers = ... list of customers who have purchased recently ...\n     * const remainingCustomers = allCustomers.except(\n     *      recentCustomers, \n     *      customerRecord => customerRecord.CustomerId\n     * );\n     * </pre>\n     */    \n    except<InnerIndexT = IndexT, InnerValueT = ValueT, KeyT = ValueT> (\n        inner: ISeries<InnerIndexT, InnerValueT>, \n        outerSelector?: SelectorFn<ValueT, KeyT>,\n        innerSelector?: SelectorFn<InnerValueT, KeyT>): \n            ISeries<IndexT, ValueT>;\n\n   /**\n     * Creates a new series by merging two input series.\n     * The resulting dataframe contains only those value that have matching keys in both input series.\n     *\n     * @param inner The 'inner' series to join (the series you are callling the function on is the 'outer' series).\n     * @param outerKeySelector User-defined selector function that chooses the join key from the outer series.\n     * @param innerKeySelector User-defined selector function that chooses the join key from the inner series.\n     * @param resultSelector User-defined function that merges outer and inner values.\n     * \n     * @return Returns the new merged series.\n     * \n     * @example\n     * <pre>\n     * \n     * // Join together two sets of customers to find those\n     * // that have bought both product A and product B.\n     * const customerWhoBoughtProductA = ...\n     * const customerWhoBoughtProductB = ...\n     * const customersWhoBoughtBothProductsDf = customerWhoBoughtProductA.join(\n     *          customerWhoBoughtProductB,\n     *          customerA => customerA.CustomerId, // Join key.\n     *          customerB => customerB.CustomerId, // Join key.\n     *          (customerA, customerB) => {\n     *              return {\n     *                  // ... merge the results ...\n     *              };\n     *          }\n     *      );\n     * </pre>\n     */\n    join<KeyT, InnerIndexT, InnerValueT, ResultValueT> (\n        inner: ISeries<InnerIndexT, InnerValueT>, \n        outerKeySelector: SelectorFn<ValueT, KeyT>, \n        innerKeySelector: SelectorFn<InnerValueT, KeyT>, \n        resultSelector: JoinFn<ValueT, InnerValueT, ResultValueT>):\n            ISeries<number, ResultValueT>;\n\n    /**\n     * Creates a new series by merging two input series.\n     * The resulting series contains only those values that are only present in or or the other of the series, not both.\n     *\n     * @param inner The 'inner' series to join (the series you are callling the function on is the 'outer' series).\n     * @param outerKeySelector User-defined selector function that chooses the join key from the outer series.\n     * @param innerKeySelector User-defined selector function that chooses the join key from the inner series.\n     * @param resultSelector User-defined function that merges outer and inner values.\n     * \n     * Implementation from here:\n     * \n     * \thttp://blogs.geniuscode.net/RyanDHatch/?p=116\n     * \n     * @return Returns the new merged series.\n     * \n     * @example\n     * <pre>\n     * \n     * // Join together two sets of customers to find those\n     * // that have bought either product A or product B, not not both.\n     * const customerWhoBoughtProductA = ...\n     * const customerWhoBoughtProductB = ...\n     * const customersWhoBoughtEitherProductButNotBothDf = customerWhoBoughtProductA.joinOuter(\n     *          customerWhoBoughtProductB,\n     *          customerA => customerA.CustomerId, // Join key.\n     *          customerB => customerB.CustomerId, // Join key.\n     *          (customerA, customerB) => {\n     *              return {\n     *                  // ... merge the results ...\n     *              };\n     *          }\n     *      );\n     * </pre>\n     */    \n    joinOuter<KeyT, InnerIndexT, InnerValueT, ResultValueT> (\n        inner: ISeries<InnerIndexT, InnerValueT>, \n        outerKeySelector: SelectorFn<ValueT, KeyT>, \n        innerKeySelector: SelectorFn<InnerValueT, KeyT>, \n        resultSelector: JoinFn<ValueT | null, InnerValueT | null, ResultValueT>):\n            ISeries<number, ResultValueT>;\n\n    /**\n     * Creates a new series by merging two input series.\n     * The resulting series contains only those values that are present either in both series or only in the outer (left) series.\n     * \n     * @param inner The 'inner' series to join (the series you are callling the function on is the 'outer' series).\n     * @param outerKeySelector User-defined selector function that chooses the join key from the outer series.\n     * @param innerKeySelector User-defined selector function that chooses the join key from the inner series.\n     * @param resultSelector User-defined function that merges outer and inner values.\n     * \n     * Implementation from here:\n     * \n     * \thttp://blogs.geniuscode.net/RyanDHatch/?p=116\n     * \n     * @return Returns the new merged series.\n     * \n     * @example\n     * <pre>\n     * \n     * // Join together two sets of customers to find those\n     * // that have bought either just product A or both product A and product B.\n     * const customerWhoBoughtProductA = ...\n     * const customerWhoBoughtProductB = ...\n     * const boughtJustAorAandB = customerWhoBoughtProductA.joinOuterLeft(\n     *          customerWhoBoughtProductB,\n     *          customerA => customerA.CustomerId, // Join key.\n     *          customerB => customerB.CustomerId, // Join key.\n     *          (customerA, customerB) => {\n     *              return {\n     *                  // ... merge the results ...\n     *              };\n     *          }\n     *      );\n     * </pre>\n     */\n    joinOuterLeft<KeyT, InnerIndexT, InnerValueT, ResultValueT> (\n        inner: ISeries<InnerIndexT, InnerValueT>, \n        outerKeySelector: SelectorFn<ValueT, KeyT>, \n        innerKeySelector: SelectorFn<InnerValueT, KeyT>, \n        resultSelector: JoinFn<ValueT | null, InnerValueT | null, ResultValueT>):\n            ISeries<number, ResultValueT>;\n\n    /**\n     * Creates a new series by merging two input series.\n     * The resulting series contains only those values that are present either in both series or only in the inner (right) series.\n     *\n     * @param inner The 'inner' series to join (the series you are callling the function on is the 'outer' series).\n     * @param outerKeySelector User-defined selector function that chooses the join key from the outer series.\n     * @param innerKeySelector User-defined selector function that chooses the join key from the inner series.\n     * @param resultSelector User-defined function that merges outer and inner values.\n     * \n     * Implementation from here:\n     * \n     * \thttp://blogs.geniuscode.net/RyanDHatch/?p=116\n     * \n     * @return Returns the new merged series.\n     * \n     * @example\n     * <pre>\n     * \n     * // Join together two sets of customers to find those\n     * // that have bought either just product B or both product A and product B.\n     * const customerWhoBoughtProductA = ...\n     * const customerWhoBoughtProductB = ...\n     * const boughtJustAorAandB = customerWhoBoughtProductA.joinOuterRight(\n     *          customerWhoBoughtProductB,\n     *          customerA => customerA.CustomerId, // Join key.\n     *          customerB => customerB.CustomerId, // Join key.\n     *          (customerA, customerB) => {\n     *              return {\n     *                  // ... merge the results ...\n     *              };\n     *          }\n     *      );\n     * </pre>\n     */\n    joinOuterRight<KeyT, InnerIndexT, InnerValueT, ResultValueT> (\n        inner: ISeries<InnerIndexT, InnerValueT>, \n        outerKeySelector: SelectorFn<ValueT, KeyT>, \n        innerKeySelector: SelectorFn<InnerValueT, KeyT>, \n        resultSelector: JoinFn<ValueT | null, InnerValueT | null, ResultValueT>):\n            ISeries<number, ResultValueT>;\n\n    /**\n     * Produces a new series with all string values truncated to the requested maximum length.\n     *\n     * @param maxLength - The maximum length of the string values after truncation.\n     * \n     * @returns Returns a new series with strings that are truncated to the specified maximum length. \n     * \n     * @example\n     * <pre>\n     * \n     * const truncated = series.truncateStrings(10); // Truncate all string values to max length of 10 characters.\n     * </pre>\n     */\n    truncateStrings (maxLength: number): ISeries<IndexT, ValueT>;\n\n    /**\n     * Insert a pair at the start of the series.\n     * Doesn't modify the original series! The returned series is entirely new and contains values from the original series plus the inserted pair.\n     *\n     * @param pair The index/value pair to insert.\n     * \n     * @return Returns a new series with the specified pair inserted.\n     * \n     * @example\n     * <pre>\n     * \n     * const newIndex = ... index of the new row ...\n     * const newRow = ... the new data row to insert ...\n     * const insertedSeries = series.insertPair([newIndex, newRows]);\n     * </pre>\n     */\n    insertPair (pair: [IndexT, ValueT]): ISeries<IndexT, ValueT>;\n\n    /**\n     * Append a pair to the end of a series.\n     * Doesn't modify the original series! The returned series is entirely new and contains values from the original series plus the appended pair.\n     *\n     * @param pair The index/value pair to append.\n     *  \n     * @return Returns a new series with the specified pair appended.\n     * \n     * @example\n     * <pre>\n     * \n     * const newIndex = ... index of the new row ...\n     * const newRow = ... the new data row to append ...\n     * const appendedSeries = series.appendPair([newIndex, newRows]);\n     * </pre>\n     */\n    appendPair (pair: [IndexT, ValueT]): ISeries<IndexT, ValueT>;\n\n    /**\n     * Fill gaps in a series.\n     *\n     * @param comparer User-defined comparer function that is passed pairA and pairB, two consecutive values, return truthy if there is a gap between the value, or falsey if there is no gap.\n     * @param generator User-defined generator function that is passed pairA and pairB, two consecutive values, returns an array of pairs that fills the gap between the values.\n     *\n     * @return Returns a new series with gaps filled in.\n     * \n     * @example\n     * <pre>\n     * \n     *   var sequenceWithGaps = ...\n     *\n     *  // Predicate that determines if there is a gap.\n     *  var gapExists = (pairA, pairB) => {\n     *      // Returns true if there is a gap.\n     *      return true;\n     *  };\n     *\n     *  // Generator function that produces new rows to fill the game.\n     *  var gapFiller = (pairA, pairB) => {\n     *      // Create an array of index, value pairs that fill the gaps between pairA and pairB.\n     *      return [\n     *          newPair1,\n     *          newPair2,\n     *          newPair3,\n     *      ];\n     *  };\n     *\n     *  var sequenceWithoutGaps = sequenceWithGaps.fillGaps(gapExists, gapFiller);\n     * </pre>\n     */\n    fillGaps (comparer: ComparerFn<[IndexT, ValueT], [IndexT, ValueT]>, generator: GapFillFn<[IndexT, ValueT], [IndexT, ValueT]>): ISeries<IndexT, ValueT>;\n\n    /**\n     * Returns the specified default series if the input series is empty. \n     *\n     * @param defaultSequence Default series to return if the input series is empty.\n     * \n     * @return Returns 'defaultSequence' if the input series is empty. \n     * \n     * @example\n     * <pre>\n     * \n     * const emptySeries = new Series();\n     * const defaultSeries = new Series([ 1, 2, 3 ]);\n     * expect(emptyDataFrame.defaultIfEmpty(defaultSeries)).to.eql(defaultSeries);\n     * </pre>\n     * \n     * @example\n     * <pre>\n     * \n     * const nonEmptySeries = new Series([ 100 ]);\n     * const defaultSeries = new Series([ 1, 2, 3 ]);\n     * expect(nonEmptySeries.defaultIfEmpty(defaultSeries)).to.eql(nonEmptySeries);\n     * </pre>\n     */\n    defaultIfEmpty (defaultSequence: ValueT[] | ISeries<IndexT, ValueT>): ISeries<IndexT, ValueT>;\n\n    /**\n     * Detect the the frequency of the types of the values in the series.\n     * This is a good way to understand the shape of your data.\n     *\n     * @return Returns a {@link DataFrame} with rows that confirm to {@link ITypeFrequency} that describes the data types contained in the original series.\n     * \n     * @example\n     * <pre>\n     * \n     * const dataTypes = series.detectTypes();\n     * console.log(dataTypes.toString());\n     * </pre>\n     */\n    detectTypes (): IDataFrame<number, ITypeFrequency>;\n\n    /**\n     * Detect the frequency of the values in the series.\n     * This is a good way to understand the shape of your data.\n     *\n     * @return Returns a {@link DataFrame} with rows that conform to {@link IValueFrequency} that describes the values contained in the original series.\n     * \n     * @example\n     * <pre>\n     * \n     * const dataValues = series.detectValues();\n     * console.log(dataValues.toString());\n     * </pre>\n     */\n    detectValues (): IDataFrame<number, IValueFrequency>;\n\n    /**\n     * Organise all values in the series into the specified number of buckets.\n     * Assumes that the series is a series of numbers.\n     * \n     * @param numBuckets - The number of buckets to create.\n     * \n     * @returns Returns a dataframe containing bucketed values. The input values are divided up into these buckets.\n     * \n     * @example\n     * <pre>\n     * \n     * const buckets = series.bucket(20); // Distribute values into 20 evenly spaced buckets.\n     * console.log(buckets.toString());\n     * </pre>\n     */\n    bucket (numBuckets: number): IDataFrame<IndexT, IBucket>;    \n}\n\n/**\n * Interface to a series that has been ordered.\n */\nexport interface IOrderedSeries<IndexT = number, ValueT = any, SortT = any> extends ISeries<IndexT, ValueT> {\n\n    /** \n     * Applys additional sorting (ascending) to an already sorted series.\n     * \n     * @param selector User-defined selector that selects the additional value to sort by.\n     * \n     * @return Returns a new series has been additionally sorted by the value chosen by the selector function. \n     * \n     * @example\n     * <pre>\n     * \n     * // Order sales by salesperson and then by amount (from least to most).\n     * const ordered = sales.orderBy(sale => sale.SalesPerson).thenBy(sale => sale.Amount);\n     * </pre>\n     */\n    thenBy<SortT> (selector: SelectorWithIndexFn<ValueT, SortT>): IOrderedSeries<IndexT, ValueT, SortT>;\n\n    /** \n     * Applys additional sorting (descending) to an already sorted series.\n     * \n     * @param selector User-defined selector that selects the additional value to sort by.\n     * \n     * @return Returns a new series has been additionally sorted by the value chosen by the selector function. \n     * \n     * @example\n     * <pre>\n     * \n     * // Order sales by salesperson and then by amount (from most to least).\n     * const ordered = sales.orderBy(sale => sale.SalesPerson).thenByDescending(sale => sale.Amount);\n     * </pre>\n     */\n    thenByDescending<SortT> (selector: SelectorWithIndexFn<ValueT, SortT>): IOrderedSeries<IndexT, ValueT, SortT>;\n}\n\n//\n// Represents the contents of a series.\n//\ninterface ISeriesContent<IndexT, ValueT> {\n    index: Iterable<IndexT>;\n    values: Iterable<ValueT>;\n    pairs: Iterable<[IndexT, ValueT]>;\n\n    //\n    // Records if a series is baked into memory.\n    //\n    isBaked: boolean;\n}\n\n/**\n * Class that represents a series containing a sequence of indexed values.\n */\nexport class Series<IndexT = number, ValueT = any> implements ISeries<IndexT, ValueT> {\n\n    //\n    // Function to lazy evaluate the configuration of the series.\n    //\n    private configFn: SeriesConfigFn<IndexT, ValueT> | null = null;\n\n    //\n    // The content of the series.\n    // When this is null it means the series is yet to be lazy initialised.\n    //\n    private content: ISeriesContent<IndexT, ValueT> | null = null;\n\n    private static readonly defaultCountIterable = new CountIterable();\n    private static readonly defaultEmptyIterable = new EmptyIterable();\n\n    //\n    // Initialise series content from an array of values.\n    //\n    private static initFromArray<IndexT, ValueT>(arr: Iterable<ValueT>): ISeriesContent<IndexT, ValueT> {\n        return {\n            index: Series.defaultCountIterable,\n            values: arr,\n            pairs: new MultiIterable([Series.defaultCountIterable, arr]),\n            isBaked: true,\n        };\n    }\n\n    //\n    // Initialise an empty series.\n    //\n    private static initEmpty<IndexT, ValueT>(): ISeriesContent<IndexT, ValueT> {\n        return {\n            index: Series.defaultEmptyIterable,\n            values: Series.defaultEmptyIterable,\n            pairs: Series.defaultEmptyIterable,\n            isBaked: true,\n        };\n    }\n\n    //\n    // Check that a value is an interable.\n    //\n    private static checkIterable<T>(input: T[] | Iterable<T>, fieldName: string): void {\n        if (isArray(input)) {\n            // Ok\n        }\n        else if (isFunction(input[Symbol.iterator])) {\n            // Assume it's an iterable.\n            // Ok\n        }\n        else {\n            // Not ok\n            throw new Error(\"Expected '\" + fieldName + \"' field of Series config object to be an array of values or an iterable of values.\");\n        }\n    };\n\n    //\n    // Initialise series content from a config object.\n    //\n    private static initFromConfig<IndexT, ValueT>(config: ISeriesConfig<IndexT, ValueT>): ISeriesContent<IndexT, ValueT> {\n\n        let index: Iterable<IndexT>;\n        let values: Iterable<ValueT>;\n        let pairs: Iterable<[IndexT, ValueT]> | undefined;\n        let isBaked = false;\n\n        if (config.pairs) {\n            Series.checkIterable<[IndexT, ValueT]>(config.pairs, \"pairs\");\n            pairs = config.pairs;\n        }\n\n        if (config.index) {\n            Series.checkIterable<IndexT>(config.index, \"index\")\n            index = config.index;\n        }\n        else if (pairs) {\n            index = new ExtractElementIterable(pairs, 0);\n        }\n        else {\n            index = Series.defaultCountIterable;\n        }\n\n        if (config.values) {\n            Series.checkIterable<ValueT>(config.values, \"values\");\n            values = config.values;\n        }\n        else if (pairs) {\n            values = new ExtractElementIterable(pairs, 1);\n        }\n        else {\n            values = Series.defaultEmptyIterable;\n        }\n\n        if (!pairs) {\n            pairs = new MultiIterable([index, values]);\n        }\n\n        if (config.baked !== undefined) {\n            isBaked = config.baked;\n        }\n\n        return {\n            index: index,\n            values: values,\n            pairs: pairs,\n            isBaked: isBaked,\n        };\n    }\n\n    /**\n     * Create a series.\n     * \n     * @param config This can be an array, a configuration object or a function that lazily produces a configuration object. \n     * \n     * It can be an array that specifies the values that the series contains.\n     * \n     * It can be a {@link ISeriesConfig} that defines the values and configuration of the series.\n     * \n     * Or it can be a function that lazily produces a {@link ISeriesConfig}.\n     * \n     * @example\n     * <pre>\n     * \n     * const series = new Series();\n     * </pre>\n     * \n     * @example\n     * <pre>\n     * \n     * const series = new Series([10, 20, 30, 40]);\n     * </pre>\n     * \n     * @example\n     * <pre>\n     * \n     * const series = new Series({ index: [1, 2, 3, 4], values: [10, 20, 30, 40]});\n     * </pre>\n     * \n     * @example\n     * <pre>\n     * \n     * const lazyInit = () => ({ index: [1, 2, 3, 4], values: [10, 20, 30, 40] });\n     * const series = new Series(lazyInit);\n     * </pre>\n     */\n    constructor(config?: Iterable<ValueT> | ISeriesConfig<IndexT, ValueT> | SeriesConfigFn<IndexT, ValueT>) {\n        if (config) {\n            if (isFunction(config)) {\n                this.configFn = config;\n            }\n            else if (isArray(config) || \n                     isFunction((config as any)[Symbol.iterator])) {\n                this.content = Series.initFromArray(config as Iterable<ValueT>);\n            }\n            else {\n                this.content = Series.initFromConfig(config as ISeriesConfig<IndexT, ValueT>);\n            }\n        }\n        else {\n            this.content = Series.initEmpty();\n        }\n    }\n\n    //\n    // Ensure the series content has been initialised.\n    //\n    private lazyInit() {\n        if (this.content === null && this.configFn !== null) {\n            this.content = Series.initFromConfig(this.configFn());\n        }\n    }\n\n    //\n    // Ensure the series content is lazy initalised and return it.\n    //\n    private getContent(): ISeriesContent<IndexT, ValueT> { \n        this.lazyInit();\n        return this.content!;\n    }\n\n    /**\n     * Get an iterator to enumerate the values of the series.\n     * Enumerating the iterator forces lazy evaluation to complete.\n     * This function is automatically called by `for...of`.\n     * \n     * @return An iterator for the series.\n     * \n     * @example\n     * <pre>\n     * \n     * for (const value of series) {\n     *     // ... do something with the value ...\n     * }\n     * </pre>\n     */\n    [Symbol.iterator](): Iterator<ValueT> {\n        return this.getContent().values[Symbol.iterator]();\n    }\n\n    /**\n     * Cast the value of the series to a new type.\n     * This operation has no effect but to retype the values that the series contains.\n     * \n     * @return The same series, but with the type changed.\n     * \n     * @example\n     * <pre>\n     * \n     * const castSeries = series.cast<SomeOtherType>();\n     * </pre>\n     */\n    cast<NewValueT> (): ISeries<IndexT, NewValueT> {\n        return this as any as ISeries<IndexT, NewValueT>;\n    }\n    \n    /**\n     * Get the index for the series.\n     * \n     * @return The {@link Index} for the series.\n     * \n     * @example\n     * <pre>\n     * \n     * const index = series.getIndex();\n     * </pre>\n     */\n    getIndex (): IIndex<IndexT> {\n        return new Index<IndexT>(() => ({ values: this.getContent().index }));\n    }\n\n    /**\n     * Apply a new {@link Index} to the series.\n     * \n     * @param newIndex The new array or iterable to be the new {@link Index} of the series. Can also be a selector to choose the {@link Index} for each value in the series.\n     * \n     * @return Returns a new series with the specified {@link Index} attached.\n     * \n     * @example\n     * <pre>\n     * \n     * const indexedSeries = series.withIndex([10, 20, 30]);\n     * </pre>\n     * \n     * @example\n     * <pre>\n     * \n     * const indexedSeries = series.withIndex(someOtherSeries);\n     * </pre>\n     * \n     * @example\n     * <pre>\n     * \n     * const indexedSeries = series.withIndex(value => computeIndexFromValue(value));\n     * </pre>\n     * \n     * @example\n     * <pre>\n     * \n     * const indexedSeries = series.withIndex(value => value + 20);\n     * </pre>\n     */\n    withIndex<NewIndexT> (newIndex: Iterable<NewIndexT> | SelectorFn<ValueT, NewIndexT>): ISeries<NewIndexT, ValueT> {\n\n        if (isFunction(newIndex)) {\n            return new Series<NewIndexT, ValueT>(() => ({\n                values: this.getContent().values,\n                index: this.select(newIndex),\n            }));\n        }\n        else {\n            Series.checkIterable(newIndex as Iterable<NewIndexT>, 'newIndex');\n            \n            return new Series<NewIndexT, ValueT>(() => ({\n                values: this.getContent().values,\n                index: newIndex as Iterable<NewIndexT>,\n            }));\n        }\n    };\n\n    /**\n     * Resets the {@link Index} of the series back to the default zero-based sequential integer index.\n     * \n     * @return Returns a new series with the {@link Index} reset to the default zero-based index. \n     * \n     * @example\n     * <pre>\n     * \n     * const seriesWithResetIndex = series.resetIndex();\n     * </pre>\n     */\n    resetIndex (): ISeries<number, ValueT> {\n        return new Series<number, ValueT>(() => ({\n            values: this.getContent().values // Just strip the index.\n        }));\n    }\n\n    /**\n     * Merge multiple series into a single series.\n     * Values are merged by index.\n     * Values at each index are combined into arrays in the resulting series.\n     * \n     * @param series An array or series of series to merge.\n     * \n     * @returns The merged series.\n     * \n     * @example\n     * <pre>\n     * \n     * const mergedSeries = Series.merge([series1, series2, etc]);\n     * </pre>\n     */\n    static merge<MergedValueT = any, IndexT = any>(series: Iterable<ISeries<IndexT, any>>): ISeries<IndexT, MergedValueT[]> {\n\n        const rowMap = new Map<IndexT, any[]>();\n        const numSeries = Array.from(series).length; //TODO: Be nice not to have to do this.\n        let seriesIndex = 0;\n        for (const workingSeries of series) {\n            for (const pair of workingSeries.toPairs()) {\n                const index = pair[0];\n                if (!rowMap.has(index)) {\n                    rowMap.set(index, new Array(numSeries));\n                }\n\n                rowMap.get(index)![seriesIndex] = pair[1];\n            }\n\n            ++seriesIndex;\n        }\n\n        const mergedPairs = Array.from(rowMap.keys())\n            .map(index => [index, rowMap.get(index)] as [IndexT, MergedValueT[]]);\n\n        mergedPairs.sort((a, b) => { // Sort by index, ascending.\n            if (a[0] === b[0]) {\n                return 0;\n            }\n            else if (a[0] > b[0]) {\n                return 1;\n            }\n            else {\n                return -1;\n            }\n        });\n\n        return new Series<IndexT, MergedValueT[]>({\n            pairs: mergedPairs,\n        });\n    }\n\n   /**\n     * Merge one or more series into this series.\n     * Values are merged by index.\n     * Values at each index are combined into arrays in the resulting series.\n     * \n     * @param series... One or more other series to merge into the series.\n     * \n     * @returns The merged series.\n     * \n     * @example\n     * <pre>\n     * \n     * const mergedSeries = series1.merge(series2);\n     * </pre>\n     * \n     * <pre>\n     * \n     * const mergedSeries = series1.merge(series2, series3, etc);\n     * </pre>\n     */\n    merge<MergedValueT = any>(...args: any[]): ISeries<IndexT, MergedValueT[]> {\n        return Series.merge<MergedValueT, IndexT>([this].concat(args));\n    }\n    \n    /**\n    * Extract values from the series as an array.\n    * This forces lazy evaluation to complete.\n    * \n    * @return Returns an array of the values contained within the series.\n    * \n    * @example\n    * <pre>\n    * const values = series.toArray();\n    * </pre>\n    */\n   toArray (): any[] {\n        const values = [];\n        for (const value of this.getContent().values) {\n            if (value !== undefined) {\n                values.push(value);\n            }\n        }\n        return values;\n    }\n\n    /**\n     * Retreive the index, values pairs from the series as an array.\n     * Each pair is [index, value].\n     * This forces lazy evaluation to complete.\n     * \n     * @return Returns an array of pairs that contains the series values. Each pair is a two element array that contains an index and a value.\n     * \n     * @example\n     * <pre>\n     * const pairs = series.toPairs();\n     * </pre>\n     */\n    toPairs (): ([IndexT, ValueT])[] {\n        const pairs = [];\n        for (const pair of this.getContent().pairs) {\n            if (pair[1] != undefined) {\n                pairs.push(pair);\n            }\n        }\n        return pairs;\n    }\n\n    /**\n     * Convert the series to a JavaScript object.\n     *\n     * @param keySelector User-defined selector function that selects keys for the resulting object.\n     * @param valueSelector User-defined selector function that selects values for the resulting object.\n     * \n     * @return Returns a JavaScript object generated from the series by applying the key and value selector functions. \n     * \n     * @example\n     * <pre>\n     * \n     * const someObject = series.toObject(\n     *      value => value, // Specify the value to use for field names in the output object.\n     *      value => value // Specify the value to use as the value for each field.\n     * );\n     * </pre>\n     */\n    toObject<KeyT = any, FieldT = any, OutT = any> (keySelector: (value: ValueT) => KeyT, valueSelector: (value: ValueT) => FieldT): OutT {\n\n        if (!isFunction(keySelector)) throw new Error(\"Expected 'keySelector' parameter to Series.toObject to be a function.\");\n        if (!isFunction(valueSelector)) throw new Error(\"Expected 'valueSelector' parameter to Series.toObject to be a function.\");\n\n        return toMap(this, keySelector, valueSelector);\n    }\n    \n    /**\n     * Generates a new series by repeatedly calling a user-defined selector function on each value in the original series.\n     *\n     * @param selector A user-defined selector function that transforms each row to create the new dataframe.\n     * \n     * @return Returns a new series with each value transformed by the selector function.\n     * \n     * @example\n     * <pre>\n     * \n     * function transformValue (inputValue) {\n     *      const outputValue = {\n     *          // ... construct output value derived from input value ...\n     *      };\n     *\n     *      return outputValue;\n     * }\n     *  \n     * const transformedSeries = series.select(value => transformValue(value));\n     * </pre>\n     */\n    select<ToT> (selector: SelectorWithIndexFn<ValueT, ToT>): ISeries<IndexT, ToT> {\n        if (!isFunction(selector)) throw new Error(\"Expected 'selector' parameter to 'Series.select' function to be a function.\");\n\n        return new Series(() => ({\n            values: new SelectIterable(this.getContent().values, selector),\n            index: this.getContent().index,\n        }));\n    }\n\n    /**\n     * Generates a new series by repeatedly calling a user-defined selector function on each row in the original series.\n     * \n     * Similar to the {@link select} function, but in this case the selector function produces a collection of output values that are flattened and merged to create the new series.\n     *\n     * @param selector A user-defined selector function that transforms each value into a collection of output values.\n     * \n     * @return Returns a new series where each value has been transformed into 0 or more new values by the selector function. \n     * \n     * @example\n     * <pre>\n     * \n     * function produceOutputValues (inputValue) {\n     *      const outputValues = [];\n     *      while (someCondition) {\n     *          // ... generate zero or more output values ...\n     *          outputValues.push(... some generated value ...);\n     *      }\n     *      return outputValues;\n     * }\n     * \n     * const modifiedSeries = series.selectMany(value => produceOutputValues(value));\n     * </pre>\n     */\n    selectMany<ToT> (selector: SelectorWithIndexFn<ValueT, Iterable<ToT>>): ISeries<IndexT, ToT> {\n        if (!isFunction(selector)) throw new Error(\"Expected 'selector' parameter to 'Series.selectMany' to be a function.\");\n\n        return new Series(() => ({\n            pairs: new SelectManyIterable(\n                this.getContent().pairs, \n                (pair: [IndexT, ValueT], index: number): Iterable<[IndexT, ToT]> => {\n                    const outputPairs: [IndexT, ToT][] = [];\n                    for (const transformed of selector(pair[1], index)) {\n                        outputPairs.push([\n                            pair[0],\n                            transformed\n                        ]);\n                    }\n                    return outputPairs;\n                }\n            )\n        }));\n    }\n\n    /**\n     * Partition a series into a {@link Series} of *data windows*. \n     * Each value in the new series is a chunk of data from the original series.\n     *\n     * @param period The number of values to include in each data window.\n     * \n     * @return Returns a new series, each value of which is a chunk (data window) of the original series.\n     * \n     * @example\n     * <pre>\n     * \n     * const windows = series.window(2); // Get values in pairs.\n     * const pctIncrease = windows.select(pair => (pair.last() - pair.first()) / pair.first());\n     * console.log(pctIncrease.toString());\n     * </pre>\n     * \n     * @example\n     * <pre>\n     * \n     * const salesDf = ... // Daily sales data.\n     * const weeklySales = salesDf.window(7); // Partition up into weekly data sets.\n     * console.log(weeklySales.toString());\n     * </pre>\n     */\n    window (period: number): ISeries<number, ISeries<IndexT, ValueT>> {\n\n        if (!isNumber(period)) throw new Error(\"Expected 'period' parameter to 'Series.window' to be a number.\");\n\n        return new Series<number, ISeries<IndexT, ValueT>>(() => ({\n            values: new SeriesWindowIterable<IndexT, ValueT>(this.getContent().pairs, period)\n        }));\n    }\n\n    /** \n     * Partition a series into a new series of *rolling data windows*. \n     * Each value in the new series is a rolling chunk of data from the original series.\n     *\n     * @param period The number of data values to include in each data window.\n     * \n     * @return Returns a new series, each value of which is a rolling chunk of the original series.\n     * \n     * @example\n     * <pre>\n     * \n     * const salesData = ... // Daily sales data.\n     * const rollingWeeklySales = salesData.rollingWindow(7); // Get rolling window over weekly sales data.\n     * console.log(rollingWeeklySales.toString());\n     * </pre>\n     */\n    rollingWindow (period: number): ISeries<number, ISeries<IndexT, ValueT>> {\n\n        if (!isNumber(period)) throw new Error(\"Expected 'period' parameter to 'Series.rollingWindow' to be a number.\");\n\n        return new Series<number, ISeries<IndexT, ValueT>>(() => ({\n            values: new SeriesRollingWindowIterable<IndexT, ValueT>(this.getContent().pairs, period)\n        }));\n    }\n\n    /**\n     * Partition a series into a new series of variable-length *data windows* \n     * where the divisions between the data chunks are\n     * defined by a user-provided *comparer* function.\n     * \n     * @param comparer Function that compares two adjacent data values and returns true if they should be in the same window.\n     * \n     * @return Returns a new series, each value of which is a chunk of data from the original series.\n     * \n     * @example\n     * <pre>\n     * \n     * function rowComparer (valueA, valueB) {\n     *      if (... valueA should be in the same data window as valueB ...) {\n     *          return true;\n     *      }\n     *      else {\n     *          return false;\n     *      }\n     * };\n     * \n     * const variableWindows = series.variableWindow(rowComparer);\n     */\n    variableWindow (comparer: ComparerFn<ValueT, ValueT>): ISeries<number, ISeries<IndexT, ValueT>> {\n        \n        if (!isFunction(comparer)) throw new Error(\"Expected 'comparer' parameter to 'Series.variableWindow' to be a function.\")\n\n        return new Series<number, ISeries<IndexT, ValueT>>(() => ({\n            values: new SeriesVariableWindowIterable<IndexT, ValueT>(this.getContent().pairs, comparer)\n        }));\n    };    \n\n    /**\n     * Eliminates adjacent duplicate values.\n     * \n     * For each group of adjacent values that are equivalent only returns the last index/row for the group, \n     * thus ajacent equivalent values are collapsed down to the last value.\n     *\n     * @param [selector] Optional selector function to determine the value used to compare for equivalence.\n     * \n     * @return Returns a new series with groups of adjacent duplicate vlaues collapsed to a single value per group.\n     * \n     * @example\n     * <pre>\n     * \n     * const seriesWithDuplicateRowsRemoved = series.sequentialDistinct(value => value);\n     * \n     * // Or\n     * const seriesWithDuplicateRowsRemoved = series.sequentialDistinct(value => value.someNestedField);\n     * </pre>\n     */\n    sequentialDistinct<ToT = ValueT> (selector?: SelectorFn<ValueT, ToT>): ISeries<IndexT, ValueT> {\n        \n        if (selector) {\n            if (!isFunction(selector)) throw new Error(\"Expected 'selector' parameter to 'Series.sequentialDistinct' to be a selector function that determines the value to compare for duplicates.\")\n        }\n        else {\n            selector = (value: ValueT): ToT => <ToT> <any> value;\n        }\n\n        return this.variableWindow((a, b) => selector!(a) === selector!(b))\n            .select((window): [IndexT, ValueT] => {\n                return [window.getIndex().first(), window.first()] ;\n            })\n            .withIndex(pair => pair[0])\n            .select(pair => pair[1]);\n    }\n\n    /**\n     * Aggregate the values in the series to a single result.\n     *\n     * @param [seed] Optional seed value for producing the aggregation.\n     * @param selector Function that takes the seed and then each value in the series and produces the aggregated value.\n     * \n     * @return Returns a new value that has been aggregated from the series using the 'selector' function. \n     * \n     * @example\n     * <pre>\n     * \n     * const dailySales = ... daily sales figures for the past month ...\n     * const totalSalesForthisMonth = dailySales.aggregate(\n     *      0, // Seed - the starting value.\n     *      (accumulator, salesAmount) => accumulator + salesAmount // Aggregation function.\n     * );\n     * </pre>\n     * \n     * @example\n     * <pre>\n     * \n     * const totalSalesAllTime = 500; // We'll seed the aggregation with this value.\n     * const dailySales = ... daily sales figures for the past month ...\n     * const updatedTotalSalesAllTime = dailySales.aggregate(\n     *      totalSalesAllTime, \n     *      (accumulator, salesAmount) => accumulator + salesAmount\n     * );\n     * </pre>\n     * \n     * @example\n     * <pre>\n     * \n     * var salesDataSummary = salesData.aggregate({\n     *      TotalSales: series => series.count(),\n     *      AveragePrice: series => series.average(),\n     *      TotalRevenue: series => series.sum(), \n     * });\n     * </pre>\n    */\n   aggregate<ToT = ValueT> (seedOrSelector: AggregateFn<ValueT, ToT> | ToT, selector?: AggregateFn<ValueT, ToT>): ToT {\n\n        if (isFunction(seedOrSelector) && !selector) {\n            return this.skip(1).aggregate(<ToT> <any> this.first(), seedOrSelector);\n        }\n        else {\n            if (!isFunction(selector)) throw new Error(\"Expected 'selector' parameter to aggregate to be a function.\");\n\n            let accum = <ToT> seedOrSelector;\n\n            for (const value of this) {\n                accum = selector!(accum, value);\n            }\n\n            return accum;\n        }\n    }\n   \n    /**\n     * Compute the amount of change between pairs or sets of values in the series.\n     * \n     * @param [period] Optional period for computing the change - defaults to 2.\n     * \n     * @returns Returns a new series where each value indicates the amount of change from the previous number value in the original series.  \n     * \n     * @example\n     * <pre>\n     * \n     * const saleFigures = ... running series of daily sales figures ...\n     * const amountChanged = salesFigures.amountChanged(); // Amount that sales has changed, day to day.\n     * </pre>\n     * @example\n     * <pre>\n     * \n     * const saleFigures = ... running series of daily sales figures ...\n     * const amountChanged = salesFigures.amountChanged(7); // Amount that sales has changed, week to week.\n     * </pre>\n     */\n    amountChange (period?: number): ISeries<IndexT, number> {\n        return (<ISeries<IndexT, number>> <any> this) // Have to assume this is a number series.\n            .rollingWindow(period === undefined ? 2 : period)\n            .select((window): [IndexT, number] => {\n                const first = window.first();\n                const last = window.last();\n                const amountChange = last - first; // Compute amount of change.\n                return [window.getIndex().last(), amountChange]; // Return new index and value.\n            })\n            .withIndex(pair => pair[0])\n            .select(pair => pair[1]);\n    }   \n\n    /**\n     * Compute the proportion change between pairs or sets of values in the series.\n     * Proportions are expressed as 0-1 values.\n     * \n     * @param [period] Optional period for computing the proportion - defaults to 2.\n     * \n     * @returns Returns a new series where each value indicates the proportion change from the previous number value in the original series.\n     * \n     * @example\n     * <pre>\n     * \n     * const saleFigures = ... running series of daily sales figures ...\n     * const proportionChanged = salesFigures.amountChanged(); // Proportion that sales has changed, day to day.\n     * </pre>\n     * @example\n     * <pre>\n     * \n     * const saleFigures = ... running series of daily sales figures ...\n     * const proportionChanged = salesFigures.amountChanged(7); // Proportion that sales has changed, week to week.\n     * </pre>\n     */\n    proportionChange (period?: number): ISeries<IndexT, number> {\n        return (<ISeries<IndexT, number>> <any> this) // Have to assume this is a number series.\n            .rollingWindow(period === undefined ? 2 : period)\n            .select((window): [IndexT, number] => {\n                const first = window.first();\n                const last = window.last();\n                const amountChange = last - first; // Compute amount of change.\n                const pctChange = amountChange / first; // Compute proportion change.\n                return [window.getIndex().last(), pctChange]; // Return new index and value.\n            })\n            .withIndex(pair => pair[0])\n            .select(pair => pair[1]);\n    }    \n\n    /**\n     * Compute the percentage change between pairs or sets of values in the series.\n     * Percentages are expressed as 0-100 values.\n     * \n     * @param [period] Optional period for computing the percentage - defaults to 2.\n     * \n     * @returns Returns a new series where each value indicates the percent change from the previous number value in the original series.\n     * \n     * @example\n     * <pre>\n     * \n     * const saleFigures = ... running series of daily sales figures ...\n     * const percentChanged = salesFigures.amountChanged(); // Percent that sales has changed, day to day.\n     * </pre>\n     * @example\n     * <pre>\n     * \n     * const saleFigures = ... running series of daily sales figures ...\n     * const percentChanged = salesFigures.amountChanged(7); // Percent that sales has changed, week to week.\n     * </pre>\n     */\n    percentChange (period?: number): ISeries<IndexT, number> {\n        return this.proportionChange(period).select(v => v * 100);\n    }    \n    \n    /**\n     * For each period, compute the proportion of values that are less than the last value in the period.\n     * Proportions are expressed as 0-1 values.\n     * \n     * @param [period] Optional period for computing the proportion rank - defaults to 2.\n     * \n     * @returns Returns a new series where each value indicates the proportion rank value for that period.\n     * \n     * @example\n     * <pre>\n     * \n     * const proportionRank = series.proportionRank();\n     * </pre>\n     * @example\n     * <pre>\n     * \n     * const proportionRank = series.proportionRank(100);\n     * </pre>\n     */\n    proportionRank (period?: number): ISeries<IndexT, number> {\n        if (period === undefined) {\n            period = 2;\n        }\n\n        if (!isNumber(period)) {\n            throw new Error(\"Expected 'period' parameter to 'Series.proportionRank' to be a number that specifies the time period for the ranking.\");\n        }\n    \n        return this.rollingWindow(period+1) // +1 to account for the last value being used.\n            .select<[IndexT, number]>(window => {\n                const latestValue = window.last();\n                const numLowerValues = window.head(-1).where(prevMomentum => prevMomentum < latestValue).count();\n                const proportionRank = numLowerValues / period!;\n                return [\n                    window.getIndex().last(),\n                    proportionRank\n                ];\n            })\n            .withIndex(pair => pair[0])\n            .select(pair => pair[1]);\n    }\n\n    /**\n     * For each period, compute the percent of values that are less than the last value in the period.\n     * Percent are expressed as 0-100 values.\n     * \n     * @param [period] Optional period for computing the percent rank - defaults to 2.\n     * \n     * @returns Returns a new series where each value indicates the percent rank value for that period.\n     * \n     * @example\n     * <pre>\n     * \n     * const percentRank = series.percentRank();\n     * </pre>\n     * @example\n     * <pre>\n     * \n     * const percentRank = series.percentRank(100);\n     * </pre>\n     */\n    percentRank (period?: number): ISeries<IndexT, number> {\n        if (period === undefined) {\n            period = 2;\n        }\n\n        if (!isNumber(period)) {\n            throw new Error(\"Expected 'period' parameter to 'Series.percentRank' to be a number that specifies the time period for the ranking.\");\n        }\n    \n        return this.proportionRank(period).select(proportion => proportion * 100);\n    }\n    \n    /**\n     * Skip a number of values in the series.\n     *\n     * @param numValues Number of values to skip.\n     * \n     * @return Returns a new series with the specified number of values skipped.\n     * \n     * @example\n     * <pre>\n     * \n     * const seriesWithRowsSkipped = series.skip(10); // Skip 10 rows in the original series.\n     * </pre>\n     */\n    skip (numValues: number): ISeries<IndexT, ValueT> {\n        return new Series<IndexT, ValueT>(() => ({\n            values: new SkipIterable(this.getContent().values, numValues),\n            index: new SkipIterable(this.getContent().index, numValues),\n            pairs: new SkipIterable(this.getContent().pairs, numValues),\n        }));\n    }\n    \n    /**\n     * Skips values in the series while a condition evaluates to true or truthy.\n     *\n     * @param predicate Returns true/truthy to continue to skip values in the original series.\n     * \n     * @return Returns a new series with all initial sequential values removed while the predicate returned true/truthy.\n     * \n     * @example\n     * <pre>\n     * \n     * const seriesWithRowsSkipped = series.skipWhile(salesFigure => salesFigure > 100); // Skip initial sales figure that are less than 100.\n     * </pre>\n     */\n    skipWhile (predicate: PredicateFn<ValueT>): ISeries<IndexT, ValueT> {\n        if (!isFunction(predicate)) throw new Error(\"Expected 'predicate' parameter to 'Series.skipWhile' function to be a predicate function that returns true/false.\");\n\n        return new Series<IndexT, ValueT>(() => ({\n            values: new SkipWhileIterable(this.getContent().values, predicate),\n            pairs: new SkipWhileIterable(this.getContent().pairs, pair => predicate(pair[1])),\n        }));\n    }\n\n    /**\n     * Skips values in the series untils a condition evaluates to true or truthy.\n     *\n     * @param predicate Return true/truthy to stop skipping values in the original series.\n     * \n     * @return Returns a new series with all initial sequential values removed until the predicate returned true/truthy.\n     * \n     * @example\n     * <pre>\n     * \n     * const seriesWithRowsSkipped = series.skipUntil(salesFigure => salesFigure > 100); // Skip initial sales figures unitl we see one greater than 100.\n     * </pre>\n     */\n    skipUntil (predicate: PredicateFn<ValueT>): ISeries<IndexT, ValueT> {\n        if (!isFunction(predicate)) throw new Error(\"Expected 'predicate' parameter to 'Series.skipUntil' function to be a predicate function that returns true/false.\");\n\n        return this.skipWhile(value => !predicate(value)); \n    }\n\n    /**\n     * Take a number of  values from the series.\n     *\n     * @param numValues Number of values to take.\n     * \n     * @return Returns a new series with only the specified number of values taken from the original series.\n     * \n     * @example\n     * <pre>\n     * \n     * const seriesWithRowsTaken = series.take(15); // Take only the first 15 values from the original series.\n     * </pre>\n     */\n    take (numRows: number): ISeries<IndexT, ValueT> {\n        if (!isNumber(numRows)) throw new Error(\"Expected 'numRows' parameter to 'Series.take' function to be a number.\");\n\n        return new Series(() => ({\n            index: new TakeIterable(this.getContent().index, numRows),\n            values: new TakeIterable(this.getContent().values, numRows),\n            pairs: new TakeIterable(this.getContent().pairs, numRows)\n        }));\n    };\n\n    /**\n     * Takes values from the series while a condition evaluates to true or truthy.\n     *\n     * @param predicate Returns true/truthy to continue to take values from the original series.\n     * \n     * @return Returns a new series with only the initial sequential values that were taken while the predicate returned true/truthy.\n     * \n     * @example\n     * <pre>\n     * \n     * const seriesWithRowsTaken = series.takeWhile(salesFigure => salesFigure > 100); // Take only initial sales figures that are greater than 100.\n     * </pre>\n     */\n    takeWhile (predicate: PredicateFn<ValueT>): ISeries<IndexT, ValueT> {\n        if (!isFunction(predicate)) throw new Error(\"Expected 'predicate' parameter to 'Series.takeWhile' function to be a predicate function that returns true/false.\");\n\n        return new Series(() => ({\n            values: new TakeWhileIterable(this.getContent().values, predicate),\n            pairs: new TakeWhileIterable(this.getContent().pairs, pair => predicate(pair[1]))\n        }));\n    }\n\n    /**\n     * Takes values from the series until a condition evaluates to true or truthy.\n     *\n     * @param predicate Return true/truthy to stop taking values in the original series.\n     * \n     * @return Returns a new series with only the initial sequential values taken until the predicate returned true/truthy.\n     * \n     * @example\n     * <pre>\n     * \n     * const seriesWithRowsTaken = series.takeUntil(salesFigure => salesFigure > 100); // Take all initial sales figures until we see one that is greater than 100.\n     * </pre>\n     */\n    takeUntil (predicate: PredicateFn<ValueT>): ISeries<IndexT, ValueT> {\n        if (!isFunction(predicate)) throw new Error(\"Expected 'predicate' parameter to 'Series.takeUntil' function to be a predicate function that returns true/false.\");\n\n        return this.takeWhile(value => !predicate(value));\n    }\n\n    /**\n     * Static version of the count function for use with summarize and pivot functions.\n     * \n     * @param series Input series to be counted.\n     * \n     * @returns Returns the count of values in the series.\n     * \n     * @example\n     * <pre>\n     * \n     * const summary = dataFrame.summarize({\n     *      ColumnToBeCounted: Series.count,\n     * });\n     * </pre>\n     */\n    static count<IndexT = any> (series: ISeries<IndexT, number>): number {\n        return series.count();\n    }\n    \n    /**\n     * Count the number of values in the seriese\n     *\n     * @return Returns the count of all values.\n     * \n     * @example\n     * <pre>\n     * \n     * const numValues = series.count();\n     * </pre>\n     */\n    count (): number {\n\n        let total = 0;\n        for (const value of this.getContent().values) {\n            ++total;\n        }\n        return total;\n    }\n\n    /**\n     * Get the first value of the series.\n     *\n     * @return Returns the first value of the series.\n     * \n     * @example\n     * <pre>\n     * \n     * const firstValue = series.first();\n     * </pre>\n     */\n    first (): ValueT {\n\n        for (const value of this) {\n            return value; // Only need the first value.\n        }\n\n        throw new Error(\"Series.first: No values in Series.\");\n    }\n\n    /**\n     * Get the last value of the series.\n     *\n     * @return Returns the last value of the series.\n     * \n     * @example\n     * <pre>\n     * \n     * const lastValue = series.last();\n     * </pre>\n     */\n    last (): ValueT {\n\n        let lastValue = null;\n\n        for (const value of this) {\n            lastValue = value; // Throw away all values until we get to the last one.\n        }\n\n        if (lastValue === null) {\n            throw new Error(\"Series.last: No values in Series.\");\n        }\n\n        return lastValue;\n    }    \n    \n    /**\n     * Get the value, if there is one, with the specified index.\n     *\n     * @param index Index to for which to retreive the value.\n     *\n     * @return Returns the value from the specified index in the series or undefined if there is no such index in the present in the series.\n     * \n     * @example\n     * <pre>\n     * \n     * const value = series.at(5); // Get the value at index 5 (with a default 0-based index).\n     * </pre>\n     * \n     * @example\n     * <pre>\n     * \n     * const date = ... some date ...\n     * // Retreive the value with specified date from a time-series (assuming date indexed has been applied).\n     * const value = series.at(date); \n     * </pre>\n     */\n    at (index: IndexT): ValueT | undefined {\n\n        if (this.none()) {\n            return undefined;\n        }\n\n        //\n        // This is pretty expensive.\n        // A specialised index could improve this.\n        //\n\n        for (const pair of this.getContent().pairs) {\n            if (pair[0] === index) {\n                return pair[1];\n            }\n        }\n\n        return undefined;\n    }\n    \n    /** \n     * Get X value from the start of the series.\n     * Pass in a negative value to get all values at the head except for X values at the tail.\n     *\n     * @param numValues Number of values to take.\n     * \n     * @return Returns a new series that has only the specified number of values taken from the start of the original series.\n     * \n     * @examples\n     * <pre>\n     * \n     * const sample = series.head(10); // Take a sample of 10 values from the start of the series.\n     * </pre>\n     */\n    head (numValues: number): ISeries<IndexT, ValueT> {\n\n        if (!isNumber(numValues)) throw new Error(\"Expected 'numValues' parameter to 'Series.head' function to be a number.\");\n\n        if (numValues === 0) {\n            return new Series<IndexT, ValueT>(); // Empty series.\n        }\n\n        const toTake = numValues < 0 ? this.count() - Math.abs(numValues) : numValues;\n        return this.take(toTake);\n    }\n\n    /** \n     * Get X values from the end of the series.\n     * Pass in a negative value to get all values at the tail except X values at the head.\n     *\n     * @param numValues Number of values to take.\n     * \n     * @return Returns a new series that has only the specified number of values taken from the end of the original series.  \n     * \n     * @examples\n     * <pre>\n     * \n     * const sample = series.tail(12); // Take a sample of 12 values from the end of the series.\n     * </pre>\n     */\n    tail (numValues: number): ISeries<IndexT, ValueT> {\n\n        if (!isNumber(numValues)) throw new Error(\"Expected 'numValues' parameter to 'Series.tail' function to be a number.\");\n\n        if (numValues === 0) {\n            return new Series<IndexT, ValueT>(); // Empty series.\n        }\n\n        const toSkip = numValues > 0 ? this.count() - numValues : Math.abs(numValues);\n        return this.skip(toSkip);\n    }\n\n    /**\n     * Filter the series using user-defined predicate function.\n     *\n     * @param predicate Predicte function to filter values from the series. Returns true/truthy to keep values, or false/falsy to omit values.\n     * \n     * @return Returns a new series containing only the values from the original series that matched the predicate. \n     * \n     * @example\n     * <pre>\n     * \n     * const filtered = series.where(salesFigure => salesFigure > 100); // Filter so we only have sales figures greater than 100.\n     * </pre>\n     */\n    where (predicate: PredicateFn<ValueT>): ISeries<IndexT, ValueT> {\n\n        if (!isFunction(predicate)) throw new Error(\"Expected 'predicate' parameter to 'Series.where' function to be a function.\");\n\n        return new Series(() => ({\n            values: new WhereIterable(this.getContent().values, predicate),\n            pairs: new WhereIterable(this.getContent().pairs, pair => predicate(pair[1]))\n        }));\n    }\n\n    /**\n     * Invoke a callback function for each value in the series.\n     *\n     * @param callback The calback function to invoke for each value.\n     * \n     * @return Returns the original series with no modifications.\n     * \n     * @example\n     * <pre>\n     * \n     * series.forEach(value => {\n     *      // ... do something with the value ...\n     * });\n     * </pre>\n     */\n    forEach (callback: CallbackFn<ValueT>): ISeries<IndexT, ValueT> {\n        if (!isFunction(callback)) throw new Error(\"Expected 'callback' parameter to 'Series.forEach' to be a function.\");\n\n        let index = 0;\n        for (const value of this) {\n            callback(value, index++);\n        }\n\n        return this;\n    };\n\n    /**\n     * Evaluates a predicate function for every value in the series to determine \n     * if some condition is true/truthy for **all** values in the series.\n     * \n     * @param predicate Predicate function that receives each value. It should returns true/truthy for a match, otherwise false/falsy.\n     *\n     * @return Returns true if the predicate has returned true or truthy for every value in the series, otherwise returns false. Returns false for an empty series.\n     * \n     * @example\n     * <pre>\n     * \n     * const result = series.all(salesFigure => salesFigure > 100); // Returns true if all sales figures are greater than 100.\n     * </pre>\n     */\n    all (predicate: PredicateFn<ValueT>): boolean {\n        if (!isFunction(predicate)) throw new Error(\"Expected 'predicate' parameter to 'Series.all' to be a function.\")\n\n        let count = 0;\n\n        for (const value of this) {\n            if (!predicate(value)) {\n                return false;\n            }\n\n            ++count;\n        }\n\n        return count > 0;\n    }\n\n    /**\n     * Evaluates a predicate function for every value in the series to determine \n     * if some condition is true/truthy for **any** of values in the series.\n     * \n     * If no predicate is specified then it simply checks if the series contains more than zero values.\n     *\n     * @param [predicate] Optional predicate function that receives each value. It should return true/truthy for a match, otherwise false/falsy.\n     *\n     * @return Returns true if the predicate has returned truthy for any value in the series, otherwise returns false. \n     * If no predicate is passed it returns true if the series contains any values at all.\n     * Returns false for an empty series.\n     * \n     * @example\n     * <pre>\n     * \n     * const result = series.any(salesFigure => salesFigure > 100); // Do we have any sales figures greater than 100?\n     * </pre>\n     * \n     * @example\n     * <pre>\n     * \n     * const result = series.any(); // Do we have any sales figures at all?\n     * </pre>\n     */\n    any (predicate?: PredicateFn<ValueT>): boolean {\n        if (predicate) {\n            if (!isFunction(predicate)) throw new Error(\"Expected 'predicate' parameter to 'Series.any' to be a function.\")\n        }\n\n        if (predicate) {\n            // Use the predicate to check each value.\n            for (const value of this) {\n                if (predicate(value)) {\n                    return true;\n                }\n            }\n        }\n        else {\n            // Just check if there is at least one item.\n            const iterator = this[Symbol.iterator]()\n            return !iterator.next().done;\n        }\n\n        return false; // Nothing passed.\n    }\n\n    /**\n     * Evaluates a predicate function for every value in the series to determine \n     * if some condition is true/truthy for **none** of values in the series.\n     * \n     * If no predicate is specified then it simply checks if the series contains zero values.\n     *\n     * @param [predicate] Optional predicate function that receives each value. It should return true/truthy for a match, otherwise false/falsy.\n     *\n     * @return Returns true if the predicate has returned truthy for zero values in the series, otherwise returns false. Returns false for an empty series.\n     * \n     * @example\n     * <pre>\n     * \n     * const result = series.none(salesFigure => salesFigure > 100); // Do we have zero sales figures greater than 100?\n     * </pre>\n     * \n     * @example\n     * <pre>\n     * \n     * const result = series.none(); // Do we have zero sales figures?\n     * </pre>\n     */\n    none (predicate?: PredicateFn<ValueT>): boolean {\n\n        if (predicate) {\n            if (!isFunction(predicate)) throw new Error(\"Expected 'predicate' parameter to 'Series.none' to be a function.\")\n        }\n\n        if (predicate) {\n            // Use the predicate to check each value.\n            for (const value of this) {\n                if (predicate(value)) {\n                    return false;\n                }\n            }\n        }\n        else {\n            // Just check if empty.\n            const iterator = this[Symbol.iterator]()\n            return iterator.next().done;\n        }\n\n        return true; // Nothing failed the predicate.\n    }\n\n    /**\n     * Gets a new series containing all values starting at or after the specified index value.\n     * \n     * @param indexValue The index value at which to start the new series.\n     * \n     * @return Returns a new series containing all values starting at or after the specified index value. \n     * \n     * @example\n     * <pre>\n     * \n     * const series = new Series({ \n     *      index: [0, 1, 2, 3], // This is the default index.\n     *      values: [10, 20, 30, 40],\n     * });\n     * \n     * const lastHalf = series.startAt(2);\n     * expect(lastHalf.toArray()).to.eql([30, 40]);\n     * </pre>\n     * \n     * @example\n     * <pre>\n     * \n     * const timeSeries = ... a series indexed by date/time ...\n     * \n     * // Get all values starting at (or after) a particular date.\n     * const result = timeSeries.startAt(new Date(2016, 5, 4)); \n     * </pre>\n     */\n    startAt (indexValue: IndexT): ISeries<IndexT, ValueT> {\n        return new Series<IndexT, ValueT>(() => {\n            const lessThan = this.getIndex().getLessThan();\n            return {                \n                index: new SkipWhileIterable(this.getContent().index, index => lessThan(index, indexValue)),\n                pairs: new SkipWhileIterable(this.getContent().pairs, pair => lessThan(pair[0], indexValue)),\n            }\n        });\n    }\n\n    /**\n     * Gets a new series containing all values up until and including the specified index value (inclusive).\n     * \n     * @param indexValue The index value at which to end the new series.\n     * \n     * @return Returns a new series containing all values up until and including the specified index value.\n     * \n     * @example\n     * <pre>\n     * \n     * const series = new Series({ \n     *      index: [0, 1, 2, 3], // This is the default index.\n     *      values: [10, 20, 30, 40],\n     * });\n     * \n     * const firstHalf = series.endAt(1);\n     * expect(firstHalf.toArray()).to.eql([10, 20]);\n     * </pre>\n     * \n     * @example\n     * <pre>\n     * \n     * const timeSeries = ... a series indexed by date/time ...\n     * \n     * // Get all values ending at a particular date.\n     * const result = timeSeries.endAt(new Date(2016, 5, 4)); \n     * </pre>\n     */\n    endAt (indexValue: IndexT): ISeries<IndexT, ValueT> {\n        return new Series<IndexT, ValueT>(() => {\n            const lessThanOrEqualTo = this.getIndex().getLessThanOrEqualTo();\n            return {\n                index: new TakeWhileIterable(this.getContent().index, index => lessThanOrEqualTo(index, indexValue)),\n                pairs: new TakeWhileIterable(this.getContent().pairs, pair => lessThanOrEqualTo(pair[0], indexValue)),\n            };\n        });\n    }\n\n    /**\n     * Gets a new series containing all values up to the specified index value (exclusive).\n     * \n     * @param indexValue The index value at which to end the new series.\n     * \n     * @return Returns a new series containing all values up to (but not including) the specified index value. \n     * \n     * @example\n     * <pre>\n     * \n     * const series = new Series({ \n     *      index: [0, 1, 2, 3], // This is the default index.\n     *      values: [10, 20, 30, 40],\n     * });\n     * \n     * const firstHalf = series.before(2);\n     * expect(firstHalf.toArray()).to.eql([10, 20]);\n     * </pre>\n     * \n     * @example\n     * <pre>\n     * \n     * const timeSeries = ... a series indexed by date/time ...\n     * \n     * // Get all values before the specified date.\n     * const result = timeSeries.before(new Date(2016, 5, 4)); \n     * </pre>\n     */\n    before (indexValue: IndexT): ISeries<IndexT, ValueT> {\n        return new Series<IndexT, ValueT>(() => {\n            const lessThan = this.getIndex().getLessThan();\n            return {\n                index: new TakeWhileIterable(this.getContent().index, index => lessThan(index, indexValue)),\n                pairs: new TakeWhileIterable(this.getContent().pairs, pair => lessThan(pair[0], indexValue)),\n            };\n        });\n    }\n\n    /**\n     * Gets a new series containing all values after the specified index value (exclusive).\n     * \n     * @param indexValue The index value after which to start the new series.\n     * \n     * @return Returns a new series containing all values after the specified index value.\n     * \n     * @example\n     * <pre>\n     * \n     * const series = new Series({ \n     *      index: [0, 1, 2, 3], // This is the default index.\n     *      values: [10, 20, 30, 40],\n     * });\n     * \n     * const lastHalf = df.before(1);\n     * expect(lastHalf.toArray()).to.eql([30, 40]);\n     * </pre>\n     * \n     * @example\n     * <pre>\n     * \n     * const timeSerie = ... a series indexed by date/time ...\n     * \n     * // Get all values after the specified date.\n     * const result = timeSeries.after(new Date(2016, 5, 4)); \n     * </pre>\n     */    \n    after (indexValue: IndexT): ISeries<IndexT, ValueT> {\n        return new Series<IndexT, ValueT>(() => {\n            const lessThanOrEqualTo = this.getIndex().getLessThanOrEqualTo();\n            return {\n                index: new SkipWhileIterable(this.getContent().index, index => lessThanOrEqualTo(index, indexValue)),\n                pairs: new SkipWhileIterable(this.getContent().pairs, pair => lessThanOrEqualTo(pair[0], indexValue)),\n            };\n        });\n    }\n\n    /**\n     * Gets a new series containing all values between the specified index values (inclusive).\n     * \n     * @param startIndexValue The index at which to start the new series.\n     * @param endIndexValue The index at which to end the new series.\n     * \n     * @return Returns a new series containing all values between the specified index values (inclusive).\n     * \n     * @example\n     * <pre>\n     * \n     * const series = new Series({ \n     *      index: [0, 1, 2, 3, 4, 6], // This is the default index.\n     *      values: [10, 20, 30, 40, 50, 60],\n     * });\n     * \n     * const middleSection = series.between(1, 4);\n     * expect(middleSection.toArray()).to.eql([20, 30, 40, 50]);\n     * </pre>\n     * \n     * @example\n     * <pre>\n     * \n     * const timeSeries = ... a series indexed by date/time ...\n     * \n     * // Get all values between the start and end dates (inclusive).\n     * const result = timeSeries.after(new Date(2016, 5, 4), new Date(2016, 5, 22)); \n     * </pre>\n     */\n    between (startIndexValue: IndexT, endIndexValue: IndexT): ISeries<IndexT, ValueT> {\n        return this.startAt(startIndexValue).endAt(endIndexValue); \n    }\n\n    /** \n     * Format the series for display as a string.\n     * This forces lazy evaluation to complete.\n     * \n     * @return Generates and returns a string representation of the series.\n     * \n     * @example\n     * <pre>\n     * \n     * console.log(series.toString());\n     * </pre>\n     */\n    toString (): string {\n\n        const header = [\"__index__\", \"__value__\"];\n        const rows = this.toPairs();\n\n        const table = new Table();\n        for (let rowIndex = 0; rowIndex < rows.length; ++rowIndex) {\n            const row = rows[rowIndex];\n            for (let cellIndex = 0; cellIndex < row.length; ++cellIndex) {\n                const cell = row[cellIndex];\n                table.cell(header[cellIndex], cell);\n            }\n            table.newRow();\n        }\n\n        return table.toString();\n    };\n\n    //\n    // Helper function to parse a string to an int.\n    //\n    static parseInt (value: any | undefined, valueIndex: number): number | undefined {\n        if (value === undefined) {\n            return undefined;\n        }\n        else {\n            if (!isString(value)) throw new Error(\"Called Series.parseInts, expected all values in the series to be strings, instead found a '\" + typeof(value) + \"' at index \" + valueIndex);\n\n            if (value.length === 0) {\n                return undefined;\n            }\n\n            return parseInt(value);\n        }\n    }\n\n    /**\n     * Parse a series with string values and convert it to a series with int values.\n     *\n     * @return Returns a new series with values parsed from strings to ints.\n     * \n     * @example\n     * <pre>\n     * \n     * const parsed = series.parseInts();\n     * </pre>\n     */\n    parseInts (): ISeries<IndexT, number> {\n        return <ISeries<IndexT, number>> this.select(Series.parseInt);\n    };\n\n    //\n    // Helper function to parse a string to a float.\n    //\n    static parseFloat (value: any | undefined, valueIndex: number): number | undefined {\n        if (value === undefined) {\n            return undefined;\n        }\n        else {\n            if (!isString(value)) throw new Error(\"Called Series.parseFloats, expected all values in the series to be strings, instead found a '\" + typeof(value) + \"' at index \" + valueIndex);\n\n            if (value.length === 0) {\n                return undefined;\n            }\n\n            return parseFloat(value);\n        }\n    }\n\n    /**\n     * Parse a series with string values and convert it to a series with float values.\n     *\n     * @return Returns a new series with values parsed from strings to floats.\n     * \n     * @example\n     * <pre>\n     * \n     * const parsed = series.parseFloats();\n     * </pre>\n     */\n    parseFloats (): ISeries<IndexT, number> {\n        return <ISeries<IndexT, number>> this.select(Series.parseFloat);\n    };\n\n    //\n    // Helper function to parse a string to a date.\n    //\n    static parseDate (value: any | undefined, valueIndex: number, formatString?: string): Date | undefined {\n        if (value === undefined) {\n            return undefined;\n        }\n        else {\n            if (!isString(value)) throw new Error(\"Called Series.parseDates, expected all values in the series to be strings, instead found a '\" + typeof(value) + \"' at index \" + valueIndex);\n\n            if (value.length === 0) {\n                return undefined;\n            }\n\n            return moment(value, formatString).toDate();\n        }\n    }\n\n    /**\n     * Parse a series with string values and convert it to a series with date values.\n     *\n     * @param [formatString] Optional formatting string for dates.\n     * \n     * Moment is used for date parsing.\n     * https://momentjs.com\n     * \n     * @return Returns a new series with values parsed from strings to dates.\n     * \n     * @example\n     * <pre>\n     * \n     * const parsed = series.parseDates();\n     * </pre>\n     */\n    parseDates (formatString?: string): ISeries<IndexT, Date> {\n\n        if (formatString) {\n            if (!isString(formatString)) throw new Error(\"Expected optional 'formatString' parameter to Series.parseDates to be a string (if specified).\");\n        }\n\n        return <ISeries<IndexT, Date>> this.select((value: any | undefined, valueIndex: number) => Series.parseDate(value, valueIndex, formatString));\n    }\n\n    //\n    // Helper function to convert a value to a string.\n    //\n    static toString(value: any | undefined, formatString?: string): string | undefined | null {\n        if (value === undefined) {\n            return undefined;\n        }\n        else if (value === null) {\n            return null;\n        }\n        else if (formatString && isDate(value)) {\n            return moment(value).format(formatString);\n        }\n        else if (formatString && isNumber(value)) {\n            return numeral(value).format(formatString);\n        }\n        else {\n            return value.toString();\t\n        }\t\t\n    }\n\n    /**\n     * Convert a series of values of different types to a series containing string values.\n     *\n     * @param [formatString] Optional formatting string for dates.\n     * \n     * Numeral.js is used for number formatting.\n     * http://numeraljs.com/\n     * \n     * Moment is used for date formatting.\n     * https://momentjs.com/docs/#/parsing/string-format/\n     * \n     * @return Returns a new series values converted from values to strings.\n     * \n     * @example\n     * <pre>\n     * \n     * const result = series.toStrings(\"YYYY-MM-DD\");\n     * </pre>\n     * \n     * @example\n     * <pre>\n     * \n     * const result = series.toStrings(\"0.00\");\n     * </pre>\n     */\n    toStrings (formatString?: string): ISeries<IndexT, string> {\n\n        if (formatString) {\n            if (!isString(formatString)) throw new Error(\"Expected optional 'formatString' parameter to Series.toStrings to be a string (if specified).\");\n        }\n\n        return <ISeries<IndexT, string>> this.select(value => Series.toString(value, formatString));\n    }\n\n    /**\n     * Forces lazy evaluation to complete and 'bakes' the series into memory.\n     * \n     * @return Returns a series that has been 'baked', all lazy evaluation has completed.\n     * \n     * @example\n     * <pre>\n     * \n     * const baked = series.bake();\n     * </pre>\n     */\n    bake (): ISeries<IndexT, ValueT> {\n\n        if (this.getContent().isBaked) {\n            // Already baked.\n            return this;\n        }\n\n        return new Series<IndexT, ValueT>({\n            values: this.toArray(),\n            pairs: this.toPairs(),\n            baked: true,\n        });\n    };\n\n    /** \n     * Converts (inflates) a series to a {@link DataFrame}.\n     *\n     * @param [selector] Optional user-defined selector function that transforms each value to produce the dataframe.\n     *\n     * @returns Returns a dataframe that was created from the original series.\n     * \n     * @example\n     * <pre>\n     * \n     * const dataframe = series.inflate(); // Inflate a series of objects to a dataframe.\n     * </pre>\n     * \n     * @example\n     * <pre>\n     * \n     * const dataframe = series.inflate(value => { AColumn:  value }); // Produces a dataframe with 1 column from a series of values.\n     * </pre>\n     * \n     * @example\n     * <pre>\n     * \n     * const dataframe = series.inflate(value => { AColumn:  value.NestedValue }); // Extract a nested value and produce a dataframe from it.\n     * </pre>\n     */\n    inflate<ToT = ValueT> (selector?: SelectorWithIndexFn<ValueT, ToT>): IDataFrame<IndexT, ToT> {\n\n        if (selector) {\n            if (!isFunction(selector)) throw new Error(\"Expected 'selector' parameter to Series.inflate to be a selector function.\");\n\n            return new DataFrame<IndexT, ToT>(() => {\n                const content = this.getContent();\n                return {\n                    values: new SelectIterable(content.values, selector),\n                    index: content.index,\n                    pairs: new SelectIterable(content.pairs, (pair: [IndexT, ValueT], index: number): [IndexT, ToT] => [pair[0], selector(pair[1], index)]),\n                };\n            });\n        }\n        else {\n            return new DataFrame<IndexT, ToT>(() => {\n                const content = this.getContent();\n                return {\n                    values: <Iterable<ToT>> <any> content.values,\n                    index: content.index,\n                    pairs: <Iterable<[IndexT, ToT]>> <any> content.pairs,\n                };\n            });\n        }\n    }\n\n    /**\n     * Static version of the sum function for use with summarize and pivot functions.\n     * \n     * @param series Input series to be summed.\n     * \n     * @returns Returns the sum of the number values in the series.\n     * \n     * @example\n     * <pre>\n     * \n     * const summary = dataFrame.summarize({\n     *      ColumnToBeSummed: Series.sum,\n     * });\n     * </pre>\n     */\n    static sum<IndexT = any> (series: ISeries<IndexT, number>): number {\n        return series.sum();\n    }\n\n    /**\n     * Sum the values in a series and returns the result.\n     * \n     * @returns Returns the sum of the number values in the series.\n     * \n     * @example\n     * <pre>\n     * \n     * const totalSales = salesFigures.sum();\n     * </pre>\n     */\n    sum (): number {\n\n        if (this.none()) {\n            return 0;\n        }\n\n        const numberSeries = <ISeries<IndexT, number>> <any> this; // Have to assume we are working with a number series here.\n        return numberSeries.aggregate((prev: number, value: number) => prev + value);\n    }\n\n    /**\n     * Static version of the average function for use with summarize and pivot functions.\n     * \n     * @param series Input series to be averaged.\n     * \n     * @returns Returns the average of the number values in the series.\n     * \n     * @example\n     * <pre>\n     * \n     * const summary = dataFrame.summarize({\n     *      ColumnToBeAveraged: Series.average,\n     * });\n     * </pre>\n     */\n    static average<IndexT = any> (series: ISeries<IndexT, number>): number {\n        return series.average();\n    }\n    \n    /**\n     * Average the values in a series and returns the result\n     * \n     * @returns Returns the average of the number values in the series.\n     * \n     * @example\n     * <pre>\n     * \n     * const averageSales = salesFigures.average();\n     * </pre>\n     */\n    average (): number {\n\n        const count = this.count();\n        if (count > 0) {\n            return this.sum() / count;\n        }\n        else {\n            return 0;\n        }\n    }\n\n    /**\n     * Static version of the median function for use with summarize and pivot functions.\n     * \n     * @param series Input series to find the median of.\n     * \n     * @returns Returns the median of the number values in the series.\n     * \n     * @example\n     * <pre>\n     * \n     * const summary = dataFrame.summarize({\n     *      InputColumn: Series.median,\n     * });\n     * </pre>\n     */\n    static median<IndexT = any> (series: ISeries<IndexT, number>): number {\n        return series.median();\n    }\n\n    /**\n     * Get the median value in the series. \n     * Note that this sorts the series, which can be expensive.\n     * \n     * @returns Returns the median of the values in the series.\n     * \n     * @example\n     * <pre>\n     * \n     * const medianSales = salesFigures.median();\n     * </pre>\n     */\n    median (): number {\n\n        //\n        // From here: http://stackoverflow.com/questions/5275115/add-a-median-method-to-a-list\n        //\n        const numberSeries = <ISeries<IndexT, number>> <any> this; // Have to assume we are working with a number series here.\n\n        const count = numberSeries.count();\n        if (count === 0) {\n            return 0;\n        }\n\n        const ordered = numberSeries.orderBy(value => value).toArray();\n        if ((count % 2) == 0) {\n            // Even.\n            const a = ordered[count / 2 - 1];\n            const b = ordered[count / 2];\n            return (a + b) / 2;\t\n        }\n\n        // Odd\n        return ordered[Math.floor(count / 2)];\n    }\n\n    /**\n     * Static version of the standard deviation function for use with summarize and pivot functions.\n     * \n     * @param series Input series to find the standard deviation of.\n     * \n     * @returns Returns the standard deviation of the values in the series.\n     * \n     * @example\n     * <pre>\n     * \n     * const summary = dataFrame.summarize({\n     *      InputColumn: Series.std,\n     * });\n     * </pre>\n     */\n    static std<IndexT = any> (series: ISeries<IndexT, number>): number {\n        return series.std();\n    }\n    \n    /**\n     * Get the standard deviation of number values in the series. \n     * \n     * @returns Returns the standard deviation of the values in the series.\n     * \n     * @example\n     * <pre>\n     * \n     * const salesStdDev = salesFigures.std();\n     * </pre>\n     */\n    std (): number {\n\n        // Have to assume we are working with a number series here.\n        // Bake so we don't evaluate multiple times.\n        // TODO: Caching can help here.\n        const numberSeries = (<ISeries<IndexT, number>> <any> this.bake()); \n        const valueCount = numberSeries.count();\n        if (valueCount === 0) {\n            return 0;\n        }\n\n        // https://en.wikipedia.org/wiki/Standard_deviation\n        const mean = numberSeries.average();\n        const sumOfSquaredDiffs = numberSeries\n            .select(value  => { \n                const diffFromMean = value - mean;\n                return diffFromMean * diffFromMean;\n            })\n            .sum();\n        return Math.sqrt(sumOfSquaredDiffs / valueCount);\n    }\n\n    /**\n     * Static version of the min function for use with summarize and pivot functions.\n     * \n     * @param series Input series to find the minimum of.\n     * \n     * @returns Returns the minimum of number values in the series.\n     * \n     * @example\n     * <pre>\n     * \n     * const summary = dataFrame.summarize({\n     *      Column: Series.min,\n     * });\n     * </pre>\n     */\n    static min<IndexT = any> (series: ISeries<IndexT, number>): number {\n        return series.min();\n    }\n\n    /**\n     * Get the min value in the series.\n     * \n     * @returns Returns the minimum of the number values in the series.\n     * \n     * @example\n     * <pre>\n     * \n     * const minSales = salesFigures.min();\n     * </pre>\n     */\n    min (): number {\n\n        const numberSeries = <ISeries<IndexT, number>> <any> this; // Have to assume we are working with a number series here.\n        return numberSeries.aggregate((prev, value) => Math.min(prev, value));\n    }\n\n    /**\n     * Static version of the max function for use with summarize and pivot functions.\n     * \n     * @param series Input series to find the maximum of.\n     * \n     * @returns Returns the maximum of number values in the series.\n     * \n     * @example\n     * <pre>\n     * \n     * const summary = dataFrame.summarize({\n     *      Column: Series.max,\n     * });\n     * </pre>\n     */\n    static max<IndexT = any> (series: ISeries<IndexT, number>): number {\n        return series.max();\n    }\n    \n    /**\n     * Get the max value in the series.\n     * \n     * @returns Returns the maximum of the number values in the series.\n     * \n     * @example\n     * <pre>\n     * \n     * const maxSales = salesFigures.max();\n     * </pre>\n     */\n    max (): number {\n\n        const numberSeries = <ISeries<IndexT, number>> <any> this; // Have to assume we are working with a number series here.\n        return numberSeries.aggregate((prev, value) => Math.max(prev, value));\n    }\n    \n    /**\n     * Invert the sign of every number value in the series.\n     * This assumes that the input series contains numbers.\n     * \n     * @returns Returns a new series with all number values inverted.\n     * \n     * @example\n     * <pre>\n     * \n     * const inverted = series.invert();\n     * </pre>\n     */\n    invert (): ISeries<IndexT, number> {\n        const inputSeries = this as any as ISeries<IndexT, number>;\n        return inputSeries.select(value => -value);\n    }\n\n    /**\n     * Counts the number of sequential values where the predicate evaluates to truthy.\n     * Outputs 0 for values when the predicate evaluates to falsy.\n     * \n     * @param predicate User-defined function. Should evaluate to truthy to activate the counter or falsy to deactivate it.\n     * \n     * @returns Returns a new series that counts up the number of sequential values where the predicate evaluates to truthy. 0 values appear when the prediate evaluates to falsy.\n     * \n     * @example\n     * <pre>\n     * \n     * const series = new Series([ 1, 10, 3, 15, 8, 5 ]);\n     * const counted = series.counter(value => value >= 3);\n     * console.log(counted.toString());\n     * </pre>\n     */\n    counter (predicate: PredicateFn<ValueT>): ISeries<IndexT, number> {\n        return this.groupSequentialBy(predicate)\n            .selectMany((group, i) => {\n                if (predicate(group.first())) {\n                    // This group matches the predicate.\n                    return range(1, group.count())\n                        .withIndex(group.getIndex())\n                        .toPairs(); //TODO: selectMany wipes the index. It needs to respect it!\n                }\n                else {\n                    // This group doesn't match the predicate.\n                    return replicate(0, group.count())\n                        .withIndex(group.getIndex())\n                        .toPairs(); //TODO: selectMany wipes the index. It needs to respect it!\n                }\n            }) \n            .withIndex(pair => pair[0])\n            .select(pair => pair[1]) as any as ISeries<IndexT, number>;\n    }\n    \n    /** \n     * Gets a new series in reverse order.\n     * \n     * @return Returns a new series that is the reverse of the original.\n     * \n     * @example\n     * <pre>\n     * \n     * const reversed = series.reverse();\n     * </pre>\n     */\n    reverse (): ISeries<IndexT, ValueT> {\n\n        return new Series<IndexT, ValueT>(() => ({\n            values: new ReverseIterable(this.getContent().values),\n            index: new ReverseIterable(this.getContent().index),\n            pairs: new ReverseIterable(this.getContent().pairs)\n        }));\n    }\n\n    /**\n     * Returns only the set of values in the series that are distinct.\n     * Provide a user-defined selector to specify criteria for determining the distinctness.\n     * This can be used to remove duplicate values from the series.\n     *\n     * @param [selector] Optional user-defined selector function that specifies the criteria used to make comparisons for duplicate values.\n     * \n     * @return Returns a series containing only unique values in the series. \n     * \n     * @example\n     * <pre>\n     * \n     * const uniqueValues = series.distinct(); // Get only non-duplicated value in the series.\n     * </pre>\n     * \n     * @example\n     * <pre>\n     * \n     * const bucketedValues = series.distinct(value => Math.floor(value / 10)); // Lump values into buckets of 10.\n     * </pre>\n     */\n    distinct<ToT> (selector?: SelectorFn<ValueT, ToT>): ISeries<IndexT, ValueT> {\n\n        return new Series<IndexT, ValueT>(() => ({\n            values: new DistinctIterable<ValueT, ToT>(this.getContent().values, selector),\n            pairs: new DistinctIterable<[IndexT, ValueT],ToT>(this.getContent().pairs, (pair: [IndexT, ValueT]): ToT => selector && selector(pair[1]) || <ToT> <any> pair[1])\n        }));\n    }\n\n    /**\n     * Collects values in the series into a new series of groups according to a user-defined selector function.\n     *\n     * @param selector User-defined selector function that specifies the criteriay to group by.\n     *\n     * @return Returns a new series of groups. Each group is a series with values that have been grouped by the 'selector' function.\n     * \n     * @example\n     * <pre>\n     * \n     * const sales = ... product sales ...\n     * const salesByProduct = sales.groupBy(sale => sale.ProductId);\n     * for (const productSalesGroup of salesByProduct) {\n     *      // ... do something with each product group ...\n     *      const productId = productSalesGroup.first().ProductId;\n     *      const totalSalesForProduct = productSalesGroup.deflate(sale => sale.Amount).sum();\n     *      console.log(totalSalesForProduct);\n     * }\n     * </pre>\n     */\n    groupBy<GroupT> (selector: SelectorWithIndexFn<ValueT, GroupT>): ISeries<number, ISeries<IndexT, ValueT>> {\n\n        if (!isFunction(selector)) throw new Error(\"Expected 'selector' parameter to 'Series.groupBy' to be a selector function that determines the value to group the series by.\");\n\n        return new Series<number, ISeries<IndexT, ValueT>>(() => {\n            const groups: any[] = []; // Each group, in order of discovery.\n            const groupMap: any = {}; // Group map, records groups by key.\n            \n            let valueIndex = 0;\n    \n            for (const pair of this.getContent().pairs) {\n                const groupKey = selector(pair[1], valueIndex);\n                ++valueIndex;\n                const existingGroup = groupMap[groupKey];\n                if (existingGroup) {\n                    existingGroup.push(pair);\n                }\n                else {\n                    const newGroup: any[] = [];\n                    newGroup.push(pair);\n                    groups.push(newGroup);\n                    groupMap[groupKey] = newGroup;\n                }\n            }\n\n            return {\n                values: groups.map(group => new Series<IndexT, ValueT>({ pairs: group }))\n            };            \n        });\n    }\n    \n    /**\n     * Collects values in the series into a new series of groups based on if the values are the same or according to a user-defined selector function.\n     *\n     * @param [selector] Optional selector that specifies the criteria for grouping.\n     *\n     * @return Returns a new series of groups. Each group is a series with values that are the same or have been grouped by the 'selector' function.\n     * \n     * @example\n     * <pre>\n     * \n     * // Some ultra simple stock trading strategy backtesting...\n     * const dailyStockPrice = ... daily stock price for a company ...\n     * const priceGroups  = dailyStockPrice.groupBy(day => day.close > day.movingAverage);\n     * for (const priceGroup of priceGroups) {\n     *      // ... do something with each stock price group ...\n     * \n     *      const firstDay = priceGroup.first();\n     *      if (firstDay.close > movingAverage) {\n     *          // This group of days has the stock price above its moving average.\n     *          // ... maybe enter a long trade here ...\n     *      }\n     *      else {\n     *          // This group of days has the stock price below its moving average.\n     *          // ... maybe enter a short trade here ...\n     *      }\n     * }\n     * </pre>\n     */    \n    groupSequentialBy<GroupT> (selector?: SelectorFn<ValueT, GroupT>): ISeries<number, ISeries<IndexT, ValueT>> {\n\n        if (selector) {\n            if (!isFunction(selector)) throw new Error(\"Expected 'selector' parameter to 'Series.groupSequentialBy' to be a selector function that determines the value to group the series by.\")\n        }\n        else {\n            selector = value => <GroupT> <any> value;\n        }\n        \n        return this.variableWindow((a: ValueT, b: ValueT): boolean => selector!(a) === selector!(b));\n    }\n\n    /**\n     * Concatenate multiple series into a single series.\n     *\n     * @param series - Array of series to concatenate.\n     * \n     * @returns Returns a single series concatenated from multiple input series. \n     */\n    static concat<IndexT = any, ValueT = any> (series: ISeries<IndexT, ValueT>[]): ISeries<IndexT, ValueT> {\n        if (!isArray(series)) throw new Error(\"Expected 'series' parameter to 'Series.concat' to be an array of series.\");\n\n        return new Series(() => {\n            const upcast = <Series<IndexT, ValueT>[]> series; // Upcast so that we can access private index, values and pairs.\n            const contents = upcast.map(series => series.getContent());\n            return {\n                values: new ConcatIterable(contents.map(content => content.values)),\n                pairs: new ConcatIterable(contents.map(content => content.pairs)),\n            };\n        });\n    }\n    \n    /**\n     * Concatenate multiple other series onto this series.\n     * \n     * @param series Multiple arguments. Each can be either a series or an array of series.\n     * \n     * @return Returns a single series concatenated from multiple input series. \n     * \n     * @example\n     * <pre>\n     * \n     * const concatenated = a.concat(b);\n     * </pre>\n     * \n     * @example\n     * <pre>\n     * \n     * const concatenated = a.concat(b, c);\n     * </pre>\n     * \n     * @example\n     * <pre>\n     * \n     * const concatenated = a.concat([b, c]);\n     * </pre>\n     * \n     * @example\n     * <pre>\n     * \n     * const concatenated = a.concat(b, [c, d]);\n     * </pre>\n     * \n     * @example\n     * <pre>\n     * \n     * const otherSeries = [... array of series...];\n     * const concatenated = a.concat(otherSeries);\n     * </pre>\n     */    \n    concat (...series: (ISeries<IndexT, ValueT>[]|ISeries<IndexT, ValueT>)[]): ISeries<IndexT, ValueT> {\n        const concatInput: ISeries<IndexT, ValueT>[] = [this];\n\n        for (const input of series) {\n            if (isArray(input)) {\n                for (const subInput of input) {\n                    concatInput.push(subInput);\n                }\n            }\n            else {\n                concatInput.push(input);\n            }\n        }\n\n        return Series.concat<IndexT, ValueT>(concatInput);\n    }\n   \n    /**\n    * Zip together multiple series to create a new series.\n    * Preserves the index of the first series.\n    *\n    * @param series - An iterable of series to be zipped.\n    * @param zipper - Selector function that produces a new series based on the input series.\n    * \n    * @returns Returns a single series zipped from multiple input series. \n    */\n    static zip<IndexT = any, ValueT = any, ResultT = any> (series: Iterable<ISeries<IndexT, ValueT>>, zipper: ZipNFn<ValueT, ResultT>): ISeries<IndexT, ResultT> {\n\n        const input = Array.from(series);\n\n        if (input.length === 0) {\n            return new Series<IndexT, ResultT>();\n        }\n\n        const firstSeries = input[0];\n        if (firstSeries.none()) {\n            return new Series<IndexT, ResultT>();\n        }\n\n        return new Series<IndexT, ResultT>(() => {\n            const firstSeriesUpCast = <Series<IndexT, ValueT>> firstSeries;\n            const upcast = <Series<IndexT, ValueT>[]> input; // Upcast so that we can access private index, values and pairs.\n            \n            return {\n                index: <Iterable<IndexT>> firstSeriesUpCast.getContent().index,\n                values: new ZipIterable<ValueT, ResultT>(upcast.map(s => s.getContent().values), zipper),\n            };\n        });\n    }\n    \n    /**\n    * Merge together multiple series to create a new series.\n    * Preserves the index of the first series.\n    * \n    * @param s2, s3, s4, s4 Multiple series to zip.\n    * @param zipper User-defined zipper function that merges rows. It produces values for the new series based-on values from the input series.\n    * \n    * @return Returns a single series merged from multiple input series. \n    * \n    * @example\n    * <pre>\n    * \n    * const a = new Series([1, 2, 3]);\n    * const b = new Series([10, 20, 30]);\n    * const zipped = a.zip(b (valueA, valueB) => valueA + valueB);\n    * </pre>\n    */    \n    zip<Index2T, Value2T, ResultT>  (s2: ISeries<Index2T, Value2T>, zipper: Zip2Fn<ValueT, Value2T, ResultT> ): ISeries<IndexT, ResultT>;\n    zip<Index2T, Value2T, Index3T, Value3T, ResultT>  (s2: ISeries<Index2T, Value2T>, s3: ISeries<Index3T, Value3T>, zipper: Zip3Fn<ValueT, Value2T, Value3T, ResultT> ): ISeries<IndexT, ResultT>;\n    zip<Index2T, Value2T, Index3T, Value3T, Index4T, Value4T, ResultT>  (s2: ISeries<Index2T, Value2T>, s3: ISeries<Index3T, Value3T>, s4: ISeries<Index4T, Value4T>, zipper: Zip3Fn<ValueT, Value2T, Value3T, ResultT> ): ISeries<IndexT, ResultT>;\n    zip<ResultT>  (...args: any[]): ISeries<IndexT, ResultT> {\n\n        const selector: Function = args[args.length-1];\n        const input: ISeries<IndexT, any>[] = [this].concat(args.slice(0, args.length-1));\n        return Series.zip<IndexT, any, ResultT>(input, values => selector(...values));\n    }    \n\n    /**\n     * Sorts the series in ascending order by a value defined by the user-defined selector function. \n     * \n     * @param selector User-defined selector function that selects the value to sort by.\n     * \n     * @return Returns a new series that has been ordered accorrding to the value chosen by the selector function. \n     * \n     * @example\n     * <pre>\n     * \n     * const orderedSeries = series.orderBy(value => value); \n     * </pre>\n     * \n     * @example\n     * <pre>\n     * \n     * const orderedSeries = series.orderBy(value => value.NestedValue); \n     * </pre>\n     */\n    orderBy<SortT> (selector: SelectorWithIndexFn<ValueT, SortT>): IOrderedSeries<IndexT, ValueT, SortT> {\n        const content = this.getContent();\n        return new OrderedSeries<IndexT, ValueT, SortT>({\n            values: content.values, \n            pairs: content.pairs, \n            selector: selector, \n            direction: Direction.Ascending, \n            parent: null,\n        });\n    }\n\n    /**\n     * Sorts the series in descending order by a value defined by the user-defined selector function. \n     * \n     * @param selector User-defined selector function that selects the value to sort by.\n     * \n     * @return Returns a new series that has been ordered accorrding to the value chosen by the selector function. \n     * \n     * @example\n     * <pre>\n     * \n     * const orderedSeries = series.orderByDescending(value => value); \n     * </pre>\n     * \n     * @example\n     * <pre>\n     * \n     * const orderedSeries = series.orderByDescending(value => value.NestedValue); \n     * </pre>\n     */\n    orderByDescending<SortT> (selector: SelectorWithIndexFn<ValueT, SortT>): IOrderedSeries<IndexT, ValueT, SortT> {\n        const content = this.getContent();\n        return new OrderedSeries<IndexT, ValueT, SortT>({\n            values: content.values, \n            pairs: content.pairs, \n            selector: selector, \n            direction: Direction.Descending, \n            parent: null,\n        });\n    }\n        \n    /**\n     * Creates a new series by merging two input dataframes.\n     * The resulting series contains the union of value from the two input series.\n     * These are the unique combination of values in both series.\n     * This is basically a concatenation and then elimination of duplicates.\n     *\n     * @param other The other series to merge.\n     * @param [selector] Optional user-defined selector function that selects the value to compare to determine distinctness.\n     * \n     * @return Returns the union of the two series.\n     * \n     * @example\n     * <pre>\n     *\n     * const seriesA = ...\n     * const seriesB = ...\n     * const merged = seriesA.union(seriesB);\n     * </pre>\n     * \n     * @example\n     * <pre>\n     *\n     * // Merge two sets of customer records that may contain the same\n     * // customer record in each set. This is basically a concatenation\n     * // of the series and then an elimination of any duplicate records\n     * // that result.\n     * const customerRecordsA = ...\n     * const customerRecordsB = ...\n     * const mergedCustomerRecords = customerRecordsA.union(\n     *      customerRecordsB, \n     *      customerRecord => customerRecord.CustomerId\n     * );\n     * </pre>\n     * \n     * \n     * @example\n     * <pre>\n     *\n     * // Note that you can achieve the exact same result as the previous\n     * // example by doing a {@link Series.concat) and {@link Series.distinct}\n     * // of the input series and then an elimination of any duplicate records\n     * // that result.\n     * const customerRecordsA = ...\n     * const customerRecordsB = ...\n     * const mergedCustomerRecords = customerRecordsA\n     *      .concat(customerRecordsB)\n     *      .distinct(customerRecord => customerRecord.CustomerId);\n     * </pre>\n     * \n     */\n    union<KeyT = ValueT> (\n        other: ISeries<IndexT, ValueT>, \n        selector?: SelectorFn<ValueT, KeyT>): \n            ISeries<IndexT, ValueT> {\n\n        if (selector) {\n            if (!isFunction(selector)) throw new Error(\"Expected optional 'selector' parameter to 'Series.union' to be a selector function.\");\n        }\n\n        return this.concat(other).distinct(selector);\n    };\n\n    /**\n     * Creates a new series by merging two input series.\n     * The resulting series contains the intersection of values from the two input series.\n     * These are only the values that appear in both series.\n     *\n     * @param inner The inner series to merge (the series you call the function on is the 'outer' series).\n     * @param [outerSelector] Optional user-defined selector function that selects the key from the outer series that is used to match the two series.\n     * @param [innerSelector] Optional user-defined selector function that selects the key from the inner series that is used to match the two series.\n     * \n     * @return Returns a new series that contains the intersection of values from the two input series.\n     * \n     * @example\n     * <pre>\n     * \n     * const seriesA = ...\n     * const seriesB = ...\n     * const mergedDf = seriesA.intersection(seriesB);\n     * </pre>\n     * \n     * @example\n     * <pre>\n     *\n     * // Merge two sets of customer records to find only the\n     * // customers that appears in both.\n     * const customerRecordsA = ...\n     * const customerRecordsB = ...\n     * const intersectionOfCustomerRecords = customerRecordsA.intersection(\n     *      customerRecordsB, \n     *      customerRecord => customerRecord.CustomerId\n     * );\n     * </pre>     \n     */    \n    intersection<InnerIndexT = IndexT, InnerValueT = ValueT, KeyT = ValueT> (\n        inner: ISeries<InnerIndexT, InnerValueT>, \n        outerSelector?: SelectorFn<ValueT, KeyT>,\n        innerSelector?: SelectorFn<InnerValueT, KeyT>): \n            ISeries<IndexT, ValueT> {\n\n        if (outerSelector) {\n            if (!isFunction(outerSelector)) throw new Error(\"Expected optional 'outerSelector' parameter to 'Series.intersection' to be a function.\");\n        }\n        else {\n            outerSelector = value => <KeyT> <any> value;\n        }\n        \n        if (innerSelector) {\n            if (!isFunction(innerSelector)) throw new Error(\"Expected optional 'innerSelector' parameter to 'Series.intersection' to be a function.\");\n        }\n        else {\n            innerSelector = value => <KeyT> <any> value;\n        }\n\n        const outer = this;\n        return outer.where(outerValue => {\n                const outerKey = outerSelector!(outerValue);\n                return inner\n                    .where(innerValue => outerKey === innerSelector!(innerValue))\n                    .any();\n            });\n    };\n\n    /**\n     * Creates a new series by merging two input series.\n     * The resulting series contains only the values from the 1st series that don't appear in the 2nd series.\n     * This is essentially subtracting the values from the 2nd series from the 1st and creating a new series with the remaining values.\n     *\n     * @param inner The inner series to merge (the series you call the function on is the 'outer' series).\n     * @param [outerSelector] Optional user-defined selector function that selects the key from the outer series that is used to match the two series.\n     * @param [innerSelector] Optional user-defined selector function that selects the key from the inner series that is used to match the two series.\n     * \n     * @return Returns a new series that contains only the values from the 1st series that don't appear in the 2nd series.\n     * \n     * @example\n     * <pre>\n     * \n     * const seriesA = ...\n     * const seriesB = ...\n     * const remainingDf = seriesA.except(seriesB);\n     * </pre>\n     * \n     * @example\n     * <pre>\n     *\n     * // Find the list of customers haven't bought anything recently.\n     * const allCustomers = ... list of all customers ...\n     * const recentCustomers = ... list of customers who have purchased recently ...\n     * const remainingCustomers = allCustomers.except(\n     *      recentCustomers, \n     *      customerRecord => customerRecord.CustomerId\n     * );\n     * </pre>\n     */    \n    except<InnerIndexT = IndexT, InnerValueT = ValueT, KeyT = ValueT> (\n        inner: ISeries<InnerIndexT, InnerValueT>, \n        outerSelector?: SelectorFn<ValueT, KeyT>,\n        innerSelector?: SelectorFn<InnerValueT, KeyT>): \n            ISeries<IndexT, ValueT> {\n\n        if (outerSelector) {\n            if (!isFunction(outerSelector)) throw new Error(\"Expected optional 'outerSelector' parameter to 'Series.except' to be a function.\");\n        }\n        else {\n            outerSelector = value => <KeyT> <any> value;\n        }\n\n        if (innerSelector) {\n            if (!isFunction(innerSelector)) throw new Error(\"Expected optional 'innerSelector' parameter to 'Series.except' to be a function.\");\n        }\n        else {\n            innerSelector = value => <KeyT> <any> value;\n        }\n\n        const outer = this;\n        return outer.where(outerValue => {\n                const outerKey = outerSelector!(outerValue);\n                return inner\n                    .where(innerValue => outerKey === innerSelector!(innerValue))\n                    .none();\n            });\n    };\n\n   /**\n     * Creates a new series by merging two input series.\n     * The resulting dataframe contains only those value that have matching keys in both input series.\n     *\n     * @param inner The 'inner' series to join (the series you are callling the function on is the 'outer' series).\n     * @param outerKeySelector User-defined selector function that chooses the join key from the outer series.\n     * @param innerKeySelector User-defined selector function that chooses the join key from the inner series.\n     * @param resultSelector User-defined function that merges outer and inner values.\n     * \n     * @return Returns the new merged series.\n     * \n     * @example\n     * <pre>\n     * \n     * // Join together two sets of customers to find those\n     * // that have bought both product A and product B.\n     * const customerWhoBoughtProductA = ...\n     * const customerWhoBoughtProductB = ...\n     * const customersWhoBoughtBothProductsDf = customerWhoBoughtProductA.join(\n     *          customerWhoBoughtProductB,\n     *          customerA => customerA.CustomerId, // Join key.\n     *          customerB => customerB.CustomerId, // Join key.\n     *          (customerA, customerB) => {\n     *              return {\n     *                  // ... merge the results ...\n     *              };\n     *          }\n     *      );\n     * </pre>\n     */\n    join<KeyT, InnerIndexT, InnerValueT, ResultValueT> (\n        inner: ISeries<InnerIndexT, InnerValueT>, \n        outerKeySelector: SelectorFn<ValueT, KeyT>, \n        innerKeySelector: SelectorFn<InnerValueT, KeyT>, \n        resultSelector: JoinFn<ValueT, InnerValueT, ResultValueT>):\n            ISeries<number, ResultValueT> {\n\n        if (!isFunction(outerKeySelector)) throw new Error(\"Expected 'outerKeySelector' parameter of 'Series.join' to be a selector function.\");\n        if (!isFunction(innerKeySelector)) throw new Error(\"Expected 'innerKeySelector' parameter of 'Series.join' to be a selector function.\");\n        if (!isFunction(resultSelector)) throw new Error(\"Expected 'resultSelector' parameter of 'Series.join' to be a selector function.\");\n\n        const outer = this;\n\n        return new Series<number, ResultValueT>(() => {\n            const innerMap = inner\n                .groupBy(innerKeySelector)\n                .toObject(\n                    group => innerKeySelector(group.first()), \n                    group => group\n                );\n\n            const outerContent = outer.getContent();\n\n            const output: ResultValueT[] = [];\n            \n            for (const outerValue of outer) { //TODO: There should be an enumerator that does this.\n                const outerKey = outerKeySelector(outerValue);\n                const innerGroup = innerMap[outerKey];\n                if (innerGroup) {\n                    for (const innerValue of innerGroup) {\n                        output.push(resultSelector(outerValue, innerValue));\n                    }    \n                }\n            }\n\n            return {\n                values: output\n            };\n        });\n    }\n\n    /**\n     * Creates a new series by merging two input series.\n     * The resulting series contains only those values that are only present in or or the other of the series, not both.\n     *\n     * @param inner The 'inner' series to join (the series you are callling the function on is the 'outer' series).\n     * @param outerKeySelector User-defined selector function that chooses the join key from the outer series.\n     * @param innerKeySelector User-defined selector function that chooses the join key from the inner series.\n     * @param resultSelector User-defined function that merges outer and inner values.\n     * \n     * Implementation from here:\n     * \n     * \thttp://blogs.geniuscode.net/RyanDHatch/?p=116\n     * \n     * @return Returns the new merged series.\n     * \n     * @example\n     * <pre>\n     * \n     * // Join together two sets of customers to find those\n     * // that have bought either product A or product B, not not both.\n     * const customerWhoBoughtProductA = ...\n     * const customerWhoBoughtProductB = ...\n     * const customersWhoBoughtEitherProductButNotBothDf = customerWhoBoughtProductA.joinOuter(\n     *          customerWhoBoughtProductB,\n     *          customerA => customerA.CustomerId, // Join key.\n     *          customerB => customerB.CustomerId, // Join key.\n     *          (customerA, customerB) => {\n     *              return {\n     *                  // ... merge the results ...\n     *              };\n     *          }\n     *      );\n     * </pre>\n     */    \n    joinOuter<KeyT, InnerIndexT, InnerValueT, ResultValueT> (\n        inner: ISeries<InnerIndexT, InnerValueT>, \n        outerKeySelector: SelectorFn<ValueT, KeyT>, \n        innerKeySelector: SelectorFn<InnerValueT, KeyT>, \n        resultSelector: JoinFn<ValueT | null, InnerValueT | null, ResultValueT>):\n            ISeries<number, ResultValueT> {\n\n        if (!isFunction(outerKeySelector)) throw new Error(\"Expected 'outerKeySelector' parameter of 'Series.joinOuter' to be a selector function.\");\n        if (!isFunction(innerKeySelector)) throw new Error(\"Expected 'innerKeySelector' parameter of 'Series.joinOuter' to be a selector function.\");\n        if (!isFunction(resultSelector)) throw new Error(\"Expected 'resultSelector' parameter of 'Series.joinOuter' to be a selector function.\");\n\n        // Get the results in the outer that are not in the inner.\n        const outer = this;\n        const outerResult = outer.except<InnerIndexT, InnerValueT, KeyT>(inner, outerKeySelector, innerKeySelector)\n            .select(outer => resultSelector(outer, null))\n            .resetIndex();\n\n        // Get the results in the inner that are not in the outer.\n        const innerResult = inner.except<IndexT, ValueT, KeyT>(outer, innerKeySelector, outerKeySelector)\n            .select(inner => resultSelector(null, inner))\n            .resetIndex();\n\n        // Get the intersection of results between inner and outer.\n        const intersectionResults = outer.join<KeyT, InnerIndexT, InnerValueT, ResultValueT>(inner, outerKeySelector, innerKeySelector, resultSelector);\n\n        return outerResult\n            .concat(intersectionResults)\n            .concat(innerResult)\n            .resetIndex();\n    };\n\n    /**\n     * Creates a new series by merging two input series.\n     * The resulting series contains only those values that are present either in both series or only in the outer (left) series.\n     * \n     * @param inner The 'inner' series to join (the series you are callling the function on is the 'outer' series).\n     * @param outerKeySelector User-defined selector function that chooses the join key from the outer series.\n     * @param innerKeySelector User-defined selector function that chooses the join key from the inner series.\n     * @param resultSelector User-defined function that merges outer and inner values.\n     * \n     * Implementation from here:\n     * \n     * \thttp://blogs.geniuscode.net/RyanDHatch/?p=116\n     * \n     * @return Returns the new merged series.\n     * \n     * @example\n     * <pre>\n     * \n     * // Join together two sets of customers to find those\n     * // that have bought either just product A or both product A and product B.\n     * const customerWhoBoughtProductA = ...\n     * const customerWhoBoughtProductB = ...\n     * const boughtJustAorAandB = customerWhoBoughtProductA.joinOuterLeft(\n     *          customerWhoBoughtProductB,\n     *          customerA => customerA.CustomerId, // Join key.\n     *          customerB => customerB.CustomerId, // Join key.\n     *          (customerA, customerB) => {\n     *              return {\n     *                  // ... merge the results ...\n     *              };\n     *          }\n     *      );\n     * </pre>\n     */\n    joinOuterLeft<KeyT, InnerIndexT, InnerValueT, ResultValueT> (\n        inner: ISeries<InnerIndexT, InnerValueT>, \n        outerKeySelector: SelectorFn<ValueT, KeyT>, \n        innerKeySelector: SelectorFn<InnerValueT, KeyT>, \n        resultSelector: JoinFn<ValueT | null, InnerValueT | null, ResultValueT>):\n            ISeries<number, ResultValueT> {\n\n        if (!isFunction(outerKeySelector)) throw new Error(\"Expected 'outerKeySelector' parameter of 'Series.joinOuterLeft' to be a selector function.\");\n        if (!isFunction(innerKeySelector)) throw new Error(\"Expected 'innerKeySelector' parameter of 'Series.joinOuterLeft' to be a selector function.\");\n        if (!isFunction(resultSelector)) throw new Error(\"Expected 'resultSelector' parameter of 'Series.joinOuterLeft' to be a selector function.\");\n\n        // Get the results in the outer that are not in the inner.\n        const outer = this;\n        const outerResult = outer.except<InnerIndexT, InnerValueT, KeyT>(inner, outerKeySelector, innerKeySelector)\n            .select(outer => resultSelector(outer, null))\n            .resetIndex();\n\n        // Get the intersection of results between inner and outer.\n        const intersectionResults = outer.join<KeyT, InnerIndexT, InnerValueT, ResultValueT>(inner, outerKeySelector, innerKeySelector, resultSelector);\n\n        return outerResult\n            .concat(intersectionResults)\n            .resetIndex();\n    };\n\n    /**\n     * Creates a new series by merging two input series.\n     * The resulting series contains only those values that are present either in both series or only in the inner (right) series.\n     *\n     * @param inner The 'inner' series to join (the series you are callling the function on is the 'outer' series).\n     * @param outerKeySelector User-defined selector function that chooses the join key from the outer series.\n     * @param innerKeySelector User-defined selector function that chooses the join key from the inner series.\n     * @param resultSelector User-defined function that merges outer and inner values.\n     * \n     * Implementation from here:\n     * \n     * \thttp://blogs.geniuscode.net/RyanDHatch/?p=116\n     * \n     * @return Returns the new merged series.\n     * \n     * @example\n     * <pre>\n     * \n     * // Join together two sets of customers to find those\n     * // that have bought either just product B or both product A and product B.\n     * const customerWhoBoughtProductA = ...\n     * const customerWhoBoughtProductB = ...\n     * const boughtJustAorAandB = customerWhoBoughtProductA.joinOuterRight(\n     *          customerWhoBoughtProductB,\n     *          customerA => customerA.CustomerId, // Join key.\n     *          customerB => customerB.CustomerId, // Join key.\n     *          (customerA, customerB) => {\n     *              return {\n     *                  // ... merge the results ...\n     *              };\n     *          }\n     *      );\n     * </pre>\n     */\n    joinOuterRight<KeyT, InnerIndexT, InnerValueT, ResultValueT> (\n        inner: ISeries<InnerIndexT, InnerValueT>, \n        outerKeySelector: SelectorFn<ValueT, KeyT>, \n        innerKeySelector: SelectorFn<InnerValueT, KeyT>, \n        resultSelector: JoinFn<ValueT | null, InnerValueT | null, ResultValueT>):\n            ISeries<number, ResultValueT> {\n\n        if (!isFunction(outerKeySelector)) throw new Error(\"Expected 'outerKeySelector' parameter of 'Series.joinOuterRight' to be a selector function.\");\n        if (!isFunction(innerKeySelector)) throw new Error(\"Expected 'innerKeySelector' parameter of 'Series.joinOuterRight' to be a selector function.\");\n        if (!isFunction(resultSelector)) throw new Error(\"Expected 'resultSelector' parameter of 'Series.joinOuterRight' to be a selector function.\");\n\n        // Get the results in the inner that are not in the outer.\n        const outer = this;\n        const innerResult = inner.except<IndexT, ValueT, KeyT>(outer, innerKeySelector, outerKeySelector)\n            .select(inner => resultSelector(null, inner))\n            .resetIndex();\n\n        // Get the intersection of results between inner and outer.\n        const intersectionResults = outer.join<KeyT, InnerIndexT, InnerValueT, ResultValueT>(inner, outerKeySelector, innerKeySelector, resultSelector);\n\n        return intersectionResults\n            .concat(innerResult)\n            .resetIndex();\n    }    \n\n    /**\n     * Produces a new series with all string values truncated to the requested maximum length.\n     *\n     * @param maxLength - The maximum length of the string values after truncation.\n     * \n     * @returns Returns a new series with strings that are truncated to the specified maximum length. \n     * \n     * @example\n     * <pre>\n     * \n     * const truncated = series.truncateStrings(10); // Truncate all string values to max length of 10 characters.\n     * </pre>\n     */\n    truncateStrings (maxLength: number): ISeries<IndexT, ValueT> {\n\n        if (!isNumber(maxLength)) throw new Error(\"Expected 'maxLength' parameter to 'Series.truncateStrings' to be a number.\");\n\n        return this.select((value: any) => {\n                if (isString(value)) {\n                    if (value.length > maxLength) {\n                        return value.substring(0, maxLength);\n                    }\n                }\n\n                return value;\n            });\n    };    \n\n    /**\n     * Insert a pair at the start of the series.\n     * Doesn't modify the original series! The returned series is entirely new and contains values from the original series plus the inserted pair.\n     *\n     * @param pair The index/value pair to insert.\n     * \n     * @return Returns a new series with the specified pair inserted.\n     * \n     * @example\n     * <pre>\n     * \n     * const newIndex = ... index of the new row ...\n     * const newRow = ... the new data row to insert ...\n     * const insertedSeries = series.insertPair([newIndex, newRows]);\n     * </pre>\n     */\n    insertPair (pair: [IndexT, ValueT]): ISeries<IndexT, ValueT> {\n        if (!isArray(pair)) throw new Error(\"Expected 'pair' parameter to 'Series.insertPair' to be an array.\");\n        if (pair.length !== 2) throw new Error(\"Expected 'pair' parameter to 'Series.insertPair' to be an array with two elements. The first element is the index, the second is the value.\");\n\n        return (new Series<IndexT, ValueT>({ pairs: [pair] })).concat(this);\n    }\n\n    /**\n     * Append a pair to the end of a series.\n     * Doesn't modify the original series! The returned series is entirely new and contains values from the original series plus the appended pair.\n     *\n     * @param pair The index/value pair to append.\n     *  \n     * @return Returns a new series with the specified pair appended.\n     * \n     * @example\n     * <pre>\n     * \n     * const newIndex = ... index of the new row ...\n     * const newRow = ... the new data row to append ...\n     * const appendedSeries = series.appendPair([newIndex, newRows]);\n     * </pre>\n     */\n    appendPair (pair: [IndexT, ValueT]): ISeries<IndexT, ValueT> {\n        if (!isArray(pair)) throw new Error(\"Expected 'pair' parameter to 'Series.appendPair' to be an array.\");\n        if (pair.length !== 2) throw new Error(\"Expected 'pair' parameter to 'Series.appendPair' to be an array with two elements. The first element is the index, the second is the value.\");\n\n        return this.concat(new Series<IndexT, ValueT>({ pairs: [pair] }));\n    }\n\n    /**\n     * Fill gaps in a series.\n     *\n     * @param comparer User-defined comparer function that is passed pairA and pairB, two consecutive values, return truthy if there is a gap between the value, or falsey if there is no gap.\n     * @param generator User-defined generator function that is passed pairA and pairB, two consecutive values, returns an array of pairs that fills the gap between the values.\n     *\n     * @return Returns a new series with gaps filled in.\n     * \n     * @example\n     * <pre>\n     * \n     *   var sequenceWithGaps = ...\n     *\n     *  // Predicate that determines if there is a gap.\n     *  var gapExists = (pairA, pairB) => {\n     *      // Returns true if there is a gap.\n     *      return true;\n     *  };\n     *\n     *  // Generator function that produces new rows to fill the game.\n     *  var gapFiller = (pairA, pairB) => {\n     *      // Create an array of index, value pairs that fill the gaps between pairA and pairB.\n     *      return [\n     *          newPair1,\n     *          newPair2,\n     *          newPair3,\n     *      ];\n     *  };\n     *\n     *  var sequenceWithoutGaps = sequenceWithGaps.fillGaps(gapExists, gapFiller);\n     * </pre>\n     */\n    fillGaps (comparer: ComparerFn<[IndexT, ValueT], [IndexT, ValueT]>, generator: GapFillFn<[IndexT, ValueT], [IndexT, ValueT]>): ISeries<IndexT, ValueT> {\n        if (!isFunction(comparer)) throw new Error(\"Expected 'comparer' parameter to 'Series.fillGaps' to be a comparer function that compares two values and returns a boolean.\")\n        if (!isFunction(generator)) throw new Error(\"Expected 'generator' parameter to 'Series.fillGaps' to be a generator function that takes two values and returns an array of generated pairs to span the gap.\")\n\n        return this.rollingWindow(2)\n            .selectMany((window): [IndexT, ValueT][] => {\n                const pairs = window.toPairs();\n                const pairA = pairs[0];\n                const pairB = pairs[1];\n                if (!comparer(pairA, pairB)) {\n                    return [pairA];\n                }\n\n                const generatedRows = generator(pairA, pairB);\n                if (!isArray(generatedRows)) throw new Error(\"Expected return from 'generator' parameter to 'Series.fillGaps' to be an array of pairs, instead got a \" + typeof(generatedRows));\n\n                return [pairA].concat(generatedRows);\n            })\n            .withIndex(pair => pair[0])\n            .select(pair => pair[1])\n            .concat(this.tail(1));\n    }\n\n    /**\n     * Returns the specified default series if the input series is empty. \n     *\n     * @param defaultSequence Default series to return if the input series is empty.\n     * \n     * @return Returns 'defaultSequence' if the input series is empty. \n     * \n     * @example\n     * <pre>\n     * \n     * const emptySeries = new Series();\n     * const defaultSeries = new Series([ 1, 2, 3 ]);\n     * expect(emptyDataFrame.defaultIfEmpty(defaultSeries)).to.eql(defaultSeries);\n     * </pre>\n     * \n     * @example\n     * <pre>\n     * \n     * const nonEmptySeries = new Series([ 100 ]);\n     * const defaultSeries = new Series([ 1, 2, 3 ]);\n     * expect(nonEmptySeries.defaultIfEmpty(defaultSeries)).to.eql(nonEmptySeries);\n     * </pre>\n     */\n    defaultIfEmpty (defaultSequence: ValueT[] | ISeries<IndexT, ValueT>): ISeries<IndexT, ValueT> {\n\n        if (this.none()) {\n            if (defaultSequence instanceof Series) {\n                return <ISeries<IndexT, ValueT>> defaultSequence;\n            }\n            else if (isArray(defaultSequence)) {\n                return new Series<IndexT, ValueT>(defaultSequence);\n            }\n            else {\n                throw new Error(\"Expected 'defaultSequence' parameter to 'Series.defaultIfEmpty' to be an array or a series.\");\n            }\n        } \n        else {\n            return this;\n        }\n    }\n\n    /**\n     * Detect the the frequency of the types of the values in the series.\n     * This is a good way to understand the shape of your data.\n     *\n     * @return Returns a {@link DataFrame} with rows that confirm to {@link ITypeFrequency} that describes the data types contained in the original series.\n     * \n     * @example\n     * <pre>\n     * \n     * const dataTypes = series.detectTypes();\n     * console.log(dataTypes.toString());\n     * </pre>\n     */\n    detectTypes (): IDataFrame<number, ITypeFrequency> {\n\n        return new DataFrame<number, ITypeFrequency>(() => {\n            const totalValues = this.count();\n\n            const typeFrequencies = this.select(value => {\n                    let valueType: string = typeof(value);\n                    if (valueType === \"object\") {\n                        if (isDate(value)) {\n                            valueType = \"date\";\n                        }\n                    }\n                    return valueType;\n                })\n                .aggregate({}, (accumulated: any, valueType: string) => {\n                    var typeInfo = accumulated[valueType];\n                    if (!typeInfo) {\n                        typeInfo = {\n                            count: 0\n                        };\n                        accumulated[valueType] = typeInfo;\n                    }\n                    ++typeInfo.count;\n                    return accumulated;\n                });\n\n            return {\n                columnNames: [\"Type\", \"Frequency\"],\n                rows: Object.keys(typeFrequencies)\n                    .map(valueType => {\n                        return [\n                            valueType,\n                            (typeFrequencies[valueType].count / totalValues) * 100\n                        ];\n                    })\n            };\n        });\n    }\n\n    /**\n     * Detect the frequency of the values in the series.\n     * This is a good way to understand the shape of your data.\n     *\n     * @return Returns a {@link DataFrame} with rows that conform to {@link IValueFrequency} that describes the values contained in the original series.\n     * \n     * @example\n     * <pre>\n     * \n     * const dataValues = series.detectValues();\n     * console.log(dataValues.toString());\n     * </pre>\n     */\n    detectValues (): IDataFrame<number, IValueFrequency> {\n\n        return new DataFrame<number, IValueFrequency>(() => {\n            const totalValues = this.count();\n            const valueFrequencies = this.aggregate(new Map<any, any>(), (accumulated: Map<any, any>, value: any) => {\n                let valueInfo = accumulated.get(value);\n                if (!valueInfo) {\n                    valueInfo = {\n                        count: 0,\n                        value: value,\n                    };\n                    accumulated.set(value, valueInfo);\n                }\n                ++valueInfo.count;\n                return accumulated;\n            });\n\n            return {\n                columnNames: [\"Value\", \"Frequency\"],\n                rows: Array.from(valueFrequencies.keys())\n                    .map(value => {\n                        const valueInfo = valueFrequencies.get(value);\n                        return [\n                            valueInfo.value,\n                            (valueInfo.count / totalValues) * 100\n                        ];\n                    }),\n            };\n        });\n    }\n\n    /**\n     * Organise all values in the series into the specified number of buckets.\n     * Assumes that the series is a series of numbers.\n     * \n     * @param numBuckets - The number of buckets to create.\n     * \n     * @returns Returns a dataframe containing bucketed values. The input values are divided up into these buckets.\n     * \n     * @example\n     * <pre>\n     * \n     * const buckets = series.bucket(20); // Distribute values into 20 evenly spaced buckets.\n     * console.log(buckets.toString());\n     * </pre>\n     */\n    bucket (numBuckets: number): IDataFrame<IndexT, IBucket> {\n\n        if (this.none()) {\n            return new DataFrame();\n        }\n\n        const numberSeries = this as any as ISeries<IndexT, number>;\n        var min = numberSeries.min();\n        var max = numberSeries.max();\n        var range = max - min;\n        var width = range / (numBuckets-1);\n        return numberSeries.select(v => {\n                var bucket = Math.floor((v - min) / width);\n                var bucketMin = (bucket * width) + min;\n                return {\n                    Value: v,\n                    Bucket: bucket,\n                    Min: bucketMin,\n                    Mid: bucketMin + (width*0.5),\n                    Max: bucketMin + width,\n                };\n            })\n            .inflate();\n    }\n\n    /***\n     * Allows the series to be queried to confirm that it is actually a series.\n     * Used from JavaScript to tell the difference between a Series and a DataFrame.\n     * \n     * @return Returns the string \"series\".\n     */\n    getTypeCode (): string {\n        return \"series\";\n    }    \n}\n\n/**\n * @hidden\n * The configuration for an ordered series.\n */\ninterface IOrderedSeriesConfig<IndexT, ValueT, SortT> {\n\n    //\n    // The source values for the ordered series.\n    //\n    values: Iterable<ValueT>;\n\n    //\n    // The source pairs (index,value) for the ordered series.\n    //\n    pairs: Iterable<[IndexT, ValueT]>;\n\n    //\n    // The selector used to get the sorting key for the orderby operation.\n    //\n    selector: SelectorWithIndexFn<ValueT, SortT>;\n\n    //\n    // The sort direction, ascending or descending.\n    //\n    direction: Direction;\n\n    //\n    // The parent series in the orderby operation or null if none.\n    //\n    parent: OrderedSeries<IndexT, ValueT, any> | null;\n}\n\n/**\n * @hidden\n * A series that has been ordered.\n */\nclass OrderedSeries<IndexT = number, ValueT = any, SortT = any> \n    extends Series<IndexT, ValueT>\n    implements IOrderedSeries<IndexT, ValueT, SortT> {\n\n    //\n    // Configuration for the ordered series.\n    //\n    config: IOrderedSeriesConfig<IndexT, ValueT, SortT>;\n\n    //\n    // Helper function to create a sort spec.\n    //\n    private static makeSortSpec (sortLevel: number, selector: SortSelectorFn, direction: Direction): ISortSpec {\n        return { sortLevel: sortLevel, selector: selector, direction: direction };\n    }\n\n    //\n    // Helper function to make a sort selector for pairs, this captures the parent correct when generating the closure.\n    //\n    private static makePairsSelector (selector: SortSelectorFn): SortSelectorFn {\n        return (pair: any, index: number) => selector(pair[1], index);\n    }\n\n    constructor(config: IOrderedSeriesConfig<IndexT, ValueT, SortT>) {\n\n        const valueSortSpecs: ISortSpec[] = [];\n        const pairSortSpecs: ISortSpec[] = [];\n        let sortLevel = 0;\n\n        let parent = config.parent;\n\n        while (parent !== null) {\n            const parentConfig = parent.config;\n            valueSortSpecs.push(OrderedSeries.makeSortSpec(sortLevel, parentConfig.selector, parentConfig.direction));\n            pairSortSpecs.push(OrderedSeries.makeSortSpec(sortLevel, OrderedSeries.makePairsSelector(parentConfig.selector), parentConfig.direction));\n            ++sortLevel;\n            parent = parentConfig.parent;\n        }\n\n        valueSortSpecs.push(OrderedSeries.makeSortSpec(sortLevel, config.selector, config.direction));\n        pairSortSpecs.push(OrderedSeries.makeSortSpec(sortLevel, OrderedSeries.makePairsSelector(config.selector), config.direction));\n\n        super({\n            values: new OrderedIterable(config.values, valueSortSpecs),\n            pairs: new OrderedIterable(config.pairs, pairSortSpecs)\n        });\n\n        this.config = config;\n    }\n\n    /** \n     * Applys additional sorting (ascending) to an already sorted series.\n     * \n     * @param selector User-defined selector that selects the additional value to sort by.\n     * \n     * @return Returns a new series has been additionally sorted by the value chosen by the selector function. \n     * \n     * @example\n     * <pre>\n     * \n     * // Order sales by salesperson and then by amount (from least to most).\n     * const ordered = sales.orderBy(sale => sale.SalesPerson).thenBy(sale => sale.Amount);\n     * </pre>\n     */\n    thenBy<SortT> (selector: SelectorWithIndexFn<ValueT, SortT>): IOrderedSeries<IndexT, ValueT, SortT> {\n        return new OrderedSeries<IndexT, ValueT, SortT>({\n            values: this.config.values, \n            pairs: this.config.pairs, \n            selector: selector, \n            direction: Direction.Ascending, \n            parent: this,\n        });\n    }\n\n    /** \n     * Applys additional sorting (descending) to an already sorted series.\n     * \n     * @param selector User-defined selector that selects the additional value to sort by.\n     * \n     * @return Returns a new series has been additionally sorted by the value chosen by the selector function. \n     * \n     * @example\n     * <pre>\n     * \n     * // Order sales by salesperson and then by amount (from most to least).\n     * const ordered = sales.orderBy(sale => sale.SalesPerson).thenByDescending(sale => sale.Amount);\n     * </pre>\n     */\n    thenByDescending<SortT> (selector: SelectorWithIndexFn<ValueT, SortT>): IOrderedSeries<IndexT, ValueT, SortT> {\n        return new OrderedSeries<IndexT, ValueT, SortT>({\n            values: this.config.values,\n            pairs: this.config.pairs, \n            selector: selector, \n            direction: Direction.Descending, \n            parent: this\n        });\n    }\n}\n","import { ArrayIterable }  from './iterables/array-iterable';\nimport { EmptyIterable }  from './iterables/empty-iterable';\nimport { CountIterable }  from './iterables/count-iterable';\nimport { MultiIterable }  from './iterables/multi-iterable';\nimport { SelectIterable }  from './iterables/select-iterable';\nimport { SelectManyIterable }  from './iterables/select-many-iterable';\nimport { TakeIterable }  from './iterables/take-iterable';\nimport { TakeWhileIterable }  from './iterables/take-while-iterable';\nimport { WhereIterable }  from './iterables/where-iterable';\nimport { ConcatIterable }  from './iterables/concat-iterable';\nimport { DataFrameWindowIterable }  from './iterables/dataframe-window-iterable';\nimport { ReverseIterable }  from './iterables/reverse-iterable';\nimport { ZipIterable }  from './iterables/zip-iterable';\nimport { CsvRowsIterable }  from './iterables/csv-rows-iterable';\nimport { DistinctIterable }  from './iterables/distinct-iterable';\nimport { DataFrameRollingWindowIterable }  from './iterables/dataframe-rolling-window-iterable';\nimport { DataFrameVariableWindowIterable }  from './iterables/dataframe-variable-window-iterable';\nimport { OrderedIterable, Direction, ISortSpec, SelectorFn as SortSelectorFn }  from './iterables/ordered-iterable';\nimport { IIndex, Index } from './index';\nimport { ExtractElementIterable } from './iterables/extract-element-iterable';\nimport { SkipIterable } from './iterables/skip-iterable';\nimport { SkipWhileIterable } from './iterables/skip-while-iterable';\nconst Table = require('easy-table');\nimport * as moment from \"dayjs\";\nimport { ISeries, Series, SelectorWithIndexFn, PredicateFn, ComparerFn, SelectorFn, AggregateFn, Zip2Fn, Zip3Fn, Zip4Fn, Zip5Fn, ZipNFn, CallbackFn, JoinFn, GapFillFn, ISeriesConfig } from './series';\nimport { ColumnNamesIterable } from './iterables/column-names-iterable';\nimport { toMap, makeDistinct, mapIterable, determineType, toMap2, isArray, isString, isFunction, isObject, isUndefined, isNumber } from './utils';\nimport { ISerializedDataFrame } from \"@data-forge/serialization\";\n\nconst PapaParse = require('papaparse');\n\n/** \n * An object whose fields specify the data for named columns.\n */\nexport interface IColumnSpec {\n    [index: string]: Iterable<any> | ISeries<any, any>,\n}\n\n/**\n * Specifes the format per column when converting columns to strings.\n */\nexport interface IFormatSpec {\n    [index: string]: string;\n}\n\n/**\n * An function that aggregates a series.\n */\nexport type SeriesAggregatorFn<IndexT, ValueT, OutputT> = (values: ISeries<IndexT, ValueT>) => OutputT;\n\n/**\n * Specification that can produce multiple output columns from a single input column of a dataframe.\n */\nexport interface IColumnAggregatorSpec {\n    [outputColumnName: string]: SeriesAggregatorFn<any, any, any>,\n} \n\n/**\n * Specification that can aggregate multiple input columns in a dataframe to produce multiple output columns.\n */\nexport interface IMultiColumnAggregatorSpec {\n    [inputColumnName: string]: SeriesAggregatorFn<any, any, any> | IColumnAggregatorSpec;\n}\n\n/**\n * Defines the configuration for a new column.\n */\nexport interface IColumnConfig {\n    /**\n     * The name of the new column.\n     */\n    name: string;\n\n    /**\n     * The series of values for the column.\n     */\n    series: Iterable<any> | ISeries<any, any>;\n}\n\n/**\n * Options for CSV output.\n */\nexport interface ICSVOutputOptions {\n    /**\n     * Enable or disable output of the CSV header line.\n     * Defaults to true.\n     */\n    header?: boolean;\n}\n\n/**\n * Used to configure a dataframe.\n */\nexport interface IDataFrameConfig<IndexT, ValueT> {\n    /**\n     * Values to put in the dataframe.\n     * This should be array or iterable of JavaScript objects.\n     * Each element in the array contains fields that match the columns of the dataframe.\n     */\n    values?: Iterable<ValueT>,\n\n    /**\n     * CSV style rows to put in the dataframe.\n     * An array of arrays. Each element in the top level array is a row of data.\n     * Each row of data contains field values in column order.\n     */\n    rows?: Iterable<any[]>,\n\n    /***\n     * The index for the dataframe.\n     * If omitted the index will default to a 0-based index.\n     */\n    index?: Iterable<IndexT>,\n\n    /**\n     * Array or iterable of index,value pairs to put in the dataframe.\n     * If index and values are not separately specified they can be extracted\n     * from the pairs.\n     */\n    pairs?: Iterable<[IndexT, ValueT]>,\n\n    /**\n     * Array or iterable of column names that are in the dataframe.\n     * The order matters. This arrays specifies the ordering of columns which\n     * is important when rendering tables or writing out CSV data files.\n     * If this is omitted column names will automatically be determined\n     * from the fields of the first row/value in the dataframe.\n     */\n    columnNames?: Iterable<string>,\n\n    /***\n     * Set to true when the dataframe has been baked into memory\n     * and does not need to be lazily evaluated.\n     */\n    baked?: boolean,\n\n    /**\n     * Set to true to consider all rows/values in the dataframe when\n     * determining the column names. Otherwise only the first row is considered.\n     * You should use this if you have ireggular fields in the objects that\n     * make up the rows/values of the dataframe.\n     */\n    considerAllRows?: boolean,\n\n    /**\n     * Explicitly specify data for named columns to put in the dataframe.\n     */\n    columns?: Iterable<IColumnConfig> | IColumnSpec,\n};\n\n/** \n * Represents a named column in a dataframe.\n */\nexport interface IColumn {\n    \n    /**\n     * The name of the column.\n     */\n    name: string;\n\n    /**\n     * The data type of the column.\n     */\n    type: string;\n\n    /**\n     * The data series from the column.\n     */\n    series: ISeries<any, any>;\n}\n\n/** \n * An object whose fields specify data for named named columns or user-defined generator functions that generate the data for the columns.\n */\nexport interface IColumnGenSpec { //todo: this should allow iterable as well!\n    [index: string]: ISeries<any, any> | SeriesSelectorFn<any, any, any>,\n}\n\n/**\n * A string-to-string mapping that specifies how to rename columns.\n */\nexport interface IColumnRenameSpec {\n    [index: string]: string;\n}\n\n/**\n * Specifies columns to transform and the user-defined selector function that does the transformation.\n */\nexport interface IColumnTransformSpec {\n    [columnName: string]: SelectorWithIndexFn<any, any>;\n}\n\n/**\n * Specifies columns that should be aggregated and a user-defined aggregator function to do the aggregation.\n */\nexport interface IColumnAggregateSpec {\n    [index: string]: AggregateFn<any, any>;\n}\n\n/**\n * A selector function that can select a series from a dataframe.\n */\nexport type SeriesSelectorFn<IndexT, DataFrameValueT, SeriesValueT> = (dataFrame: IDataFrame<IndexT, DataFrameValueT>) => ISeries<IndexT, SeriesValueT>;\n\n/*\n * A function that generates a dataframe content object.\n * Used to make it easy to create lazy evaluated dataframes.\n */\nexport type DataFrameConfigFn<IndexT, ValueT> = () => IDataFrameConfig<IndexT, ValueT>;\n\n/**\n * Represents the frequency of a type in a series or dataframe.\n */\nexport interface ITypeFrequency {\n\n    /**\n     * Name of the column containing the value.\n     */\n    Column: string;\n\n    /**\n     * The name of the type.\n     */\n    Type: string; \n\n    /**\n     * The frequency of the type's appearance in the series or dataframe.\n     */\n    Frequency: number;\n}\n\n/**\n * Represents the frequency of a value in a series or dataframe.\n */\nexport interface IValueFrequency {\n\n    /**\n     * Name of the column containing the value.\n     */\n    Column: string;\n\n    /**\n     * The value.\n     */\n    Value: any; \n\n    /**\n     * The frequency of the value's appearance in the series or dataframe.\n     */\n    Frequency: number;\n}\n\n/**\n * Interface that represents a dataframe.\n * A dataframe contains an indexed sequence of data records.\n * Think of it as a spreadsheet or CSV file in memory.\n * \n * Each data record contains multiple named fields, the value of each field represents one row in a column of data.\n * Each column of data is a named {@link Series}.\n * You think of a dataframe a collection of named data series.\n * \n * @typeparam IndexT The type to use for the index.\n * @typeparam ValueT The type to use for each row/data record.\n */\nexport interface IDataFrame<IndexT = number, ValueT = any> extends Iterable<ValueT> {\n\n    /**\n     * Get an iterator to enumerate the rows of the dataframe.\n     * Enumerating the iterator forces lazy evaluation to complete.\n     * This function is automatically called by `for...of`.\n     * \n     * @return An iterator for the rows in the dataframe.\n     * \n     * @example\n     * <pre>\n     * \n     * for (const row of df) {\n     *     // ... do something with the row ...\n     * }\n     * </pre>\n     */\n    [Symbol.iterator] (): Iterator<ValueT>;\n\n    /**\n     * Get the names of the columns in the dataframe.\n     * \n     * @return Returns an array of the column names in the dataframe.  \n     * \n     * @example\n     * <pre>\n     * \n     * console.log(df.getColumnNames());\n     * </pre>\n     */\n    getColumnNames (): string[];\n\n    /** \n     * Retreive the collection of all columns in the dataframe.\n     * \n     * @return Returns a {@link Series} containing the names of the columns in the dataframe.\n     * \n     * @example\n     * <pre>\n     * \n     * for (const column in df.getColummns()) {\n     *      console.log(\"Column name: \");\n     *      console.log(column.name);\n     * \n     *      console.log(\"Data:\");\n     *      console.log(column.series.toArray());\n     * }\n     * </pre>\n     */\n    getColumns (): ISeries<number, IColumn>;\n\n    /**\n     * Cast the value of the dataframe to a new type.\n     * This operation has no effect but to retype the r9ws that the dataframe contains.\n     * \n     * @return The same dataframe, but with the type changed.\n     * \n     * @example\n     * <pre>\n     * \n     * const castDf = df.cast<SomeOtherType>();\n     * </pre>\n     */\n    cast<NewValueT> (): IDataFrame<IndexT, NewValueT>;\n    \n    /**\n     * Get the index for the dataframe.\n     * \n     * @return The {@link Index} for the dataframe.\n     * \n     * @example\n     * <pre>\n     * \n     * const index = df.getIndex();\n     * </pre>\n     */\n    getIndex (): IIndex<IndexT>;\n\n    /**\n     * Set a named column as the {@link Index} of the dataframe.\n     *\n     * @param columnName Name of the column to use as the new {@link Index} of the returned dataframe.\n     *\n     * @return Returns a new dataframe with the values of the specified column as the new {@link Index}.\n     * \n     * @example\n     * <pre>\n     * \n     * const indexedDf = df.setIndex(\"SomeColumn\");\n     * </pre>\n     */\n    setIndex<NewIndexT = any> (columnName: string): IDataFrame<NewIndexT, ValueT>;\n    \n    /**\n     * Apply a new {@link Index} to the dataframe.\n     * \n     * @param newIndex The new array or iterable to be the new {@link Index} of the dataframe. Can also be a selector to choose the {@link Index} for each row in the dataframe.\n     * \n     * @return Returns a new dataframe with the specified {@link Index} attached.\n     * \n     * @example\n     * <pre>\n     * \n     * const indexedDf = df.withIndex([10, 20, 30]);\n     * </pre>\n     * \n     * @example\n     * <pre>\n     * \n     * const indexedDf = df.withIndex(df.getSeries(\"SomeColumn\"));\n     * </pre>\n     * \n     * @example\n     * <pre>\n     * \n     * const indexedDf = df.withIndex(row => row.SomeColumn);\n     * </pre>\n     * \n     * @example\n     * <pre>\n     * \n     * const indexedDf = df.withIndex(row => row.SomeColumn + 20);\n     * </pre>\n     */\n    withIndex<NewIndexT> (newIndex: Iterable<NewIndexT> | SelectorFn<ValueT, NewIndexT>): IDataFrame<NewIndexT, ValueT>;\n\n    /**\n     * Resets the {@link Index} of the dataframe back to the default zero-based sequential integer index.\n     * \n     * @return Returns a new dataframe with the {@link Index} reset to the default zero-based index. \n     * \n     * @example\n     * <pre>\n     * \n     * const dfWithResetIndex = df.resetIndex();\n     * </pre>\n     */\n    resetIndex (): IDataFrame<number, ValueT>;\n    \n    /**\n     * Extract a {@link Series} from a named column in the dataframe.\n     *\n     * @param columnName Specifies the name of the column that contains the {@link Series} to retreive.\n     * \n     * @return Returns the {@link Series} extracted from the named column in the dataframe.\n     * \n     * @example\n     * <pre>\n     * \n     * const series = df.getSeries(\"SomeColumn\");\n     * </pre>\n     */\n    getSeries<SeriesValueT = any> (columnName: string): ISeries<IndexT, SeriesValueT>;\n\n    /**\n     * Determine if the dataframe contains a {@link Series} the specified named column.\n     *\n     * @param columnName Name of the column to check for.\n     * \n     * @return Returns true if the dataframe contains the requested {@link Series}, otherwise returns false.\n     * \n     * @example\n     * <pre>\n     * \n     * if (df.hasSeries(\"SomeColumn\")) {\n     *      // ... the dataframe contains a series with the specified column name ...\n     * }\n     * </pre>\n     */\n    hasSeries (columnName: string): boolean;\n\n    /**\n     * Verify the existence of a name column and extracts the {@link Series} for it.\n     * Throws an exception if the requested column doesn't exist.\n     *\n     * @param columnName Name of the column to extract.\n     * \n     * @return Returns the {@link Series} for the column if it exists, otherwise it throws an exception.\n     * \n     * @example\n     * <pre>\n     * \n     * try {\n     *      const series = df.expectSeries(\"SomeColumn\");\n     *      // ... do something with the series ...\n     * }\n     * catch (err) {\n     *      // ... the dataframe doesn't contain the column \"SomeColumn\" ...\n     * }\n     * </pre>\n     */\n    expectSeries<SeriesValueT> (columnName: string): ISeries<IndexT, SeriesValueT>;\n\n    /**\n     * Create a new dataframe with a replaced or additional column specified by the passed-in series.\n     *\n     * @param columnNameOrSpec The name of the column to add or replace or a {@link IColumnGenSpec} that defines the columns to add.\n     * @param [series] When columnNameOrSpec is a string that identifies the column to add, this specifies the {@link Series} to add to the dataframe or a function that produces a series (given a dataframe).\n     *\n     * @return Returns a new dataframe replacing or adding a particular named column.\n     * \n     * @example\n     * <pre>\n     * \n     * const modifiedDf = df.withSeries(\"ANewColumn\", new Series([1, 2, 3]));\n     * </pre>\n     * \n     * @example\n     * <pre>\n     * \n     * const modifiedDf = df.withSeries(\"ANewColumn\", df => \n     *      df.getSeries(\"SourceData\").select(aTransformation)\n     * );\n     * </pre>\n     * \n     * @example\n     * <pre>\n     * \n     * const modifiedDf = df.withSeries({\n     *      ANewColumn: new Series([1, 2, 3]),\n     *      SomeOtherColumn: new Series([10, 20, 30])\n     * });\n     * <pre>\n     * \n     * @example\n     * <pre>\n     * \n     * const modifiedDf = df.withSeries({\n     *      ANewColumn: df => df.getSeries(\"SourceData\").select(aTransformation))\n     * });\n     * <pre>\n     */\n    withSeries<OutputValueT = any, SeriesValueT = any> (columnNameOrSpec: string | IColumnGenSpec, series?: ISeries<IndexT, SeriesValueT> | SeriesSelectorFn<IndexT, ValueT, SeriesValueT>): IDataFrame<IndexT, OutputValueT>;\n\n    /**\n     * Merge one or more dataframes into this single dataframe.\n     * Rows are merged by indexed. \n     * Same named columns in subsequent dataframes override columns in earlier dataframes.\n     * \n     * @param otherDataFrames... One or more dataframes to merge into this dataframe.\n     * \n     * @returns The merged data frame.\n     * \n     * @example\n     * <pre>\n     * \n     * const mergedDF = df1.merge(df2);\n     * </pre>\n     * \n     * <pre>\n     * \n     * const mergedDF = df1.merge(df2, df3, etc);\n     * </pre>\n     */\n    merge<MergedValueT = any>(...otherDataFrames: IDataFrame<IndexT, any>[]): IDataFrame<IndexT, MergedValueT>;\n    \n    /**\n     * Add a series to the dataframe, but only if it doesn't already exist.\n     * \n     * @param columnNameOrSpec The name of the series to add or a {@link IColumnGenSpec} that specifies the columns to add.\n     * @param [series] If columnNameOrSpec is a string that specifies the name of the series to add, this specifies the actual {@link Series} to add or a selector that generates the series given the dataframe.\n     * \n     * @return Returns a new dataframe with the specified series added, if the series didn't already exist. Otherwise if the requested series already exists the same dataframe is returned.\n     * \n     * @example\n     * <pre>\n     * \n     * const updatedDf = df.ensureSeries(\"ANewColumn\", new Series([1, 2, 3]));\n     * </pre>\n     * \n     * @example\n     * <pre>\n     * \n     * const updatedDf = df.ensureSeries(\"ANewColumn\", df => \n     *      df.getSeries(\"AnExistingSeries\").select(aTransformation)\n     * );\n     * </pre>\n     * \n     * @example\n     * <pre>\n     * \n     * const modifiedDf = df.ensureSeries({\n     *      ANewColumn: new Series([1, 2, 3]),\n     *      SomeOtherColumn: new Series([10, 20, 30])\n     * });\n     * <pre>\n     * \n     * @example\n     * <pre>\n     * \n     * const modifiedDf = df.ensureSeries({\n     *      ANewColumn: df => df.getSeries(\"SourceData\").select(aTransformation))\n     * });\n     * <pre>\n     */\n    ensureSeries<SeriesValueT> (columnNameOrSpec: string | IColumnGenSpec, series?: ISeries<IndexT, SeriesValueT> | SeriesSelectorFn<IndexT, ValueT, SeriesValueT>): IDataFrame<IndexT, ValueT>;\n\n    /**\n     * Create a new dataframe with just a subset of columns.\n     *\n     * @param columnNames Array of column names to include in the new dataframe.\n     * \n     * @return Returns a dataframe with a subset of columns from the original dataframe.\n     * \n     * @example\n     * <pre>\n     * const subsetDf = df.subset([\"ColumnA\", \"ColumnB\"]);\n     * </pre>\n     */\n    subset<NewValueT = ValueT> (columnNames: string[]): IDataFrame<IndexT, NewValueT>;\n\n    /**\n     * Create a new dataframe with the requested column or columns dropped.\n     *\n     * @param columnOrColumns Specifies the column name (a string) or columns (array of strings) to drop.\n     * \n     * @return Returns a new dataframe with a particular named column or columns removed.\n     * \n     * @example\n     * <pre>\n     * const modifiedDf = df.dropSeries(\"SomeColumn\");\n     * </pre>\n     * \n     * @example\n     * <pre>\n     * const modifiedDf = df.dropSeries([\"ColumnA\", \"ColumnB\"]);\n     * </pre>\n     */\n    dropSeries<NewValueT = ValueT> (columnOrColumns: string | string[]): IDataFrame<IndexT, NewValueT>;\n\n    /**\n     * Create a new dataframe with columns reordered.\n     * New column names create new columns (with undefined values), omitting existing column names causes those columns to be dropped.\n     * \n     * @param columnNames Specifies the new order for columns.\n     * \n     * @return Returns a new dataframe with columns reodered according to the order of the array of column names that is passed in.\n     * \n     * @example\n     * <pre>\n     * const reorderedDf = df.reorderSeries([\"FirstColumn\", \"SecondColumn\", \"etc\"]);\n     * </pre>\n     */\n    reorderSeries<NewValueT = ValueT> (columnNames: string[]): IDataFrame<IndexT, NewValueT>;\n\n    /**\n     * Bring the column(s) with specified name(s) to the front of the column order, making it (or them) the first column(s) in the output dataframe.\n     *\n     * @param columnOrColumns Specifies the column or columns to bring to the front.\n     *\n     * @return Returns a new dataframe with 1 or more columns bought to the front of the column ordering.\n     * \n     * @example\n     * <pre>\n     * const modifiedDf = df.bringToFront(\"NewFirstColumn\");\n     * </pre>\n     * \n     * @example\n     * <pre>\n     * const modifiedDf = df.bringToFront([\"NewFirstColumn\", \"NewSecondColumn\"]);\n     * </pre>\n     */\n    bringToFront (columnOrColumns: string | string[]): IDataFrame<IndexT, ValueT>;\n\n    /**\n     * Bring the column(s) with specified name(s) to the back of the column order, making it (or them) the last column(s) in the output dataframe.\n     *\n     * @param columnOrColumns Specifies the column or columns to bring to the back.\n     *\n     * @return Returns a new dataframe with 1 or more columns bought to the back of the column ordering.\n     * \n     * @example\n     * <pre>\n     * const modifiedDf = df.bringToBack(\"NewLastColumn\");\n     * </pre>\n     * \n     * @example\n     * <pre>\n     * const modifiedDf = df.bringToBack([\"NewSecondLastCollumn, \"\"NewLastColumn\"]);\n     * </pre>\n     */\n    bringToBack (columnOrColumns: string | string[]): IDataFrame<IndexT, ValueT>;\n\n    /**\n     * Create a new dataframe with 1 or more columns renamed.\n     *\n     * @param newColumnNames A column rename spec - a JavaScript hash that maps existing column names to new column names.\n     * \n     * @return Returns a new dataframe with specified columns renamed.\n     * \n     * @example\n     * <pre>\n     * \n     * const renamedDf = df.renameSeries({ OldColumnName, NewColumnName });\n     * </pre>\n     * \n     * @example\n     * <pre>\n     * \n     * const renamedDf = df.renameSeries({ \n     *      Column1: ColumnA,\n     *      Column2: ColumnB\n     * });\n     * </pre>\n     */\n    renameSeries<NewValueT = ValueT> (newColumnNames: IColumnRenameSpec): IDataFrame<IndexT, NewValueT>;\n\n    /**\n    * Extract rows from the dataframe as an array.\n    * Each element of the array is one row of the dataframe represented as\n    * a JavaScript object with the fields as the dataframe's columns.\n    * This forces lazy evaluation to complete.\n    * \n    * @return Returns an array of the rows contained within the dataframe. \n    * \n    * @example\n    * <pre>\n    * const values = df.toArray();\n    * </pre>\n    */\n   toArray (): ValueT[];\n\n    /**\n     * Retreive the index, row pairs from the dataframe as an array.\n     * Each pair is [index, row].\n     * This forces lazy evaluation to complete.\n     * \n     * @return Returns an array of pairs that contains the dataframe's rows. Each pair is a two element array that contains an index and a row.\n     * \n     * @example\n     * <pre>\n     * const pairs = df.toPairs();\n     * </pre>\n     */\n    toPairs (): ([IndexT, ValueT])[];\n\n    /**\n     * Convert the dataframe to a JavaScript object.\n     *\n     * @param keySelector User-defined selector function that selects keys for the resulting object.\n     * @param valueSelector User-defined selector function that selects values for the resulting object.\n     * \n     * @return Returns a JavaScript object generated from the dataframe by applying the key and value selector functions. \n     * \n     * @example\n     * <pre>\n     * \n     * const someObject = df.toObject(\n     *      row => row.SomeColumn, // Specify the column to use for field names in the output object.\n     *      row => row.SomeOtherColumn // Specifi the column to use as the value for each field.\n     * );\n     * </pre>\n     */\n    toObject<KeyT = any, FieldT = any, OutT = any> (keySelector: (value: ValueT) => KeyT, valueSelector: (value: ValueT) => FieldT): OutT;\n\n    /**\n     * Bake the data frame to an array of rows were each rows is an array of values in column order.\n     * \n     * @return Returns an array of rows. Each row is an array of values in column order.\n     * \n     * @example\n     * <pre>\n     * const rows = df.toRows();\n     * </pre>\n     */\n    toRows (): any[][];\n \n    /**\n     * Generates a new dataframe by repeatedly calling a user-defined selector function on each row in the original dataframe.\n     *\n     * @param selector A user-defined selector function that transforms each row to create the new dataframe.\n     * \n     * @return Returns a new dataframe with each row transformed by the selector function.\n     * \n     * @example\n     * <pre>\n     * \n     * function transformRow (inputRow) {\n     *      const outputRow = {\n     *          // ... construct output row derived from input row ...\n     *      };\n     *\n     *      return outputRow;\n     * }\n     *  \n     * const transformedDf = df.select(row => transformRow(row));\n     * </pre>\n     */\n    select<ToT> (selector: SelectorWithIndexFn<ValueT, ToT>): IDataFrame<IndexT, ToT>;\n\n    /**\n     * Generates a new dataframe by repeatedly calling a user-defined selector function on each row in the original dataframe.\n     * \n     * * Similar to the {@link select} function, but in this case the selector function produces a collection of output rows that are flattened and merged to create the new dataframe.\n     *\n     * @param selector A user-defined selector function that transforms each row into a collection of output rows.\n     * \n     * @return Returns a new dataframe where each row has been transformed into 0 or more new rows by the selector function. \n     * \n     * @example\n     * <pre>\n     * \n     * function produceOutputRows (inputRow) {\n     *      const outputRows = [];\n     *      while (someCondition) {\n     *          // ... generate zero or more output rows ...\n     *          outputRows.push(... some generated row ...);\n     *      }\n     *      return outputRows;\n     * }\n     * \n     * const modifiedDf = df.selectMany(row => produceOutputRows(row));\n     * </pre>\n     */\n    selectMany<ToT> (selector: SelectorWithIndexFn<ValueT, Iterable<ToT>>): IDataFrame<IndexT, ToT>;\n\n    /**\n     * Transform one or more columns. \n     * \n     * This is equivalent to extracting a {@link Series} with {@link getSeries}, then transforming it with {@link Series.select},\n     * and finally plugging it back in as the same column using {@link withSeries}.\n     *\n     * @param columnSelectors Object with field names for each column to be transformed. Each field specifies a selector function that transforms that column.\n     * \n     * @return Returns a new dataframe with 1 or more columns transformed.\n     * \n     * @example\n     * <pre>\n     * \n     * const modifiedDf = df.transformSeries({ \n     *      AColumnToTransform: columnValue => transformRow(columnValue) \n     * });\n     * </pre>\n     * \n     * @example\n     * <pre>\n     * \n     * const modifiedDf = df.transformSeries({ \n     *      ColumnA: columnValue => transformColumnA(columnValue),\n     *      ColumnB: columnValue => transformColumnB(columnValue)\n     * });\n     * </pre>\n     */\n    transformSeries<NewValueT = ValueT> (columnSelectors: IColumnTransformSpec): IDataFrame<IndexT, NewValueT>;\n\n    /** \n     * Generate new columns based on existing rows.\n     * \n     * This is equivalent to calling {@link select} to transform the original dataframe to a new dataframe with different column,\n     * then using {@link withSeries} to merge each the of both the new and original dataframes.\n     *\n     * @param generator Generator function that transforms each row to produce 1 or more new columns.\n     * Or use a column spec that has fields for each column, the fields specify a generate function that produces the value for each new column.\n     * \n     * @return Returns a new dataframe with 1 or more new columns.\n     * \n     * @example\n     * <pre>\n     * \n     * function produceNewColumns (inputRow) {\n     *      const newColumns = {\n     *          // ... specify new columns and their values based on the input row ...\n     *      };\n     * \n     *      return newColumns;\n     * };\n     * \n     * const dfWithNewSeries = df.generateSeries(row => produceNewColumns(row));\n     * </pre>\n     * \n     * @example\n     * <pre>\n     * \n     * const dfWithNewSeries = df.generateSeries({ \n     *      NewColumnA: row => produceNewColumnA(row),\n     *      NewColumnB: row => produceNewColumnB(row),\n     * })\n     * </pre>\n     */\n    generateSeries<NewValueT = ValueT> (generator: SelectorWithIndexFn<any, any> | IColumnTransformSpec): IDataFrame<IndexT, NewValueT>;\n\n    /** \n     * Converts (deflates) a dataframe to a {@link Series}.\n     *\n     * @param [selector] Optional user-defined selector function that transforms each row to produce the series.\n     *\n     * @return Returns a series that was created from the original dataframe.\n     * \n     * @example\n     * <pre>\n     * \n     * const series = df.deflate(); // Deflate to a series of object.\n     * </pre>\n     * \n     * @example\n     * <pre>\n     * \n     * const series = df.deflate(row => row.SomeColumn); // Extract a particular column.\n     * </pre>\n     */\n    deflate<ToT = ValueT> (selector?: SelectorWithIndexFn<ValueT, ToT>): ISeries<IndexT, ToT>;\n\n    /** \n     * Inflate a named {@link Series} in the dataframe to 1 or more new series in the new dataframe.\n     * \n     * This is the equivalent of extracting the series using {@link getSeries}, transforming them with {@link Series.select}\n     * and then running {@link Series.inflate} to create a new dataframe, then merging each column of the new dataframe\n     *  into the original dataframe using {@link withSeries}.\n     *\n     * @param columnName Name of the series to inflate.\n     * @param [selector] Optional selector function that transforms each value in the column to new columns. If not specified it is expected that each value in the column is an object whose fields define the new column names.\n     * \n     * @return Returns a new dataframe with a column inflated to 1 or more new columns.\n     * \n     * @example\n     * <pre>\n     * \n     * function newColumnGenerator (row) {\n     *      const newColumns = {\n     *          // ... create 1 field per new column ...\n     *      };\n     * \n     *      return row;\n     * }\n     * \n     * const dfWithNewSeries = df.inflateSeries(\"SomeColumn\", newColumnGenerator);\n     * </pre>\n     */\n    inflateSeries<NewValueT = ValueT> (columnName: string, selector?: SelectorWithIndexFn<IndexT, any>): IDataFrame<IndexT, ValueT>;\n\n    /**\n     * Partition a dataframe into a {@link Series} of *data windows*. \n     * Each value in the new series is a chunk of data from the original dataframe.\n     *\n     * @param period The number of rows to include in each data window.\n     * \n     * @return Returns a new series, each value of which is a chunk (data window) of the original dataframe.\n     * \n     * @example\n     * <pre>\n     * \n     * const windows = df.window(2); // Get rows in pairs.\n     * const pctIncrease = windows.select(pair => (pair.last().SalesAmount - pair.first().SalesAmount) / pair.first().SalesAmount);\n     * console.log(pctIncrease.toString());\n     * </pre>\n     * \n     * @example\n     * <pre>\n     * \n     * const salesDf = ... // Daily sales data.\n     * const weeklySales = salesDf.window(7); // Partition up into weekly data sets.\n     * console.log(weeklySales.toString());\n     * </pre>\n     */\n    window (period: number): ISeries<number, IDataFrame<IndexT, ValueT>>;\n\n    /** \n     * Partition a dataframe into a {@link Series} of *rolling data windows*. \n     * Each value in the new series is a rolling chunk of data from the original dataframe.\n     *\n     * @param period The number of data rows to include in each data window.\n     * \n     * @return Returns a new series, each value of which is a rolling chunk of the original dataframe.\n     * \n     * @example\n     * <pre>\n     * \n     * const salesDf = ... // Daily sales data.\n     * const rollingWeeklySales = salesDf.rollingWindow(7); // Get rolling window over weekly sales data.\n     * console.log(rollingWeeklySales.toString());\n     * </pre>\n     */\n    rollingWindow (period: number): ISeries<number, IDataFrame<IndexT, ValueT>>;\n\n    /**\n     * Partition a dataframe into a {@link Series} of variable-length *data windows* \n     * where the divisions between the data chunks are\n     * defined by a user-provided *comparer* function.\n     * \n     * @param comparer Function that compares two adjacent data rows and returns true if they should be in the same window.\n     * \n     * @return Returns a new series, each value of which is a chunk of data from the original dataframe.\n     * \n     * @example\n     * <pre>\n     * \n     * function rowComparer (rowA, rowB) {\n     *      if (... rowA should be in the same data window as rowB ...) {\n     *          return true;\n     *      }\n     *      else {\n     *          return false;\n     *      }\n     * };\n     * \n     * const variableWindows = df.variableWindow(rowComparer);\n     */\n    variableWindow (comparer: ComparerFn<ValueT, ValueT>): ISeries<number, IDataFrame<IndexT, ValueT>>;\n\n    /**\n     * Eliminates adjacent duplicate rows.\n     * \n     * For each group of adjacent values that are equivalent only returns the last index/row for the group, \n     * thus ajacent equivalent rows are collapsed down to the last row.\n     *\n     * @param [selector] Optional selector function to determine the value used to compare for equivalence.\n     * \n     * @return Returns a new dataframe with groups of adjacent duplicate rows collapsed to a single row per group.\n     * \n     * @example\n     * <pre>\n     * \n     * const dfWithDuplicateRowsRemoved = df.sequentialDistinct(row => row.ColumnA);\n     * </pre>\n     */\n    sequentialDistinct<ToT = ValueT> (selector?: SelectorFn<ValueT, ToT>): IDataFrame<IndexT, ValueT>;\n\n    /**\n     * Aggregate the rows in the dataframe to a single result.\n     *\n     * @param [seed] Optional seed value for producing the aggregation.\n     * @param selector Function that takes the seed and then each row in the dataframe and produces the aggregate value.\n     * \n     * @return Returns a new value that has been aggregated from the dataframe using the 'selector' function. \n     * \n     * @example\n     * <pre>\n     * \n     * const dailySalesDf = ... daily sales figures for the past month ...\n     * const totalSalesForthisMonth = dailySalesDf.aggregate(\n     *      0, // Seed - the starting value.\n     *      (accumulator, row) => accumulator + row.SalesAmount // Aggregation function.\n     * );\n     * </pre>\n     * \n     * @example\n     * <pre>\n     * \n     * const totalSalesAllTime = 500; // We'll seed the aggregation with this value.\n     * const dailySalesDf = ... daily sales figures for the past month ...\n     * const updatedTotalSalesAllTime = dailySalesDf.aggregate(\n     *      totalSalesAllTime, \n     *      (accumulator, row) => accumulator + row.SalesAmount\n     * );\n     * </pre>\n     * \n     * @example\n     * <pre>\n     * \n     * var salesDataSummary = salesDataDf.aggregate({\n     *      TotalSales: df => df.count(),\n     *      AveragePrice: df => df.deflate(row => row.Price).average(),\n     *      TotalRevenue: df => df.deflate(row => row.Revenue).sum(), \n     * });\n     * </pre>\n    */\n   aggregate<ToT = ValueT> (seedOrSelector: AggregateFn<ValueT, ToT> | ToT | IColumnAggregateSpec, selector?: AggregateFn<ValueT, ToT>): ToT;\n    \n    /**\n     * Skip a number of rows in the dataframe.\n     *\n     * @param numValues Number of rows to skip.\n     * \n     * @return Returns a new dataframe with the specified number of rows skipped. \n     * \n     * @example\n     * <pre>\n     * \n     * const dfWithRowsSkipped = df.skip(10); // Skip 10 rows in the original dataframe.\n     * </pre>\n     */\n    skip (numValues: number): IDataFrame<IndexT, ValueT>;\n\n    /**\n     * Skips values in the dataframe while a condition evaluates to true or truthy.\n     *\n     * @param predicate Returns true/truthy to continue to skip rows in the original dataframe.\n     * \n     * @return Returns a new dataframe with all initial sequential rows removed while the predicate returned true/truthy.\n     * \n     * @example\n     * <pre>\n     * \n     * const dfWithRowsSkipped = df.skipWhile(row => row.CustomerName === \"Fred\"); // Skip initial customers named Fred.\n     * </pre>\n     */\n    skipWhile (predicate: PredicateFn<ValueT>): IDataFrame<IndexT, ValueT>;\n\n    /**\n     * Skips values in the dataframe untils a condition evaluates to true or truthy.\n     *\n     * @param predicate Return true/truthy to stop skipping rows in the original dataframe.\n     * \n     * @return Returns a new dataframe with all initial sequential rows removed until the predicate returned true/truthy.\n     * \n     * @example\n     * <pre>\n     * \n     * const dfWithRowsSkipped = df.skipUntil(row => row.CustomerName === \"Fred\"); // Skip initial customers until we find Fred.\n     * </pre>\n     */\n    skipUntil (predicate: PredicateFn<ValueT>): IDataFrame<IndexT, ValueT>;\n\n    /**\n     * Take a number of rows in the dataframe.\n     *\n     * @param numValues Number of rows to take.\n     * \n     * @return Returns a new dataframe with only the specified number of rows taken from the original dataframe.\n     * \n     * @example\n     * <pre>\n     * \n     * const dfWithRowsTaken = df.take(15); // Take only the first 15 rows from the original dataframe.\n     * </pre>\n     */\n    take (numRows: number): IDataFrame<IndexT, ValueT>;\n\n    /**\n     * Takes values from the dataframe while a condition evaluates to true or truthy.\n     *\n     * @param predicate Returns true/truthy to continue to take rows from the original dataframe.\n     * \n     * @return Returns a new dataframe with only the initial sequential rows that were taken while the predicate returned true/truthy.\n     * \n     * @example\n     * <pre>\n     * \n     * const dfWithRowsTaken = df.takeWhile(row => row.CustomerName === \"Fred\"); // Take only initial customers named Fred.\n     * </pre>\n     */\n    takeWhile (predicate: PredicateFn<ValueT>): IDataFrame<IndexT, ValueT>;\n\n    /**\n     * Takes values from the dataframe untils a condition evaluates to true or truthy.\n     *\n     * @param predicate Return true/truthy to stop taking rows in the original dataframe.\n     * \n     * @return Returns a new dataframe with only the initial sequential rows taken until the predicate returned true/truthy.\n     * \n     * @example\n     * <pre>\n     * \n     * const dfWithRowsTaken = df.takeUntil(row => row.CustomerName === \"Fred\"); // Take all initial customers until we find Fred.\n     * </pre>\n     */\n    takeUntil (predicate: PredicateFn<ValueT>): IDataFrame<IndexT, ValueT>;\n\n    /**\n     * Count the number of rows in the dataframe\n     *\n     * @return Returns the count of all rows.\n     * \n     * @example\n     * <pre>\n     * \n     * const numRows = df.count();\n     * </pre>\n     */\n    count (): number;\n\n    /**\n     * Get the first row of the dataframe.\n     *\n     * @return Returns the first row of the dataframe.\n     * \n     * @example\n     * <pre>\n     * \n     * const firstRow = df.first();\n     * </pre>\n     */\n    first (): ValueT;\n\n    /**\n     * Get the last row of the dataframe.\n     *\n     * @return Returns the last row of the dataframe.\n     * \n     * @example\n     * <pre>\n     * \n     * const lastRow = df.last();\n     * </pre>\n     */\n    last (): ValueT;\n    \n    /**\n     * Get the row, if there is one, with the specified index.\n     *\n     * @param index Index to for which to retreive the row.\n     *\n     * @return Returns the row from the specified index in the dataframe or undefined if there is no such index in the present in the dataframe.\n     * \n     * @example\n     * <pre>\n     * \n     * const row = df.at(5); // Get the row at index 5 (with a default 0-based index).\n     * </pre>\n     * \n     * @example\n     * <pre>\n     * \n     * const date = ... some date ...\n     * // Retreive the row with specified date from a time-series dataframe (assuming date indexed has been applied).\n     * const row = df.at(date); \n     * </pre>\n     */\n    at (index: IndexT): ValueT | undefined;\n    \n    /** \n     * Get X rows from the start of the dataframe.\n     * Pass in a negative value to get all rows at the head except for X rows at the tail.\n     *\n     * @param numValues Number of rows to take.\n     * \n     * @return Returns a new dataframe that has only the specified number of rows taken from the start of the original dataframe.  \n     * \n     * @examples\n     * <pre>\n     * \n     * const sample = df.head(10); // Take a sample of 10 rows from the start of the dataframe.\n     * </pre>\n     */\n    head (numValues: number): IDataFrame<IndexT, ValueT>;\n\n    /** \n     * Get X rows from the end of the dataframe.\n     * Pass in a negative value to get all rows at the tail except X rows at the head.\n     *\n     * @param numValues Number of rows to take.\n     * \n     * @return Returns a new dataframe that has only the specified number of rows taken from the end of the original dataframe.  \n     * \n     * @examples\n     * <pre>\n     * \n     * const sample = df.tail(12); // Take a sample of 12 rows from the end of the dataframe.\n     * </pre>\n     */\n    tail (numValues: number): IDataFrame<IndexT, ValueT>;\n\n    /**\n     * Filter the dataframe using user-defined predicate function.\n     *\n     * @param predicate Predicte function to filter rows from the dataframe. Returns true/truthy to keep rows, or false/falsy to omit rows.\n     * \n     * @return Returns a new dataframe containing only the rows from the original dataframe that matched the predicate. \n     * \n     * @example\n     * <pre>\n     * \n     * const filteredDf = df.where(row => row.CustomerName === \"Fred\"); // Filter so we only have customers named Fred.\n     * </pre>\n     */\n    where (predicate: PredicateFn<ValueT>): IDataFrame<IndexT, ValueT>;\n\n    /**\n     * Invoke a callback function for each roew in the dataframe.\n     *\n     * @param callback The calback function to invoke for each row.\n     * \n     * @return Returns the original dataframe with no modifications.\n     * \n     * @example\n     * <pre>\n     * \n     * df.forEach(row => {\n     *      // ... do something with the row ...\n     * });\n     * </pre>\n     */\n    forEach (callback: CallbackFn<ValueT>): IDataFrame<IndexT, ValueT>;\n\n    /**\n     * Evaluates a predicate function for every row in the dataframe to determine \n     * if some condition is true/truthy for **all** rows in the dataframe.\n     * \n     * @param predicate Predicate function that receives each row. It should returns true/truthy for a match, otherwise false/falsy.\n     *\n     * @return Returns true if the predicate has returned true or truthy for every row in the dataframe, otherwise returns false. Returns false for an empty dataframe. \n     * \n     * @example\n     * <pre>\n     * \n     * const everyoneIsNamedFred = df.all(row => row.CustomerName === \"Fred\"); // Check if all customers are named Fred.\n     * </pre>\n     */\n    all (predicate: PredicateFn<ValueT>): boolean;\n\n    /**\n     * Evaluates a predicate function for every row in the dataframe to determine \n     * if some condition is true/truthy for **any** of rows in the dataframe.\n     * \n     * If no predicate is specified then it simply checks if the dataframe contains more than zero rows.\n     *\n     * @param [predicate] Optional predicate function that receives each row. It should return true/truthy for a match, otherwise false/falsy.\n     *\n     * @return Returns true if the predicate has returned truthy for any row in the sequence, otherwise returns false. \n     * If no predicate is passed it returns true if the dataframe contains any rows at all. \n     * Returns false for an empty dataframe.\n     * \n     * @example\n     * <pre>\n     * \n     * const anyFreds = df.any(row => row.CustomerName === \"Fred\"); // Do we have any customers named Fred?\n     * </pre>\n     * \n     * @example\n     * <pre>\n     * \n     * const anyCustomers = df.any(); // Do we have any customers at all?\n     * </pre>\n     */\n    any (predicate?: PredicateFn<ValueT>): boolean;\n\n    /**\n     * Evaluates a predicate function for every row in the dataframe to determine \n     * if some condition is true/truthy for **none** of rows in the dataframe.\n     * \n     * If no predicate is specified then it simply checks if the dataframe contains zero rows.\n     *\n     * @param [predicate] Optional predicate function that receives each row. It should return true/truthy for a match, otherwise false/falsy.\n     *\n     * @return Returns true if the predicate has returned truthy for zero rows in the dataframe, otherwise returns false. Returns false for an empty dataframe.\n     * \n     * @example\n     * <pre>\n     * \n     * const noFreds = df.none(row => row.CustomerName === \"Fred\"); // Do we have zero customers named Fred?\n     * </pre>\n     * \n     * @example\n     * <pre>\n     * \n     * const noCustomers = df.none(); // Do we have zero customers?\n     * </pre>\n     */\n    none (predicate?: PredicateFn<ValueT>): boolean;\n\n        /**\n     * Gets a new dataframe containing all rows starting at and after the specified index value.\n     * \n     * @param indexValue The index value at which to start the new dataframe.\n     * \n     * @return Returns a new dataframe containing all rows starting at and after the specified index value. \n     * \n     * @example\n     * <pre>\n     * \n     * const df = new DataFrame({ \n     *      index: [0, 1, 2, 3], // This is the default index.\n     *      values: [10, 20, 30, 40],\n     * });\n     * \n     * const lastHalf = df.startAt(2);\n     * expect(lastHalf.toArray()).to.eql([30, 40]);\n     * </pre>\n     * \n     * @example\n     * <pre>\n     * \n     * const timeSeriesDf = ... a dataframe indexed by date/time ...\n     * \n     * // Get all rows starting at (or after) a particular date.\n     * const allRowsFromStartDate = df.startAt(new Date(2016, 5, 4)); \n     * </pre>\n     */\n    startAt (indexValue: IndexT): IDataFrame<IndexT, ValueT>;\n\n    /**\n     * Gets a new dataframe containing all rows up until and including the specified index value (inclusive).\n     * \n     * @param indexValue The index value at which to end the new dataframe.\n     * \n     * @return Returns a new dataframe containing all rows up until and including the specified index value.\n     * \n     * @example\n     * <pre>\n     * \n     * const df = new DataFrame({ \n     *      index: [0, 1, 2, 3], // This is the default index.\n     *      values: [10, 20, 30, 40],\n     * });\n     * \n     * const firstHalf = df.endAt(1);\n     * expect(firstHalf.toArray()).to.eql([10, 20]);\n     * </pre>\n     * \n     * @example\n     * <pre>\n     * \n     * const timeSeriesDf = ... a dataframe indexed by date/time ...\n     * \n     * // Get all rows ending at a particular date.\n     * const allRowsUpToAndIncludingTheExactEndDate = df.endAt(new Date(2016, 5, 4)); \n     * </pre>\n     */\n    endAt (indexValue: IndexT): IDataFrame<IndexT, ValueT>;\n\n    /**\n     * Gets a new dataframe containing all rows up to the specified index value (exclusive).\n     * \n     * @param indexValue The index value at which to end the new dataframe.\n     * \n     * @return Returns a new dataframe containing all rows up to (but not including) the specified index value. \n     * \n     * @example\n     * <pre>\n     * \n     * const df = new DataFrame({ \n     *      index: [0, 1, 2, 3], // This is the default index.\n     *      values: [10, 20, 30, 40],\n     * });\n     * \n     * const firstHalf = df.before(2);\n     * expect(firstHalf.toArray()).to.eql([10, 20]);\n     * </pre>\n     * \n     * @example\n     * <pre>\n     * \n     * const timeSeriesDf = ... a dataframe indexed by date/time ...\n     * \n     * // Get all rows before the specified date.\n     * const allRowsBeforeEndDate = df.before(new Date(2016, 5, 4)); \n     * </pre>\n     */\n    before (indexValue: IndexT): IDataFrame<IndexT, ValueT>;\n\n    /**\n     * Gets a new dataframe containing all rows after the specified index value (exclusive).\n     * \n     * @param indexValue The index value after which to start the new dataframe.\n     * \n     * @return Returns a new dataframe containing all rows after the specified index value.\n     * \n     * @example\n     * <pre>\n     * \n     * const df = new DataFrame({ \n     *      index: [0, 1, 2, 3], // This is the default index.\n     *      values: [10, 20, 30, 40],\n     * });\n     * \n     * const lastHalf = df.before(1);\n     * expect(lastHalf.toArray()).to.eql([30, 40]);\n     * </pre>\n     * \n     * @example\n     * <pre>\n     * \n     * const timeSeriesDf = ... a dataframe indexed by date/time ...\n     * \n     * // Get all rows after the specified date.\n     * const allRowsAfterStartDate = df.after(new Date(2016, 5, 4)); \n     * </pre>\n     */\n    after (indexValue: IndexT): IDataFrame<IndexT, ValueT>;\n\n    /**\n     * Gets a new dataframe containing all rows between the specified index values (inclusive).\n     * \n     * @param startIndexValue The index at which to start the new dataframe.\n     * @param endIndexValue The index at which to end the new dataframe.\n     * \n     * @return Returns a new dataframe containing all values between the specified index values (inclusive).\n     * \n     * @example\n     * <pre>\n     * \n     * const df = new DataFrame({ \n     *      index: [0, 1, 2, 3, 4, 6], // This is the default index.\n     *      values: [10, 20, 30, 40, 50, 60],\n     * });\n     * \n     * const middleSection = df.between(1, 4);\n     * expect(middleSection.toArray()).to.eql([20, 30, 40, 50]);\n     * </pre>\n     * \n     * @example\n     * <pre>\n     * \n     * const timeSeriesDf = ... a dataframe indexed by date/time ...\n     * \n     * // Get all rows between the start and end dates (inclusive).\n     * const allRowsBetweenDates = df.after(new Date(2016, 5, 4), new Date(2016, 5, 22)); \n     * </pre>\n     */\n    between (startIndexValue: IndexT, endIndexValue: IndexT): IDataFrame<IndexT, ValueT>;\n\n    /** \n     * Format the dataframe for display as a string.\n     * This forces lazy evaluation to complete.\n     * \n     * @return Generates and returns a string representation of the dataframe or dataframe.\n     * \n     * @example\n     * <pre>\n     * \n     * console.log(df.toString());\n     * </pre>\n     */\n    toString (): string;\n\n    /**\n     * Parse a column with string values and convert it to a column with int values.\n     *\n     * @param columnNameOrNames Specifies the column name or array of column names to parse.\n     * \n     * @return Returns a new dataframe with a particular named column parsed as ints.  \n     * \n     * @example\n     * <pre>\n     * \n     * const withParsedColumn = df.parseInts(\"MyIntColumn\");\n     * </pre>\n     * \n     * @example\n     * <pre>\n     * \n     * const withParsedColumns = df.parseInts([\"MyIntColumnA\", \"MyIntColumnA\"]);\n     * </pre>\n     */\n    parseInts (columnNameOrNames: string | string[]): IDataFrame<IndexT, ValueT>;\n\n    /**\n     * Parse a column with string values and convert it to a column with float values.\n     *\n     * @param columnNameOrNames Specifies the column name or array of column names to parse.\n     * \n     * @return  Returns a new dataframe with a particular named column parsed as floats.  \n     * \n     * @example\n     * <pre>\n     * \n     * const withParsedColumn = df.parseFloats(\"MyFloatColumn\");\n     * </pre>\n     * \n     * @example\n     * <pre>\n     * \n     * const withParsedColumns = df.parseFloats([\"MyFloatColumnA\", \"MyFloatColumnA\"]);\n     * </pre>\n     */\n    parseFloats (columnNameOrNames: string | string[]): IDataFrame<IndexT, ValueT>;\n\n    /**\n     * Parse a column with string values and convert it to a column with date values.\n     *\n     * @param columnNameOrNames -Specifies the column name or array of column names to parse.\n     * @param [formatString] Optional formatting string for dates.\n     * \n     * @return Returns a new dataframe with a particular named column parsed as dates.\n     * \n     * @example\n     * <pre>\n     * \n     * const withParsedColumn = df.parseDates(\"MyDateColumn\");\n     * </pre>\n     * \n     * @example\n     * <pre>\n     * \n     * const withParsedColumns = df.parseDates([\"MyDateColumnA\", \"MyDateColumnA\"]);\n     * </pre>\n     */\n    parseDates (columnNameOrNames: string | string[], formatString?: string): IDataFrame<IndexT, ValueT>;\n\n    /**\n     * Convert a column of values of different types to a column of string values.\n     *\n     * @param columnNames Specifies the column name or array of column names to convert to strings. Can also be a format spec that specifies which columns to convert and what their format should be. \n     * @param [formatString] Optional formatting string for dates.\n     * \n     * Numeral.js is used for number formatting.\n     * http://numeraljs.com/\n     * \n     * Moment is used for date formatting.\n     * https://momentjs.com/docs/#/parsing/string-format/\n     * \n     * @return Returns a new dataframe with a particular named column convert to strings.\n     * \n     * @example\n     * <pre>\n     * \n     * const withStringColumn = df.toStrings(\"MyDateColumn\", \"YYYY-MM-DD\");\n     * </pre>\n     * \n     * @example\n     * <pre>\n     * \n     * const withStringColumn = df.toStrings(\"MyFloatColumn\", \"0.00\");\n     * </pre>\n     */\n    toStrings (columnNames: string | string[] | IFormatSpec, formatString?: string): IDataFrame<IndexT, ValueT>;    \n\n    /**\n     * Produces a new dataframe with all string values truncated to the requested maximum length.\n     *\n     * @param maxLength The maximum length of the string values after truncation.\n     * \n     * @return Returns a new dataframe with all strings truncated to the specified maximum length.\n     * \n     * @example\n     * <pre>\n     * \n     * // Truncate all string columns to 100 characters maximum.\n     * const truncatedDf = df.truncateString(100);\n     * </pre>\n     */\n    truncateStrings (maxLength: number): IDataFrame<IndexT, ValueT>;\n\n    /**\n     * Forces lazy evaluation to complete and 'bakes' the dataframe into memory.\n     * \n     * @return Returns a dataframe that has been 'baked', all lazy evaluation has completed.  \n     * \n     * @example\n     * <pre>\n     * \n     * const bakedDf = df.bake();\n     * </pre>\n     */\n    bake (): IDataFrame<IndexT, ValueT>;\n\n    /** \n     * Gets a new dataframe in reverse order.\n     * \n     * @return Returns a new dataframe that is the reverse of the original.\n     * \n     * @example\n     * <pre>\n     * \n     * const reversed = df.reverse();\n     * </pre>\n     */\n    reverse (): IDataFrame<IndexT, ValueT>;\n\n    /**\n     * Returns only the set of rows in the dataframe that are distinct according to some criteria.\n     * This can be used to remove duplicate rows from the dataframe.\n     *\n     * @param selector User-defined selector function that specifies the criteria used to make comparisons for duplicate rows.\n     * \n     * @return Returns a dataframe containing only unique values as determined by the 'selector' function. \n     * \n     * @example\n     * <pre>\n     * \n     * // Remove duplicate rows by customer id. Will return only a single row per customer.\n     * const distinctCustomers = salesDf.distinct(sale => sale.CustomerId);\n     * </pre>\n     */\n    distinct<ToT> (selector?: SelectorFn<ValueT, ToT>): IDataFrame<IndexT, ValueT>;\n\n    /**\n     * Collects rows in the dataframe into a {@link Series} of groups according to a user-defined selector function.\n     *\n     * @param selector User-defined selector function that specifies the criteriay to group by.\n     *\n     * @return Returns a {@link Series} of groups. Each group is a dataframe with rows that have been grouped by the 'selector' function.\n     * \n     * @example\n     * <pre>\n     * \n     * const salesDf = ... product sales ...\n     * const salesByProduct = salesDf.groupBy(sale => sale.ProductId);\n     * for (const productSalesGroup of salesByProduct) {\n     *      // ... do something with each product group ...\n     *      const productId = productSalesGroup.first().ProductId;\n     *      const totalSalesForProduct = productSalesGroup.deflate(sale => sale.Amount).sum();\n     *      console.log(totalSalesForProduct);\n     * }\n     * </pre>\n     */\n    groupBy<GroupT> (selector: SelectorWithIndexFn<ValueT, GroupT>): ISeries<number, IDataFrame<IndexT, ValueT>>;\n    \n    /**\n     * Collects values in the series into a new series of groups based on if the values are the same or according to a user-defined selector function.\n     *\n     * @param [selector] Optional selector that specifies the criteria for grouping.\n     *\n     * @return Returns a {@link Series} of groups. Each group is a dataframe with rows that are the same or have been grouped by the 'selector' function.\n     * \n     * @example\n     * <pre>\n     * \n     * // Some ultra simple stock trading strategy backtesting...\n     * const dailyStockPriceDf = ... daily stock price for a company ...\n     * const priceGroups  = dailyStockPriceDf.groupBy(day => day.close > day.movingAverage);\n     * for (const priceGroup of priceGroups) {\n     *      // ... do something with each stock price group ...\n     * \n     *      const firstDay = priceGroup.first();\n     *      if (firstDay.close > movingAverage) {\n     *          // This group of days has the stock price above its moving average.\n     *          // ... maybe enter a long trade here ...\n     *      }\n     *      else {\n     *          // This group of days has the stock price below its moving average.\n     *          // ... maybe enter a short trade here ...\n     *      }\n     * }\n     * </pre>\n     */\n    groupSequentialBy<GroupT> (selector?: SelectorFn<ValueT, GroupT>): ISeries<number, IDataFrame<IndexT, ValueT>>;\n    \n    /**\n     * Concatenate multiple other dataframes onto this dataframe.\n     * \n     * @param dataframes Multiple arguments. Each can be either a dataframe or an array of dataframes.\n     * \n     * @return Returns a single dataframe concatenated from multiple input dataframes. \n     * \n     * @example\n     * <pre>\n     * \n     * const concatenated = a.concat(b);\n     * </pre>\n     * \n     * @example\n     * <pre>\n     * \n     * const concatenated = a.concat(b, c);\n     * </pre>\n     * \n     * @example\n     * <pre>\n     * \n     * const concatenated = a.concat([b, c]);\n     * </pre>\n     * \n     * @example\n     * <pre>\n     * \n     * const concatenated = a.concat(b, [c, d]);\n     * </pre>\n     * \n     * @example\n     * <pre>\n     * \n     * const otherDfs = [... array of dataframes...];\n     * const concatenated = a.concat(otherDfs);\n     * </pre>\n     */    \n    concat (...dataframes: (IDataFrame<IndexT, ValueT>[] | IDataFrame<IndexT, ValueT>)[]): IDataFrame<IndexT, ValueT>;\n    \n    /**\n    * Merge together multiple dataframes to create a new dataframe.\n    * Preserves the index of the first dataframe.\n    * \n    * @param s2, s3, s4, s4 Multiple dataframes to zip.\n    * @param zipper User-defined zipper function that merges rows. It produces rows for the new dataframe based-on rows from the input dataframes.\n    * \n    * @return Returns a single dataframe merged from multiple input dataframes. \n    * \n    * @example\n    * <pre>\n    * \n    * function produceNewRow (rowA, rowB) {\n    *       const outputRow = {\n    *           ValueA: rowA.Value,\n    *           ValueB: rowB.Value,\n    *       };\n    *       return outputRow;\n    * }\n    * \n    * const dfA = new DataFrame([ { Value: 10 }, { Value: 20 }, { Value: 30 }]);\n    * const dfB = new DataFrame([ { Value: 100 }, { Value: 200 }, { Value: 300 }]);\n    * const zippedDf = dfA.zip(dfB, produceNewRow);\n    * </pre>\n    */    \n    zip<Index2T, Value2T, ResultT>  (s2: IDataFrame<Index2T, Value2T>, zipper: Zip2Fn<ValueT, Value2T, ResultT> ): IDataFrame<IndexT, ResultT>;\n    zip<Index2T, Value2T, Index3T, Value3T, ResultT>  (s2: IDataFrame<Index2T, Value2T>, s3: IDataFrame<Index3T, Value3T>, zipper: Zip3Fn<ValueT, Value2T, Value3T, ResultT> ): IDataFrame<IndexT, ResultT>;\n    zip<Index2T, Value2T, Index3T, Value3T, Index4T, Value4T, ResultT>  (s2: IDataFrame<Index2T, Value2T>, s3: IDataFrame<Index3T, Value3T>, s4: IDataFrame<Index4T, Value4T>, zipper: Zip3Fn<ValueT, Value2T, Value3T, ResultT> ): IDataFrame<IndexT, ResultT>;\n    zip<ResultT>  (...args: any[]): IDataFrame<IndexT, ResultT>;\n\n    /**\n     * Sorts the dataframe in ascending order by a value defined by the user-defined selector function. \n     * \n     * @param selector User-defined selector function that selects the value to sort by.\n     * \n     * @return Returns a new dataframe that has been ordered accorrding to the value chosen by the selector function. \n     * \n     * @example\n     * <pre>\n     * \n     * // Order sales by amount from least to most.\n     * const orderedDf = salesDf.orderBy(sale => sale.Amount); \n     * </pre>\n     */\n    orderBy<SortT> (selector: SelectorWithIndexFn<ValueT, SortT>): IOrderedDataFrame<IndexT, ValueT, SortT>;\n\n    /**\n     * Sorts the dataframe in descending order by a value defined by the user-defined selector function. \n     * \n     * @param selector User-defined selector function that selects the value to sort by.\n     * \n     * @return Returns a new dataframe that has been ordered accorrding to the value chosen by the selector function. \n     * \n     * @example\n     * <pre>\n     * \n     * // Order sales by amount from most to least\n     * const orderedDf = salesDf.orderByDescending(sale => sale.Amount); \n     * </pre>\n     */\n    orderByDescending<SortT> (selector: SelectorWithIndexFn<ValueT, SortT>): IOrderedDataFrame<IndexT, ValueT, SortT>;\n        \n    /**\n     * Creates a new dataframe by merging two input dataframes.\n     * The resulting dataframe contains the union of rows from the two input dataframes.\n     * These are the unique combination of rows in both dataframe.\n     * This is basically a concatenation and then elimination of duplicates.\n     *\n     * @param other The other dataframes to merge.\n     * @param [selector] Optional user-defined selector function that selects the value to compare to determine distinctness.\n     * \n     * @return Returns the union of the two dataframes.\n     * \n     * @example\n     * <pre>\n     *\n     * const dfA = ...\n     * const dfB = ...\n     * const merged = dfA.union(dfB);\n     * </pre>\n     * \n     * @example\n     * <pre>\n     *\n     * // Merge two sets of customer records that may contain the same\n     * // customer record in each set. This is basically a concatenation\n     * // of the dataframes and then an elimination of any duplicate records\n     * // that result.\n     * const customerRecordsA = ...\n     * const customerRecordsB = ...\n     * const mergedCustomerRecords = customerRecordsA.union(\n     *      customerRecordsB, \n     *      customerRecord => customerRecord.CustomerId\n     * );\n     * </pre>\n     * \n     * \n     * @example\n     * <pre>\n     *\n     * // Note that you can achieve the exact same result as the previous\n     * // example by doing a {@link DataFrame.concat) and {@link DataFrame.distinct}\n     * // of the dataframes and then an elimination of any duplicate records\n     * // that result.\n     * const customerRecordsA = ...\n     * const customerRecordsB = ...\n     * const mergedCustomerRecords = customerRecordsA\n     *      .concat(customerRecordsB)\n     *      .distinct(customerRecord => customerRecord.CustomerId);\n     * </pre>\n     * \n     */\n    union<KeyT = ValueT> (\n        other: IDataFrame<IndexT, ValueT>, \n        selector?: SelectorFn<ValueT, KeyT>): \n            IDataFrame<IndexT, ValueT>;\n\n    /**\n     * Creates a new dataframe by merging two input dataframes.\n     * The resulting dataframe contains the intersection of rows from the two input dataframes.\n     * These are only the rows that appear in both dataframes.\n     *\n     * @param inner The inner dataframe to merge (the dataframe you call the function on is the 'outer' dataframe).\n     * @param [outerSelector] Optional user-defined selector function that selects the key from the outer dataframe that is used to match the two dataframes.\n     * @param [innerSelector] Optional user-defined selector function that selects the key from the inner dataframe that is used to match the two dataframes.\n     * \n     * @return Returns a new dataframe that contains the intersection of rows from the two input dataframes.\n     * \n     * @example\n     * <pre>\n     * \n     * const dfA = ...\n     * const dfB = ...\n     * const mergedDf = dfA.intersection(dfB);\n     * </pre>\n     * \n     * @example\n     * <pre>\n     *\n     * // Merge two sets of customer records to find only the\n     * // customers that appears in both.\n     * const customerRecordsA = ...\n     * const customerRecordsB = ...\n     * const intersectionOfCustomerRecords = customerRecordsA.intersection(\n     *      customerRecordsB, \n     *      customerRecord => customerRecord.CustomerId\n     * );\n     * </pre>     \n     * */\n    intersection<InnerIndexT = IndexT, InnerValueT = ValueT, KeyT = ValueT> (\n        inner: IDataFrame<InnerIndexT, InnerValueT>, \n        outerSelector?: SelectorFn<ValueT, KeyT>,\n        innerSelector?: SelectorFn<InnerValueT, KeyT>): \n            IDataFrame<IndexT, ValueT>;\n    \n    /**\n     * Creates a new dataframe by merging two input dataframes.\n     * The resulting dataframe contains only the rows from the 1st dataframe that don't appear in the 2nd dataframe.\n     * This is essentially subtracting the rows from the 2nd dataframe from the 1st and creating a new dataframe with the remaining rows.\n     *\n     * @param inner The inner dataframe to merge (the dataframe you call the function on is the 'outer' dataframe).\n     * @param [outerSelector] Optional user-defined selector function that selects the key from the outer dataframe that is used to match the two dataframes.\n     * @param [innerSelector] Optional user-defined selector function that selects the key from the inner dataframe that is used to match the two dataframes.\n     * \n     * @return Returns a new dataframe that contains only the rows from the 1st dataframe that don't appear in the 2nd dataframe.\n     * \n     * @example\n     * <pre>\n     * \n     * const dfA = ...\n     * const dfB = ...\n     * const remainingDf = dfA.except(dfB);\n     * </pre>\n     * \n     * @example\n     * <pre>\n     *\n     * // Find the list of customers haven't bought anything recently.\n     * const allCustomers = ... list of all customers ...\n     * const recentCustomers = ... list of customers who have purchased recently ...\n     * const remainingCustomers = allCustomers.except(\n     *      recentCustomers, \n     *      customerRecord => customerRecord.CustomerId\n     * );\n     * </pre>\n     */\n    except<InnerIndexT = IndexT, InnerValueT = ValueT, KeyT = ValueT> (\n        inner: IDataFrame<InnerIndexT, InnerValueT>, \n        outerSelector?: SelectorFn<ValueT, KeyT>,\n        innerSelector?: SelectorFn<InnerValueT, KeyT>): \n            IDataFrame<IndexT, ValueT>;\n\n   /**\n     * Creates a new dataframe by merging two input dataframes.\n     * The resulting dataframe contains only those rows that have matching keys in both input dataframes.\n     *\n     * @param inner The 'inner' dataframe to join (the dataframe you are callling the function on is the 'outer' dataframe).\n     * @param outerKeySelector User-defined selector function that chooses the join key from the outer dataframe.\n     * @param innerKeySelector User-defined selector function that chooses the join key from the inner dataframe.\n     * @param resultSelector User-defined function that merges outer and inner values.\n     * \n     * @return Returns the new merged dataframe.\n     * \n     * @example\n     * <pre>\n     * \n     * // Join together two sets of customers to find those\n     * // that have bought both product A and product B.\n     * const customerWhoBoughtProductA = ...\n     * const customerWhoBoughtProductB = ...\n     * const customersWhoBoughtBothProductsDf = customerWhoBoughtProductA.join(\n     *          customerWhoBoughtProductB,\n     *          customerA => customerA.CustomerId, // Join key.\n     *          customerB => customerB.CustomerId, // Join key.\n     *          (customerA, customerB) => {\n     *              return {\n     *                  // ... merge the results ...\n     *              };\n     *          }\n     *      );\n     * </pre>\n     */\n    join<KeyT, InnerIndexT, InnerValueT, ResultValueT> (\n        inner: IDataFrame<InnerIndexT, InnerValueT>, \n        outerKeySelector: SelectorFn<ValueT, KeyT>, \n        innerKeySelector: SelectorFn<InnerValueT, KeyT>, \n        resultSelector: JoinFn<ValueT, InnerValueT, ResultValueT>):\n            IDataFrame<number, ResultValueT>;\n\n    /**\n     * Creates a new dataframe by merging two input dataframes.\n     * The resulting dataframe contains only those rows that are only present in or or the other of the dataframes, not both.\n     *\n     * @param inner The 'inner' dataframe to join (the dataframe you are callling the function on is the 'outer' dataframe).\n     * @param outerKeySelector User-defined selector function that chooses the join key from the outer dataframe.\n     * @param innerKeySelector User-defined selector function that chooses the join key from the inner dataframe.\n     * @param resultSelector User-defined function that merges outer and inner values.\n     * \n     * Implementation from here:\n     * \n     * \thttp://blogs.geniuscode.net/RyanDHatch/?p=116\n     * \n     * @return Returns the new merged dataframe.\n     * \n     * @example\n     * <pre>\n     * \n     * // Join together two sets of customers to find those\n     * // that have bought either product A or product B, not not both.\n     * const customerWhoBoughtProductA = ...\n     * const customerWhoBoughtProductB = ...\n     * const customersWhoBoughtEitherProductButNotBothDf = customerWhoBoughtProductA.joinOuter(\n     *          customerWhoBoughtProductB,\n     *          customerA => customerA.CustomerId, // Join key.\n     *          customerB => customerB.CustomerId, // Join key.\n     *          (customerA, customerB) => {\n     *              return {\n     *                  // ... merge the results ...\n     *              };\n     *          }\n     *      );\n     * </pre>\n     */\n    joinOuter<KeyT, InnerIndexT, InnerValueT, ResultValueT> (\n        inner: IDataFrame<InnerIndexT, InnerValueT>, \n        outerKeySelector: SelectorFn<ValueT, KeyT>, \n        innerKeySelector: SelectorFn<InnerValueT, KeyT>, \n        resultSelector: JoinFn<ValueT | null, InnerValueT | null, ResultValueT>):\n            IDataFrame<number, ResultValueT>;\n    \n    /**\n     * Creates a new dataframe by merging two input dataframes.\n     * The resulting dataframe contains only those rows that are present either in both dataframes or only in the outer (left) dataframe.\n     * \n     * @param inner The 'inner' dataframe to join (the dataframe you are callling the function on is the 'outer' dataframe).\n     * @param outerKeySelector User-defined selector function that chooses the join key from the outer dataframe.\n     * @param innerKeySelector User-defined selector function that chooses the join key from the inner dataframe.\n     * @param resultSelector User-defined function that merges outer and inner values.\n     * \n     * Implementation from here:\n     * \n     * \thttp://blogs.geniuscode.net/RyanDHatch/?p=116\n     * \n     * @return Returns the new merged dataframe.\n     * \n     * @example\n     * <pre>\n     * \n     * // Join together two sets of customers to find those\n     * // that have bought either just product A or both product A and product B.\n     * const customerWhoBoughtProductA = ...\n     * const customerWhoBoughtProductB = ...\n     * const boughtJustAorAandB = customerWhoBoughtProductA.joinOuterLeft(\n     *          customerWhoBoughtProductB,\n     *          customerA => customerA.CustomerId, // Join key.\n     *          customerB => customerB.CustomerId, // Join key.\n     *          (customerA, customerB) => {\n     *              return {\n     *                  // ... merge the results ...\n     *              };\n     *          }\n     *      );\n     * </pre>\n     */\n    joinOuterLeft<KeyT, InnerIndexT, InnerValueT, ResultValueT> (\n        inner: IDataFrame<InnerIndexT, InnerValueT>, \n        outerKeySelector: SelectorFn<ValueT, KeyT>, \n        innerKeySelector: SelectorFn<InnerValueT, KeyT>, \n        resultSelector: JoinFn<ValueT | null, InnerValueT | null, ResultValueT>):\n            IDataFrame<number, ResultValueT>;\n\n    /**\n     * Creates a new dataframe by merging two input dataframes.\n     * The resulting dataframe contains only those rows that are present either in both dataframes or only in the inner (right) dataframe.\n     *\n     * @param inner The 'inner' dataframe to join (the dataframe you are callling the function on is the 'outer' dataframe).\n     * @param outerKeySelector User-defined selector function that chooses the join key from the outer dataframe.\n     * @param innerKeySelector User-defined selector function that chooses the join key from the inner dataframe.\n     * @param resultSelector User-defined function that merges outer and inner values.\n     * \n     * Implementation from here:\n     * \n     * \thttp://blogs.geniuscode.net/RyanDHatch/?p=116\n     * \n     * @return Returns the new merged dataframe.\n     * \n     * @example\n     * <pre>\n     * \n     * // Join together two sets of customers to find those\n     * // that have bought either just product B or both product A and product B.\n     * const customerWhoBoughtProductA = ...\n     * const customerWhoBoughtProductB = ...\n     * const boughtJustAorAandB = customerWhoBoughtProductA.joinOuterRight(\n     *          customerWhoBoughtProductB,\n     *          customerA => customerA.CustomerId, // Join key.\n     *          customerB => customerB.CustomerId, // Join key.\n     *          (customerA, customerB) => {\n     *              return {\n     *                  // ... merge the results ...\n     *              };\n     *          }\n     *      );\n     * </pre>\n     */\n    joinOuterRight<KeyT, InnerIndexT, InnerValueT, ResultValueT> (\n        inner: IDataFrame<InnerIndexT, InnerValueT>, \n        outerKeySelector: SelectorFn<ValueT, KeyT>, \n        innerKeySelector: SelectorFn<InnerValueT, KeyT>, \n        resultSelector: JoinFn<ValueT | null, InnerValueT | null, ResultValueT>):\n            IDataFrame<number, ResultValueT>;\n\n    /**\n     * Produces a summary of dataframe. A bit like the 'aggregate' function but much simpler.\n     * \n     * @param [spec] Optional parameter that specifies which columns to aggregate and how to aggregate them. Leave this out to produce a default summary of all columns.\n     * \n     * @returns A object with fields that summary the values in the dataframe.\n     * \n     * @example\n     * <pre>\n     * \n     * const summary = df.summarize();\n     * console.log(summary);\n     * </pre>\n     * \n     * @example\n     * <pre>\n     * \n     * const summary = df.summarize({ // Summarize using pre-defined functions.\n     *      Column1: Series.sum,\n     *      Column2: Series.average,\n     *      Column3: Series.count,\n     * });\n     * console.log(summary);\n     * </pre>\n     * \n     * @example\n     * <pre>\n     * \n     * const summary = df.summarize({ // Summarize using custom functions.\n     *      Column1: series => series.sum(),\n     *      Column2: series => series.std(),\n     *      ColumnN: whateverFunctionYouWant,\n     * });\n     * console.log(summary);\n     * </pre>\n     * \n     * @example\n     * <pre>\n     * \n     * const summary = df.summarize({ // Multiple output fields per column.\n     *      Column1: {\n     *          OutputField1: Series.sum,\n     *          OutputField2: Series.average,\n     *      },\n     *      Column2: {\n     *          OutputField3: series => series.sum(),\n     *          OutputFieldN: whateverFunctionYouWant,\n     *      },\n     * });\n     * console.log(summary);\n     * </pre>\n     */\n    summarize<OutputValueT = any> (\n        spec?: IMultiColumnAggregatorSpec\n            ): OutputValueT;\n\n    /**\n     * Reshape (or pivot) a dataframe based on column values.\n     * This is a powerful function that combines grouping, aggregation and sorting.\n     *\n     * @param columnOrColumns Column name whose values make the new DataFrame's columns.\n     * @param valueColumnNameOrSpec Column name or column spec that defines the columns whose values should be aggregated.\n     * @param [aggregator] Optional function used to aggregate pivotted vales. \n     *\n     * @return Returns a new dataframe that has been pivoted based on a particular column's values. \n     * \n     * @example\n     * <pre>\n     * \n     * // Simplest example.\n     * // Group by the values in 'PivotColumn'.\n     * // The column 'ValueColumn' is aggregated for each group and this becomes the \n     * // values in the output column.\n     * const pivottedDf = df.pivot(\"PivotColumn\", \"ValueColumn\", values => values.average());\n     * </pre>\n     * \n     * @example\n     * <pre>\n     * \n     * // Multiple input column example.\n     * // Similar to the previous example except now we are aggregating multiple input columns.\n     * // Each group has the average computed for 'ValueColumnA' and the sum for 'ValueColumnB'.\n     * const pivottedDf = df.pivot(\"PivotColumn\", { \n     *      ValueColumnA: aValues => aValues.average(),\n     *      ValueColumnB:  bValues => bValues.sum(),\n     * });\n     * </pre>\n     * \n     * @example\n     * <pre>\n     * \n     * // Multiple output column example.\n     * // Similar to the previous example except now we are aggregating multiple outputs for each input column.\n     * // This example produces an output dataframe with columns OutputColumnA, B, C and D.\n     * // OutputColumnA/B are the sum and average of ValueColumnA across each group as defined by PivotColumn.\n     * // OutputColumnC/D are the sum and average of ValueColumnB across each group as defined by PivotColumn.\n     * const pivottedDf = df.pivot(\"PivotColumn\", { \n     *      ValueColumnA: {\n     *          OutputColumnA: aValues => aValues.sum(),\n     *          OutputColumnB: aValues => aValues.average(),\n     *      },\n     *      ValueColumnB: {\n     *          OutputColumnC: bValues => aValues.sum(),\n     *          OutputColumnD: bValues => aValues.average(),\n     *      },\n     * });\n     * </pre>\n     * \n     * @example\n     * <pre>\n     * \n     * // Full multi-column example.\n     * // Similar to the previous example, but now we are pivotting on multiple columns.\n     * // We now group by 'PivotColumnA' and then by 'PivotColumnB', effectively creating a \n     * // multi-level nested group.\n     * const pivottedDf = df.pivot([\"PivotColumnA\", \"PivotColumnB\" ], { \n     *      ValueColumnA: aValues => aValues.average(),\n     *      ValueColumnB:  bValues => bValues.sum(),\n     * });\n     * </pre>\n     * \n     * @example\n     * <pre>\n     * \n     * // To help understand the pivot function, let's expand it out and look at what it does internally.\n     * // Take the simplest example:\n     * const pivottedDf = df.pivot(\"PivotColumn\", \"ValueColumn\", values => values.average());\n     * \n     * // If we expand out the internals of the pivot function, it will look something like this:\n     * const pivottedDf = df.groupBy(row => row.PivotColumn)\n     *          .select(group => ({\n     *              PivotColumn: group.first().PivotColumn,\n     *              ValueColumn: group.deflate(row => row.ValueColumn).average()\n     *          }))\n     *          .orderBy(row  => row.PivotColumn);\n     * \n     * // You can see that pivoting a dataframe is the same as grouping, aggregating and sorting it.\n     * // Does pivoting seem simpler now?\n     * \n     * // It gets more complicated than that of course, because the pivot function supports multi-level nested \n     * // grouping and aggregation of multiple columns. So a full expansion of the pivot function is rather complex.\n     * </pre>\n     */\n    pivot<NewValueT = ValueT> (\n        columnOrColumns: string | Iterable<string>, \n        valueColumnNameOrSpec: string | IMultiColumnAggregatorSpec, \n        aggregator?: (values: ISeries<number, any>) => any\n            ): IDataFrame<number, NewValueT>;\n\n    /**\n     * Insert a pair at the start of the dataframe.\n     * Doesn't modify the original dataframe! The returned dataframe is entirely new and contains rows from the original dataframe plus the inserted pair.\n     *\n     * @param pair The index/value pair to insert.\n     * \n     * @return Returns a new dataframe with the specified pair inserted.\n     * \n     * @example\n     * <pre>\n     * \n     * const newIndex = ... index of the new row ...\n     * const newRow = ... the new data row to insert ...\n     * const insertedDf = df.insertPair([newIndex, newRows]);\n     * </pre>\n     */\n    insertPair (pair: [IndexT, ValueT]): IDataFrame<IndexT, ValueT>;\n\n    /**\n     * Append a pair to the end of a dataframe.\n     * Doesn't modify the original dataframe! The returned dataframe is entirely new and contains rows from the original dataframe plus the appended pair.\n     *\n     * @param pair The index/value pair to append.\n     *  \n     * @return Returns a new dataframe with the specified pair appended.\n     * \n     * @example\n     * <pre>\n     * \n     * const newIndex = ... index of the new row ...\n     * const newRow = ... the new data row to append ...\n     * const appendedDf = df.appendPair([newIndex, newRows]);\n     * </pre>\n     */\n    appendPair (pair: [IndexT, ValueT]): IDataFrame<IndexT, ValueT>;\n\n    /**\n     * Fill gaps in a dataframe.\n     *\n     * @param comparer User-defined comparer function that is passed pairA and pairB, two consecutive rows, return truthy if there is a gap between the rows, or falsey if there is no gap.\n     * @param generator User-defined generator function that is passed pairA and pairB, two consecutive rows, returns an array of pairs that fills the gap between the rows.\n     *\n     * @return Returns a new dataframe with gaps filled in.\n     * \n     * @example\n     * <pre>\n     * \n     *   var sequenceWithGaps = ...\n     *\n     *  // Predicate that determines if there is a gap.\n     *  var gapExists = (pairA, pairB) => {\n     *      // Returns true if there is a gap.\n     *      return true;\n     *  };\n     *\n     *  // Generator function that produces new rows to fill the game.\n     *  var gapFiller = (pairA, pairB) => {\n     *      // Create an array of index, value pairs that fill the gaps between pairA and pairB.\n     *      return [\n     *          newPair1,\n     *          newPair2,\n     *          newPair3,\n     *      ];\n     *  };\n     *\n     *  var sequenceWithoutGaps = sequenceWithGaps.fillGaps(gapExists, gapFiller);\n     * </pre>\n     */\n    fillGaps (comparer: ComparerFn<[IndexT, ValueT], [IndexT, ValueT]>, generator: GapFillFn<[IndexT, ValueT], [IndexT, ValueT]>): IDataFrame<IndexT, ValueT>;\n\n    /**\n     * Returns the specified default dataframe if the input dataframe is empty. \n     *\n     * @param defaultSequence Default dataframe to return if the input dataframe is empty.\n     * \n     * @return Returns 'defaultSequence' if the input dataframe is empty. \n     * \n     * @example\n     * <pre>\n     * \n     * const emptyDataFrame = new DataFrame();\n     * const defaultDataFrame = new DataFrame([ { A: 1 }, { A: 2 }, { A: 3 } ]);\n     * expect(emptyDataFrame.defaultIfEmpty(defaultDataFrame)).to.eql(defaultDataFrame);\n     * </pre>\n     * \n     * @example\n     * <pre>\n     * \n     * const nonEmptyDataFrame = new DataFrame([ { A: 100 }]);\n     * const defaultDataFrame = new DataFrame([ { A: 1 }, { A: 2 }, { A: 3 } ]);\n     * expect(nonEmptyDataFrame.defaultIfEmpty(defaultDataFrame)).to.eql(nonEmptyDataFrame);\n     * </pre>\n     */\n    defaultIfEmpty (defaultSequence: ValueT[] | IDataFrame<IndexT, ValueT>): IDataFrame<IndexT, ValueT>;\n\n    /**\n     * Detect the the frequency of the types of the values in the dataframe.\n     * This is a good way to understand the shape of your data.\n     *\n     * @return Returns a dataframe with rows that confirm to {@link ITypeFrequency} that describes the data types contained in the original dataframe.\n     * \n     * @example\n     * <pre>\n     * \n     * const df = dataForge.readFileSync(\"./my-data.json\").parseJSON();\n     * const dataTypes = df.detectTypes();\n     * console.log(dataTypes.toString());\n     * </pre>\n     */\n    detectTypes (): IDataFrame<number, ITypeFrequency>;\n\n    /**\n     * Detect the frequency of the values in the dataframe.\n     * This is a good way to understand the shape of your data.\n     *\n     * @return Returns a dataframe with rows that conform to {@link IValueFrequency} that describes the values contained in the original dataframe.\n     * \n     * @example\n     * <pre>\n     * \n     * const df = dataForge.readFileSync(\"./my-data.json\").parseJSON();\n     * const dataValues = df.detectValues();\n     * console.log(dataValues.toString());\n     * </pre>\n     */\n    detectValues (): IDataFrame<number, IValueFrequency>;\n\n    /**\n     * Serialize the dataframe to the JSON data format.\n     * \n     * @return Returns a string in the JSON data format that represents the dataframe.\n     * \n     * @example\n     * <pre>\n     * \n     * const jsonData = df.toJSON();\n     * console.log(jsonData);\n     * </pre>\n     */\n    toJSON (): string;\n\n    /**\n     * Serialize the dataframe to the CSV data format.\n     * \n     * @return Returns a string in the CSV data format that represents the dataframe.\n     * \n     * @example\n     * <pre>\n     * \n     * const csvData = df.toCSV();\n     * console.log(csvData);\n     * </pre>\n     * \n     * @example\n     * <pre>\n     * \n     * const csvData = df.toCSV({ header: false });\n     * console.log(csvData);\n     * </pre>\n     */\n    toCSV (options?: ICSVOutputOptions): string;\n\n    /**\n     * Serialize the dataframe to HTML.\n     * \n     * @return Returns a string in HTML format that represents the dataframe.\n     */\n    toHTML (): string;\n    \n    /**\n     * Serialize the dataframe to an ordinary JavaScript data structure.\n     * The resulting data structure is suitable for further serialization to JSON and can be used to \n     * transmit a DataFrame and its internal structure over the wire.\n     * Use the {@link deserialize} function to later reconstitute the serialized dataframe.\n     * \n     * @return Returns a JavaScript data structure conforming to {@link ISerializedDataFrame} that represents the dataframe and its internal structure.\n     * \n     * @example\n     * <pre>\n     * \n     * const jsDataStructure = df.serialize();\n     * const jsonData = JSON.stringify(jsDataStructure);\n     * console.log(jsonData);\n     * const deserializedJsDataStructure = JSON.parse(jsonData);\n     * const deserializedDf = DataFrame.deserialize(deserializedJsDataStructure); // Reconsituted.\n     * </pre>\n     */\n    serialize (): any;\n}\n\n/**\n * Interface to a dataframe that has been sorted.\n */\nexport interface IOrderedDataFrame<IndexT = number, ValueT = any, SortT = any> extends IDataFrame<IndexT, ValueT> {\n\n    /** \n     * Applys additional sorting (ascending) to an already sorted dataframe.\n     * \n     * @param selector User-defined selector that selects the additional value to sort by.\n     * \n     * @return Returns a new dataframe has been additionally sorted by the value chosen by the selector function. \n     * \n     * @example\n     * <pre>\n     * \n     * // Order sales by salesperson and then by amount (from least to most).\n     * const orderedDf = salesDf.orderBy(sale => sale.SalesPerson).thenBy(sale => sale.Amount);\n     * </pre>\n     */\n    thenBy<SortT> (selector: SelectorWithIndexFn<ValueT, SortT>): IOrderedDataFrame<IndexT, ValueT, SortT>;\n\n    /** \n     * Applys additional sorting (descending) to an already sorted dataframe.\n     * \n     * @param selector User-defined selector that selects the additional value to sort by.\n     * \n     * @return Returns a new dataframe has been additionally sorted by the value chosen by the selector function. \n     * \n     * @example\n     * <pre>\n     * \n     * // Order sales by salesperson and then by amount (from most to least).\n     * const orderedDf = salesDf.orderBy(sale => sale.SalesPerson).thenByDescending(sale => sale.Amount);\n     * </pre>\n     */\n    thenByDescending<SortT> (selector: SelectorWithIndexFn<ValueT, SortT>): IOrderedDataFrame<IndexT, ValueT, SortT>;\n}\n\n//\n// Represents the contents of a dataframe.\n//\ninterface IDataFrameContent<IndexT, ValueT> {\n    index: Iterable<IndexT>;\n    values: Iterable<ValueT>;\n    pairs: Iterable<[IndexT, ValueT]>;\n\n    columnNames: string[] | Iterable<string>,\n    isBaked: boolean,\n}\n\n/**\n * Class that represents a dataframe.\n * A dataframe contains an indexed sequence of data records.\n * Think of it as a spreadsheet or CSV file in memory.\n * \n * Each data record contains multiple named fields, the value of each field represents one row in a column of data.\n * Each column of data is a named {@link Series}.\n * You think of a dataframe a collection of named data series.\n * \n * @typeparam IndexT The type to use for the index.\n * @typeparam ValueT The type to use for each row/data record.\n */\nexport class DataFrame<IndexT = number, ValueT = any> implements IDataFrame<IndexT, ValueT> {\n\n    //\n    // Function to lazy evaluate the configuration of the dataframe.\n    //\n    private configFn: DataFrameConfigFn<IndexT, ValueT> | null = null;\n    \n    //\n    // The content of the dataframe.\n    // When this is null it means the dataframe is yet to be lazy initialised.\n    //\n    private content: IDataFrameContent<IndexT, ValueT> | null = null;\n    \n    private static readonly defaultCountIterable = new CountIterable();\n    private static readonly defaultEmptyIterable = new EmptyIterable();\n    \n    //\n    // Initialise dataframe content from an iterable of values.\n    //\n    private static initFromArray<IndexT, ValueT>(arr: Iterable<ValueT>): IDataFrameContent<IndexT, ValueT> {\n        const firstResult = arr[Symbol.iterator]().next();\n        const columnNames = !firstResult.done ? Object.keys(firstResult.value) : [];\n        return {\n            index: DataFrame.defaultCountIterable,\n            values: arr,\n            pairs: new MultiIterable([DataFrame.defaultCountIterable, arr]),\n            isBaked: true,\n            columnNames: columnNames,\n        };\n    }\n\n    //\n    // Initialise an empty dataframe.\n    //\n    private static initEmpty<IndexT, ValueT>(): IDataFrameContent<IndexT, ValueT> {\n        return {\n            index: DataFrame.defaultEmptyIterable,\n            values: DataFrame.defaultEmptyIterable,\n            pairs: DataFrame.defaultEmptyIterable,\n            isBaked: true,\n            columnNames: [],\n        };\n    }\n\n    //\n    // Initialise dataframe column names.\n    //\n    private static initColumnNames(inputColumnNames: Iterable<string>): Iterable<string> {\n        const outputColumnNames: string[] = [];\n        const columnNamesMap: any = {};\n    \n        // Search for duplicate column names.\n        for (const columnName of inputColumnNames) {\n            const columnNameLwr = columnName.toLowerCase();\n            if (columnNamesMap[columnNameLwr] === undefined) {\n                columnNamesMap[columnNameLwr] = 1;\n            }\n            else {\n                columnNamesMap[columnNameLwr] += 1;\n            }\n        }\n\n        const columnNoMap: any = {};\n\n        for (const columnName of inputColumnNames) {\n            const columnNameLwr = columnName.toLowerCase();\n            if (columnNamesMap[columnNameLwr] > 1) {\n                let curColumnNo = 1;\n\n                // There are duplicates of this column.\n                if (columnNoMap[columnNameLwr] !== undefined) {\n                    curColumnNo = columnNoMap[columnNameLwr];\n                }\n\n                outputColumnNames.push(columnName + \".\" + curColumnNo);\n                columnNoMap[columnNameLwr] = curColumnNo + 1;\n            }\n            else {\n                // No duplicates.\n                outputColumnNames.push(columnName);\n            }\n        }\n\n        return outputColumnNames;\n    }\n\n    //\n    // Check that a value is an interable.\n    //\n    private static checkIterable<T>(input: T[] | Iterable<T>, fieldName: string): void {\n        if (isArray(input)) {\n            // Ok\n        }\n        else if (isFunction(input[Symbol.iterator])) {\n            // Assume it's an iterable.\n            // Ok\n        }\n        else {\n            // Not ok\n            throw new Error(\"Expected '\" + fieldName + \"' field of DataFrame config object to be an array of values or an iterable of values.\");\n        }\n    };\n\n    //\n    // Initialise dataframe content from a config object.\n    //\n    private static initFromConfig<IndexT, ValueT>(config: IDataFrameConfig<IndexT, ValueT>): IDataFrameContent<IndexT, ValueT> {\n\n        let index: Iterable<IndexT>;\n        let values: Iterable<ValueT>;\n        let pairs: Iterable<[IndexT, ValueT]> | undefined;\n        let isBaked = false;\n        let columnNames: Iterable<string>;\n\n        if (config.pairs) {\n            DataFrame.checkIterable<[IndexT, ValueT]>(config.pairs, \"pairs\");\n            pairs = config.pairs;\n        }\n        \n        if (config.columns) {\n            let columnsConfig: any = config.columns;\n\n            if (isArray(columnsConfig) ||\n                isFunction((columnsConfig as any)[Symbol.iterator])) {\n\n                const iterableColumnsConfig = columnsConfig as Iterable<IColumnConfig>;\n                columnNames = Array.from(iterableColumnsConfig).map(column => column.name);\n                columnsConfig = toMap(iterableColumnsConfig, column => column.name, column => column.series);\n            }\n            else {\n                if (!isObject(columnsConfig)) throw new Error(\"Expected 'columns' member of 'config' parameter to DataFrame constructor to be an object with fields that define columns.\");\n\n                columnNames = Object.keys(columnsConfig);\n            }\n\n            let columnIterables: any[] = [];\n            for (let columnName of columnNames) {\n                DataFrame.checkIterable(columnsConfig[columnName], columnName);\n                columnIterables.push(columnsConfig[columnName]);\n            }\n\n            values = new CsvRowsIterable(columnNames, new MultiIterable(columnIterables));\n        }\n        else {\n            if (config.columnNames) {\n                columnNames = this.initColumnNames(config.columnNames);\n            }\n\n            if (config.rows) {\n                if (!config.columnNames) {\n                    columnNames = new SelectIterable(new CountIterable(), c => \"Column.\" + c.toString());\n                }\n\n                DataFrame.checkIterable<any[][]>(config.rows, 'rows')\n                values = new CsvRowsIterable(columnNames!, config.rows); // Convert data from rows to columns.\n            }\n            else if (config.values) {\n                DataFrame.checkIterable<ValueT>(config.values, 'values')\n                values = config.values;\n                if (!config.columnNames) {\n                    columnNames = new ColumnNamesIterable(values, config.considerAllRows || false);\n                }\n            }\n            else if (pairs) {\n                values = new ExtractElementIterable(pairs, 1);\n                if (!config.columnNames) {\n                    columnNames = new ColumnNamesIterable(values, config.considerAllRows || false);\n                }\n            }\n            else {\n                values = DataFrame.defaultEmptyIterable;\n                if (!config.columnNames) {\n                    columnNames = DataFrame.defaultEmptyIterable;\n                }\n            }\n        }\n\n        if (config.index) {\n            DataFrame.checkIterable<IndexT>(config.index, 'index');\n            index = config.index;\n        }\n        else if (pairs) {\n            index = new ExtractElementIterable(pairs, 0);\n        }\n        else {\n            index = DataFrame.defaultCountIterable;\n        }\n\n        if (!pairs) {\n            pairs = new MultiIterable([index, values]);\n        }\n\n        if (config.baked !== undefined) {\n            isBaked = config.baked;\n        }\n\n        return {\n            index: index,\n            values: values,\n            pairs: pairs,\n            isBaked: isBaked,\n            columnNames: columnNames!,\n        };\n    }\n\n    /**\n     * Create a dataframe.\n     * \n     * @param config This can be an array, a configuration object or a function that lazily produces a configuration object. \n     * \n     * It can be an array that specifies the data records that the dataframe contains.\n     * \n     * It can be a {@link IDataFrameConfig} that defines the data and configuration of the dataframe.\n     * \n     * Or it can be a function that lazily produces a {@link IDataFrameConfig}.\n     * \n     * @example\n     * <pre>\n     * \n     * const df = new DataFrame();\n     * </pre>\n     * \n     * @example\n     * <pre>\n     * \n     * const df = new DataFrame([ { A: 10 }, { A: 20 }, { A: 30 }, { A: 40 }]);\n     * </pre>\n     * \n     * @example\n     * <pre>\n     * \n     * const df = new DataFrame({ index: [1, 2, 3, 4], values: [ { A: 10 }, { A: 20 }, { A: 30 }, { A: 40 }] });\n     * </pre>\n     * \n     * @example\n     * <pre>\n     * \n     * const lazyInit = () => ({ index: [1, 2, 3, 4], values: [ { A: 10 }, { A: 20 }, { A: 30 }, { A: 40 }] });\n     * const df = new DataFrame(lazyInit);\n     * </pre>\n     */\n    constructor(config?: Iterable<ValueT> | IDataFrameConfig<IndexT, ValueT> | DataFrameConfigFn<IndexT, ValueT>) {\n        if (config) {\n            if (isFunction(config)) {\n                this.configFn = config;\n            }\n            else if (isArray(config) || \n                     isFunction((config as any)[Symbol.iterator])) {\n                this.content = DataFrame.initFromArray(config as Iterable<ValueT>);\n            }\n            else {\n                this.content = DataFrame.initFromConfig(config as IDataFrameConfig<IndexT, ValueT>);\n            }\n        }\n        else {\n            this.content = DataFrame.initEmpty();\n        }\n    }\n\n    //\n    // Ensure the dataframe content has been initialised.\n    //\n    private lazyInit() {\n        if (this.content === null && this.configFn !== null) {\n            this.content = DataFrame.initFromConfig(this.configFn());\n        }\n    }\n\n    //\n    // Ensure the dataframe content is lazy initalised and return it.\n    //\n    private getContent(): IDataFrameContent<IndexT, ValueT> { \n        this.lazyInit();\n        return this.content!;\n    }\n    \n    /**\n     * Get an iterator to enumerate the rows of the dataframe.\n     * Enumerating the iterator forces lazy evaluation to complete.\n     * This function is automatically called by `for...of`.\n     * \n     * @return An iterator for the dataframe.\n     * \n     * @example\n     * <pre>\n     * \n     * for (const row of df) {\n     *     // ... do something with the row ...\n     * }\n     * </pre>\n     */\n    [Symbol.iterator](): Iterator<any> {\n        return this.getContent().values[Symbol.iterator]();\n    }\n\n    /**\n     * Get the names of the columns in the dataframe.\n     * \n     * @return Returns an array of the column names in the dataframe.  \n     * \n     * @example\n     * <pre>\n     * \n     * console.log(df.getColumnNames());\n     * </pre>\n     */\n    getColumnNames (): string[] {\n        return Array.from(this.getContent().columnNames);\n    }\n\n    /** \n     * Retreive the collection of all columns in the dataframe.\n     * \n     * @return Returns a {@link Series} containing the names of the columns in the dataframe.\n     * \n     * @example\n     * <pre>\n     * \n     * for (const column in df.getColummns()) {\n     *      console.log(\"Column name: \");\n     *      console.log(column.name);\n     * \n     *      console.log(\"Data:\");\n     *      console.log(column.series.toArray());\n     * }\n     * </pre>\n     */\n    getColumns (): ISeries<number, IColumn> {\n        return new Series<number, IColumn>(() => {\n            const columnNames = this.getColumnNames();\n            return {\n                values: columnNames.map(columnName => {\n                    const series = this.getSeries(columnName).skipWhile(value => value === undefined);\n                    const firstValue = series.any() ? series.first() : undefined;\n                    return {\n                        name: columnName,\n                        type: determineType(firstValue), //TODO: Should cache the type.\n                        series: series,\n                    };\n                }),\n            };\n        });\n    }    \n\n    /**\n     * Cast the value of the dataframe to a new type.\n     * This operation has no effect but to retype the value that the dataframe contains.\n     * \n     * @return The same dataframe, but with the type changed.\n     * \n     * @example\n     * <pre>\n     * \n     * const castDf = df.cast<SomeOtherType>();\n     * </pre>\n     */\n    cast<NewValueT> (): IDataFrame<IndexT, NewValueT> {\n        return this as any as IDataFrame<IndexT, NewValueT>;\n    }\n    \n    /**\n     * Get the index for the dataframe.\n     * \n     * @return The {@link Index} for the dataframe.\n     * \n     * @example\n     * <pre>\n     * \n     * const index = df.getIndex();\n     * </pre>\n     */\n    getIndex (): IIndex<IndexT> {\n        return new Index<IndexT>(() => ({ values: this.getContent().index }));\n    }\n\n    /**\n     * Set a named column as the {@link Index} of the dataframe.\n     *\n     * @param columnName Name of the column to use as the new {@link Index} of the returned dataframe.\n     *\n     * @return Returns a new dataframe with the values of the specified column as the new {@link Index}.\n     * \n     * @example\n     * <pre>\n     * \n     * const indexedDf = df.setIndex(\"SomeColumn\");\n     * </pre>\n     */\n    setIndex<NewIndexT = any> (columnName: string): IDataFrame<NewIndexT, ValueT> {\n        if (!isString(columnName)) throw new Error(\"Expected 'columnName' parameter to 'DataFrame.setIndex' to be a string that specifies the name of the column to set as the index for the dataframe.\");\n\n        return this.withIndex<NewIndexT>(this.getSeries(columnName));\n    }\n    \n    /**\n     * Apply a new {@link Index} to the dataframe.\n     * \n     * @param newIndex The new array or iterable to be the new {@link Index} of the dataframe. Can also be a selector to choose the {@link Index} for each row in the dataframe.\n     * \n     * @return Returns a new dataframe or dataframe with the specified {@link Index} attached.\n     * \n     * @example\n     * <pre>\n     * \n     * const indexedDf = df.withIndex([10, 20, 30]);\n     * </pre>\n     * \n     * @example\n     * <pre>\n     * \n     * const indexedDf = df.withIndex(df.getSeries(\"SomeColumn\"));\n     * </pre>\n     * \n     * @example\n     * <pre>\n     * \n     * const indexedDf = df.withIndex(row => row.SomeColumn);\n     * </pre>\n     * \n     * @example\n     * <pre>\n     * \n     * const indexedDf = df.withIndex(row => row.SomeColumn + 20);\n     * </pre>\n     */\n    withIndex<NewIndexT> (newIndex: Iterable<NewIndexT> | SelectorFn<ValueT, NewIndexT>): IDataFrame<NewIndexT, ValueT> {\n\n        if (isFunction(newIndex)) {\n            return new DataFrame<NewIndexT, ValueT>(() => {\n                const content = this.getContent();\n                return {\n                    columnNames: content.columnNames,\n                    values: content.values,\n                    index: this.deflate(newIndex),\n                };\n            });\n        }\n        else {\n            DataFrame.checkIterable(newIndex as Iterable<NewIndexT>, 'newIndex');\n\n            return new DataFrame<NewIndexT, ValueT>(() => {\n                const content = this.getContent();\n                return {\n                    columnNames: content.columnNames,\n                    values: content.values,\n                    index: newIndex as Iterable<NewIndexT>,\n                };\n            });\n        }\n    }\n\n    /**\n     * Resets the {@link Index} of the dataframe back to the default zero-based sequential integer index.\n     * \n     * @return Returns a new dataframe with the {@link Index} reset to the default zero-based index. \n     * \n     * @example\n     * <pre>\n     * \n     * const dfWithResetIndex = df.resetIndex();\n     * </pre>\n     */\n    resetIndex (): IDataFrame<number, ValueT> {\n        return new DataFrame<number, ValueT>(() => {\n            const content = this.getContent();\n            return {\n                columnNames: content.columnNames,\n                values: content.values,\n                // Strip the index.\n            };\n        });\n    }\n    \n    /**\n     * Extract a {@link Series} from a named column in the dataframe.\n     *\n     * @param columnName Specifies the name of the column that contains the {@link Series} to retreive.\n     * \n     * @return Returns the {@link Series} extracted from the named column in the dataframe.\n     * \n     * @example\n     * <pre>\n     * \n     * const series = df.getSeries(\"SomeColumn\");\n     * </pre>\n     */\n    getSeries<SeriesValueT = any> (columnName: string): ISeries<IndexT, SeriesValueT> {\n\n        if (!isString(columnName)) throw new Error(\"Expected 'columnName' parameter to 'DataFrame.getSeries' function to be a string that specifies the name of the column to retreive.\");\n\n        return new Series<IndexT, SeriesValueT>(() => ({\n            values: new SelectIterable<ValueT, SeriesValueT>(\n                this.getContent().values, \n                (row: any) => row[columnName],\n            ),\n            index: this.getContent().index,\n        }));\n    }\n\n    /**\n     * Determine if the dataframe contains a {@link Series} the specified named column.\n     *\n     * @param columnName Name of the column to check for.\n     * \n     * @return Returns true if the dataframe contains the requested {@link Series}, otherwise returns false.\n     * \n     * @example\n     * <pre>\n     * \n     * if (df.hasSeries(\"SomeColumn\")) {\n     *      // ... the dataframe contains a series with the specified column name ...\n     * }\n     * </pre>\n     */\n    hasSeries (columnName: string): boolean {\n        const columnNameLwr = columnName.toLowerCase();\n        for (let existingColumnName of this.getColumnNames()) {\n            if (existingColumnName.toLowerCase() === columnNameLwr) {\n                return true;\n            }\n        }\n\n        return false;\n    }\n    \n    /**\n     * Verify the existence of a name column and extracts the {@link Series} for it.\n     * Throws an exception if the requested column doesn't exist.\n     *\n     * @param columnName Name of the column to extract.\n     * \n     * @return Returns the {@link Series} for the column if it exists, otherwise it throws an exception.\n     * \n     * @example\n     * <pre>\n     * \n     * try {\n     *      const series = df.expectSeries(\"SomeColumn\");\n     *      // ... do something with the series ...\n     * }\n     * catch (err) {\n     *      // ... the dataframe doesn't contain the column \"SomeColumn\" ...\n     * }\n     * </pre>\n     */\n    expectSeries<SeriesValueT> (columnName: string): ISeries<IndexT, SeriesValueT> {\n        if (!this.hasSeries(columnName)) {\n            throw new Error(\"Expected dataframe to contain series with column name: '\" + columnName + \"'.\");\n        }\n\n        return this.getSeries(columnName);\n    }\n\n    /**\n     * Create a new dataframe with a replaced or additional column specified by the passed-in series.\n     *\n     * @param columnNameOrSpec The name of the column to add or replace or a {@link IColumnGenSpec} that defines the columns to add.\n     * @param [series] When columnNameOrSpec is a string that identifies the column to add, this specifies the {@link Series} to add to the dataframe or a function that produces a series (given a dataframe).\n     *\n     * @return Returns a new dataframe replacing or adding a particular named column.\n     * \n     * @example\n     * <pre>\n     * \n     * const modifiedDf = df.withSeries(\"ANewColumn\", new Series([1, 2, 3]));\n     * </pre>\n     * \n     * @example\n     * <pre>\n     * \n     * const modifiedDf = df.withSeries(\"ANewColumn\", df => \n     *      df.getSeries(\"SourceData\").select(aTransformation)\n     * );\n     * </pre>\n     * \n     * @example\n     * <pre>\n     * \n     * const modifiedDf = df.withSeries({\n     *      ANewColumn: new Series([1, 2, 3]),\n     *      SomeOtherColumn: new Series([10, 20, 30])\n     * });\n     * <pre>\n     * \n     * @example\n     * <pre>\n     * \n     * const modifiedDf = df.withSeries({\n     *      ANewColumn: df => df.getSeries(\"SourceData\").select(aTransformation))\n     * });\n     * <pre>\n     */\n    withSeries<OutputValueT = any, SeriesValueT = any> (columnNameOrSpec: string | IColumnGenSpec, series?: ISeries<IndexT, SeriesValueT> | SeriesSelectorFn<IndexT, ValueT, SeriesValueT>): IDataFrame<IndexT, OutputValueT> {\n\n        if (!isObject(columnNameOrSpec)) {\n            if (!isString(columnNameOrSpec)) throw new Error(\"Expected 'columnNameOrSpec' parameter to 'DataFrame.withSeries' function to be a string that specifies the column to set or replace.\");\n            if (!isFunction(series as Object)) {\n                if (!isObject(series)) throw new Error(\"Expected 'series' parameter to 'DataFrame.withSeries' to be a Series object or a function that takes a dataframe and produces a Series.\");\n            }\n        }\n        else {\n            if (!isUndefined(series)) throw new Error(\"Expected 'series' parameter to 'DataFrame.withSeries' to not be set when 'columnNameOrSpec is an object.\");\n        }\n\n        if (isObject(columnNameOrSpec)) {\n            const columnSpec: IColumnGenSpec = <IColumnGenSpec> columnNameOrSpec;\n            const columnNames = Object.keys(columnSpec);\n            let workingDataFrame: IDataFrame<IndexT, ValueT> = this;\n            for (const columnName of columnNames) {\n                workingDataFrame = workingDataFrame.withSeries(columnName, columnSpec[columnName]);\n            }\n\n            return workingDataFrame.cast<OutputValueT>();\n        }\n\n        const columnName: string = <string> columnNameOrSpec;\n\n        if (this.none()) { // We have an empty data frame.\n            let importSeries: ISeries<IndexT, SeriesValueT>;\n    \n            if (isFunction(series as Object)) {\n                importSeries = (series! as SeriesSelectorFn<IndexT, ValueT, SeriesValueT>)(this);\n            }\n            else { \n                importSeries = series! as ISeries<IndexT, SeriesValueT>;\n            }\n                \n            \n            return importSeries.inflate<ValueT>(value => {\n                    var row: any = {};\n                    row[columnName] = value;\n                    return row;\n                })\n                .cast<OutputValueT>();\n        }\n\n        return new DataFrame<IndexT, OutputValueT>(() => {    \n            let importSeries: ISeries<IndexT, SeriesValueT>;\n    \n            if (isFunction(series as Object)) {\n                importSeries = (series! as SeriesSelectorFn<IndexT, ValueT, SeriesValueT>)(this);\n            }\n            else { \n                importSeries = series! as ISeries<IndexT, SeriesValueT>;\n            }\n\n            const seriesValueMap = toMap2(importSeries.toPairs(), pair => pair[0], pair => pair[1]);\n            const newColumnNames =  makeDistinct(this.getColumnNames().concat([columnName]));\n    \n            return {\n                columnNames: newColumnNames,\n                index: this.getContent().index,\n                pairs: new SelectIterable<[IndexT, ValueT], [IndexT, OutputValueT]>(this.getContent().pairs, pair => {\n                    const index = pair[0];\n                    const value = pair[1];\n                    const modified: any = Object.assign({}, value);\n                    modified[columnName] = seriesValueMap.get(index);\n                    return [\n                        index,\n                        modified\n                    ];\n                }),\n            };\n        });\n    }\n\n    /**\n     * Merge multiple dataframes into a single dataframe.\n     * Rows are merged by indexed. \n     * Same named columns in subsequent dataframes override columns earlier dataframes.\n     * \n     * @param dataFrames An array or series of dataframes to merge.\n     * \n     * @returns The merged data frame.\n     * \n     * @example\n     * <pre>\n     * \n     * const mergedDF = DataFrame.merge([df1, df2, etc]);\n     * </pre>\n     */\n    static merge<MergedValueT = any, IndexT = any, ValueT = any>(dataFrames: Iterable<IDataFrame<IndexT, ValueT>>): IDataFrame<IndexT, MergedValueT> {\n\n        const rowMap = new Map<IndexT, any>();\n        for (const dataFrame of dataFrames) {\n            for (const pair of dataFrame.toPairs()) {\n                const index = pair[0];\n                if (!rowMap.has(index)) {\n                    const clone = Object.assign({}, pair[1]);\n                    rowMap.set(index, clone);\n                }\n                else {\n                    rowMap.set(index, Object.assign(rowMap.get(index), pair[1]));\n                }\n            }\n        }\n\n        const allColumnNames = Array.from(dataFrames)\n            .map(dataFrame => dataFrame.getColumnNames())\n            .reduce((prev, next) => prev.concat(next), []);\n        const newColumnNames =  makeDistinct(allColumnNames);\n        const mergedPairs = Array.from(rowMap.keys()).map(index => [index, rowMap.get(index)]);\n\n        mergedPairs.sort((a, b) => { // Sort by index, ascending.\n            if (a[0] === b[0]) {\n                return 0;\n            }\n            else if (a[0] > b[0]) {\n                return 1;\n            }\n            else {\n                return -1;\n            }\n        });\n\n        return new DataFrame<IndexT, MergedValueT>({\n            columnNames: newColumnNames,\n            pairs: mergedPairs as [IndexT, MergedValueT][],\n        });\n    }  \n\n    /**\n     * Merge one or more dataframes into this dataframe.\n     * Rows are merged by indexed. \n     * Same named columns in subsequent dataframes override columns in earlier dataframes.\n     * \n     * @param otherDataFrames... One or more dataframes to merge into this dataframe.\n     * \n     * @returns The merged data frame.\n     * \n     * @example\n     * <pre>\n     * \n     * const mergedDF = df1.merge(df2);\n     * </pre>\n     * \n     * <pre>\n     * \n     * const mergedDF = df1.merge(df2, df3, etc);\n     * </pre>\n     */\n    merge<MergedValueT = ValueT>(...otherDataFrames: IDataFrame<IndexT, any>[]): IDataFrame<IndexT, MergedValueT> {\n        return DataFrame.merge<MergedValueT, IndexT, any>([this as IDataFrame<IndexT, ValueT>].concat(otherDataFrames));\n    }\n    \n    /**\n     * Add a series to the dataframe, but only if it doesn't already exist.\n     * \n     * @param columnNameOrSpec The name of the series to add or a {@link IColumnGenSpec} that specifies the columns to add.\n     * @param [series] If columnNameOrSpec is a string that specifies the name of the series to add, this specifies the actual {@link Series} to add or a selector that generates the series given the dataframe.\n     * \n     * @return Returns a new dataframe with the specified series added, if the series didn't already exist. Otherwise if the requested series already exists the same dataframe is returned.\n     * \n     * @example\n     * <pre>\n     * \n     * const updatedDf = df.ensureSeries(\"ANewColumn\", new Series([1, 2, 3]));\n     * </pre>\n     * \n     * @example\n     * <pre>\n     * \n     * const updatedDf = df.ensureSeries(\"ANewColumn\", df => \n     *      df.getSeries(\"AnExistingSeries\").select(aTransformation)\n     * );\n     * </pre>\n     * \n     * @example\n     * <pre>\n     * \n     * const modifiedDf = df.ensureSeries({\n     *      ANewColumn: new Series([1, 2, 3]),\n     *      SomeOtherColumn: new Series([10, 20, 30])\n     * });\n     * <pre>\n     * \n     * @example\n     * <pre>\n     * \n     * const modifiedDf = df.ensureSeries({\n     *      ANewColumn: df => df.getSeries(\"SourceData\").select(aTransformation))\n     * });\n     * <pre>\n     */\n    ensureSeries<SeriesValueT> (columnNameOrSpec: string | IColumnGenSpec, series?: ISeries<IndexT, SeriesValueT> | SeriesSelectorFn<IndexT, ValueT, SeriesValueT>): IDataFrame<IndexT, ValueT> {\n\n        if (!isObject(columnNameOrSpec)) {\n            if (!isString(columnNameOrSpec)) throw new Error(\"Expected 'columnNameOrSpec' parameter to 'DataFrame.ensureSeries' function to be a string that specifies the column to set or replace.\");\n            if (!isFunction(series as Object)) {\n                if (!isObject(series)) throw new Error(\"Expected 'series' parameter to 'DataFrame.ensureSeries' to be a Series object or a function that takes a dataframe and produces a Series.\");\n            }\n        }\n        else {\n            if (!isUndefined(series)) throw new Error(\"Expected 'series' parameter to 'DataFrame.ensureSeries' to not be set when 'columnNameOrSpec is an object.\");\n        }\n\n        if (isObject(columnNameOrSpec)) {\n            const columnSpec: IColumnGenSpec = <IColumnGenSpec> columnNameOrSpec;\n            const columnNames = Object.keys(columnNameOrSpec);\n            let workingDataFrame = <IDataFrame<IndexT,any>> this;\n            for (const columnName of columnNames) {\n                workingDataFrame = workingDataFrame.ensureSeries(columnName, columnSpec[columnName]);\n            }\n\n            return workingDataFrame;\n        }\n\n        const columnName: string = <string> columnNameOrSpec;\n        if (this.hasSeries(columnName)) {\n            return this; // Already have the series.\n        }\n        else {\n            return this.withSeries(columnName, series);\n        }\n    }    \n\n    /**\n     * Create a new dataframe with just a subset of columns.\n     *\n     * @param columnNames Array of column names to include in the new dataframe.\n     * \n     * @return Returns a dataframe with a subset of columns from the original dataframe.\n     * \n     * @example\n     * <pre>\n     * const subsetDf = df.subset([\"ColumnA\", \"ColumnB\"]);\n     * </pre>\n     */\n    subset<NewValueT = ValueT> (columnNames: string[]): IDataFrame<IndexT, NewValueT> {\n        if (!isArray(columnNames)) throw new Error(\"Expected 'columnNames' parameter to 'DataFrame.subset' to be an array of column names to keep.\");\t\n\n        return new DataFrame<IndexT, NewValueT>(() => {\n            const content = this.getContent();\n            return {\n                columnNames: columnNames,\n                index: content.index,\n                values: new SelectIterable<ValueT, NewValueT>(content.values, (value: any) => {\n                    const output: any = {};\n                    for (const columnName of columnNames) {\n                        output[columnName] = value[columnName];\n                    }\n                    return output;\n                }),\n                pairs: new SelectIterable<[IndexT, ValueT], [IndexT, NewValueT]>(content.pairs, (pair: any) => {\n                    const output: any = {};\n                    const value = pair[1];\n                    for (const columnName of columnNames) {\n                        output[columnName] = value[columnName];\n                    }\n                    return [pair[0], output];\n                }),\n            }\n        });\n    };\n    \n    /**\n     * Create a new dataframe with the requested column or columns dropped.\n     *\n     * @param columnOrColumns Specifies the column name (a string) or columns (array of strings) to drop.\n     * \n     * @return Returns a new dataframe with a particular named column or columns removed.\n     * \n     * @example\n     * <pre>\n     * const modifiedDf = df.dropSeries(\"SomeColumn\");\n     * </pre>\n     * \n     * @example\n     * <pre>\n     * const modifiedDf = df.dropSeries([\"ColumnA\", \"ColumnB\"]);\n     * </pre>\n     */\n    dropSeries<NewValueT = ValueT> (columnOrColumns: string | string[]): IDataFrame<IndexT, NewValueT> {\n\n        if (!isArray(columnOrColumns)) {\n            if (!isString(columnOrColumns)) throw new Error(\"'DataFrame.dropSeries' expected either a string or an array or strings.\");\n\n            columnOrColumns = [columnOrColumns]; // Convert to array for coding convenience.\n        }\n\n        return new DataFrame<IndexT, NewValueT>(() => {\n            const content = this.getContent();\n            const newColumnNames = [];\n            for (const columnName of content.columnNames) {\n                if (columnOrColumns.indexOf(columnName) === -1) {\n                    newColumnNames.push(columnName); // This column is not being dropped.\n                }\n            }\n\n            return {\n                columnNames: newColumnNames,\n                index: content.index,\n                values: new SelectIterable<ValueT, NewValueT>(content.values, value => {\n                    const clone: any = Object.assign({}, value);\n                    for (const droppedColumnName of columnOrColumns) {\n                        delete clone[droppedColumnName];\n                    }\n                    return clone;\n                }),\n                pairs: new SelectIterable<[IndexT, ValueT], [IndexT, NewValueT]>(content.pairs, pair => {\n                    const clone: any = Object.assign({}, pair[1]);\n                    for (const droppedColumnName of columnOrColumns) {\n                        delete clone[droppedColumnName];\n                    }\n                    return [pair[0], clone];\n                }),\n            };\n        });\n    }\n        \n    /**\n     * Create a new dataframe with columns reordered.\n     * New column names create new columns (with undefined values), omitting existing column names causes those columns to be dropped.\n     * \n     * @param columnNames Specifies the new order for columns.\n     * \n     * @return Returns a new dataframe with columns reodered according to the order of the array of column names that is passed in.\n     * \n     * @example\n     * <pre>\n     * const reorderedDf = df.reorderSeries([\"FirstColumn\", \"SecondColumn\", \"etc\"]);\n     * </pre>\n     */\n    reorderSeries<NewValueT = ValueT> (columnNames: string[]): IDataFrame<IndexT, NewValueT> {\n\n        if (!isArray(columnNames)) throw new Error(\"Expected parameter 'columnNames' to 'DataFrame.reorderSeries' to be an array with column names.\");\n\n        for (const columnName of columnNames) {\n            if (!isString(columnName)) throw new Error(\"Expected parameter 'columnNames' to 'DataFrame.reorderSeries' to be an array with column names.\");\n        }\n\n        return new DataFrame<IndexT, NewValueT>(() => {\n            const content = this.getContent();\n            return {\n                columnNames: columnNames,\n                index: content.index,\n                values: new SelectIterable<ValueT, NewValueT>(content.values, (value: any) => {\n                    const output: any = {};\n                    for (const columnName of columnNames) {\n                        output[columnName] = value[columnName];\n                    }\n\n                    return <NewValueT> output;\n                }),\n                pairs:  new SelectIterable<[IndexT, ValueT], [IndexT, NewValueT]>(content.pairs, (pair: [IndexT, ValueT]) => {\n                    const value: any = <any> pair[1];\n                    const output: any = {};\n                    for (const columnName of columnNames) {\n                        output[columnName] = value[columnName];\n                    }\n\n                    return [pair[0], <NewValueT> output];\n                }),\n            };\n        });\n    }   \n\n    /**\n     * Bring the column(s) with specified name(s) to the front of the column order, making it (or them) the first column(s) in the output dataframe.\n     *\n     * @param columnOrColumns Specifies the column or columns to bring to the front.\n     *\n     * @return Returns a new dataframe with 1 or more columns bought to the front of the column ordering.\n     * \n     * @example\n     * <pre>\n     * const modifiedDf = df.bringToFront(\"NewFirstColumn\");\n     * </pre>\n     * \n     * @example\n     * <pre>\n     * const modifiedDf = df.bringToFront([\"NewFirstColumn\", \"NewSecondColumn\"]);\n     * </pre>\n     */\n    bringToFront (columnOrColumns: string | string[]): IDataFrame<IndexT, ValueT> {\n\n        if (isArray(columnOrColumns)) {\n            for (const columnName of columnOrColumns) {\n                if (!isString(columnName)) {\n                    throw new Error(\"Expect 'columnOrColumns' parameter to 'DataFrame.bringToFront' function to specify a column or columns via a string or an array of strings.\");\t\n                }\n            }\n        }\n        else {\n            if (!isString(columnOrColumns)) {\n                throw new Error(\"Expect 'columnOrColumns' parameter to 'DataFrame.bringToFront' function to specify a column or columns via a string or an array of strings.\");\n            }\n\n            columnOrColumns = [columnOrColumns]; // Convert to array for coding convenience.\n        }\n\n        return new DataFrame<IndexT, ValueT>(() => {\n            const content = this.getContent();\n            const existingColumns = Array.from(content.columnNames);\n            const columnsToMove: string[] = [];\n            for (const columnToMove of columnOrColumns) {\n                if (existingColumns.indexOf(columnToMove) !== -1) {\n                    // The request column actually exists, so we will move it.\n                    columnsToMove.push(columnToMove);\n                }\n            }\n\n            const untouchedColumnNames: string[] = [];\n            for (const existingColumnName of existingColumns) {\n                if (columnOrColumns.indexOf(existingColumnName) === -1) {\n                    untouchedColumnNames.push(existingColumnName);\n                }\n            }\n            \n            return {\n                columnNames: columnsToMove.concat(untouchedColumnNames),\n                index: content.index,\n                values: content.values,\n                pairs: content.pairs,\n            };\n        })\n    }\n\n    /**\n     * Bring the column(s) with specified name(s) to the back of the column order, making it (or them) the last column(s) in the output dataframe.\n     *\n     * @param columnOrColumns Specifies the column or columns to bring to the back.\n     *\n     * @return Returns a new dataframe with 1 or more columns bought to the back of the column ordering.\n     * \n     * @example\n     * <pre>\n     * const modifiedDf = df.bringToBack(\"NewLastColumn\");\n     * </pre>\n     * \n     * @example\n     * <pre>\n     * const modifiedDf = df.bringToBack([\"NewSecondLastCollumn, \"\"NewLastColumn\"]);\n     * </pre>\n     */\n    bringToBack (columnOrColumns: string | string[]): IDataFrame<IndexT, ValueT> {\n\n        if (isArray(columnOrColumns)) {\n            for (const columnName of columnOrColumns) {\n                if (!isString(columnName)) {\n                    throw new Error(\"Expect 'columnOrColumns' parameter to 'DataFrame.bringToBack' function to specify a column or columns via a string or an array of strings.\");\t\n                }\n            }\n        }\n        else {\n            if (!isString(columnOrColumns)) {\n                throw new Error(\"Expect 'columnOrColumns' parameter to 'DataFrame.bringToBack' function to specify a column or columns via a string or an array of strings.\");\n            }\n\n            columnOrColumns = [columnOrColumns]; // Convert to array for coding convenience.\n        }\n\n        return new DataFrame<IndexT, ValueT>(() => {\n            const content = this.getContent();\n            const existingColumns = Array.from(content.columnNames);\n            const columnsToMove: string[] = [];\n            for (const columnToMove of columnOrColumns) {\n                if (existingColumns.indexOf(columnToMove) !== -1) {\n                    // The request column actually exists, so we will move it.\n                    columnsToMove.push(columnToMove);\n                }\n            }\n\n            const untouchedColumnNames: string[] = [];\n            for (const existingColumnName of existingColumns) {\n                if (columnOrColumns.indexOf(existingColumnName) === -1) {\n                    untouchedColumnNames.push(existingColumnName);\n                }\n            }\n            \n            return {\n                columnNames: untouchedColumnNames.concat(columnsToMove),\n                index: content.index,\n                values: content.values,\n                pairs: content.pairs,\n            };\n        })\n    }\n    \n    /**\n     * Create a new dataframe with 1 or more columns renamed.\n     *\n     * @param newColumnNames A column rename spec - a JavaScript hash that maps existing column names to new column names.\n     * \n     * @return Returns a new dataframe with specified columns renamed.\n     * \n     * @example\n     * <pre>\n     * \n     * const renamedDf = df.renameSeries({ OldColumnName, NewColumnName });\n     * </pre>\n     * \n     * @example\n     * <pre>\n     * \n     * const renamedDf = df.renameSeries({ \n     *      Column1: ColumnA,\n     *      Column2: ColumnB\n     * });\n     * </pre>\n     */\n    renameSeries<NewValueT = ValueT> (newColumnNames: IColumnRenameSpec): IDataFrame<IndexT, NewValueT> {\n\n        if (!isObject(newColumnNames)) throw new Error(\"Expected parameter 'newColumnNames' to 'DataFrame.renameSeries' to be an array with column names.\");\n\n        const existingColumnsToRename = Object.keys(newColumnNames);\n        for (const existingColumnName of existingColumnsToRename) {\n            if (!isString(existingColumnName)) throw new Error(\"Expected existing column name '\" + existingColumnName + \"' of 'newColumnNames' parameter to 'DataFrame.renameSeries' to be a string.\");\n            if (!isString(newColumnNames[existingColumnName])) throw new Error(\"Expected new column name '\" + newColumnNames[existingColumnName] + \"' for existing column '\" + existingColumnName + \"' of 'newColumnNames' parameter to 'DataFrame.renameSeries' to be a string.\");\n        }\n\n        return new DataFrame<IndexT, NewValueT>(() => {\n            const content = this.getContent();\n            const renamedColumns: string[] = [];\n\n            for (const existingColumnName of content.columnNames) { // Convert the column rename spec to array of new column names.\n                const columnIndex = existingColumnsToRename.indexOf(existingColumnName);\n                if (columnIndex === -1) {\n                    renamedColumns.push(existingColumnName); // This column is not renamed.                    \n                }\n                else {\n                    renamedColumns.push(newColumnNames[existingColumnName]); // This column is renamed.\n                }\n            }\n    \n            //\n            // Remap each row of the data frame to the new column names.\n            //\n            function remapValue (value: any): any {\n                const clone = Object.assign({}, value);\n    \n                for (const existingColumName of existingColumnsToRename) {\n                    clone[newColumnNames[existingColumName]] = clone[existingColumName];\n                    delete clone[existingColumName];\n                }\n    \n                return clone;\n            }\n    \n            return {\n                columnNames: renamedColumns,\n                index: content.index,\n                values: new SelectIterable<ValueT, NewValueT>(content.values, remapValue),\n                pairs: new SelectIterable<[IndexT, ValueT], [IndexT, NewValueT]>(content.pairs, pair => {\n                    return [pair[0], remapValue(pair[1])];\n                }),\n            };\n        });\n    };\n    \n    /**\n    * Extract values from the dataframe as an array.\n    * This forces lazy evaluation to complete.\n    * \n    * @return Returns an array of the values contained within the dataframe. \n    * \n    * @example\n    * <pre>\n    * const values = df.toArray();\n    * </pre>\n    */\n    toArray (): any[] {\n        const values = [];\n        for (const value of this.getContent().values) {\n            if (value !== undefined) {\n                values.push(value);\n            }\n        }\n        return values;\n    }\n\n    /**\n     * Retreive the index and values pairs from the dataframe as an array.\n     * Each pair is [index, value].\n     * This forces lazy evaluation to complete.\n     * \n     * @return Returns an array of pairs that contains the dataframe content. Each pair is a two element array that contains an index and a value.  \n     * \n     * @example\n     * <pre>\n     * const pairs = df.toPairs();\n     * </pre>\n     */\n    toPairs (): ([IndexT, ValueT])[] {\n        const pairs = [];\n        for (const pair of this.getContent().pairs) {\n            if (pair[1] != undefined) {\n                pairs.push(pair);\n            }\n        }\n        return pairs;\n    }\n\n    /**\n     * Convert the dataframe to a JavaScript object.\n     *\n     * @param keySelector Function that selects keys for the resulting object.\n     * @param valueSelector Function that selects values for the resulting object.\n     * \n     * @return Returns a JavaScript object generated from the dataframe by applying the key and value selector functions. \n     * \n     * @example\n     * <pre>\n     * \n     * const someObject = df.toObject(\n     *      row => row.SomeColumn, // Specify the column to use for fields in the object.\n     *      row => row.SomeOtherColumn // Specifi the column to use as the value for each field.\n     * );\n     * </pre>\n     */\n    toObject<KeyT = any, FieldT = any, OutT = any> (keySelector: (value: ValueT) => KeyT, valueSelector: (value: ValueT) => FieldT): OutT {\n\n        if (!isFunction(keySelector)) throw new Error(\"Expected 'keySelector' parameter to DataFrame.toObject to be a function.\");\n        if (!isFunction(valueSelector)) throw new Error(\"Expected 'valueSelector' parameter to DataFrame.toObject to be a function.\");\n\n        return toMap(this, keySelector, valueSelector);\n    }\n    \n    /**\n     * Bake the data frame to an array of rows were each rows is an array of values in column order.\n     * \n     * @return Returns an array of rows. Each row is an array of values in column order.\n     * \n     * @example\n     * <pre>\n     * const rows = df.toRows();\n     * </pre>\n     */\n    toRows (): any[][] {\n        const columnNames = this.getColumnNames();\n        const rows = [];\n        for (const value of this.getContent().values) {\n            const row = [];\n            for (let columnIndex = 0; columnIndex < columnNames.length; ++columnIndex) {\n                row.push((<any>value)[columnNames[columnIndex]]);\n            }\n\n            rows.push(row);\n        }\n        \n        return rows;\n    }\n\n    /**\n     * Generates a new dataframe by repeatedly calling a selector function on each row in the original dataframe.\n     *\n     * @param selector Selector function that transforms each row to create the new dataframe.\n     * \n     * @return Returns a new dataframe that has been transformed by the selector function.\n     * \n     * @example\n     * <pre>\n     * \n     * function transformRow (inputRow) {\n     *      const outputRow = {\n     *          // ... construct output row derived from input row ...\n     *      };\n     *\n     *      return outputRow;\n     * }\n     *  \n     * const modifiedDf = df.select(row => transformRow(row));\n     * </pre>\n     */\n    select<ToT> (selector: SelectorWithIndexFn<ValueT, ToT>): IDataFrame<IndexT, ToT> {\n        if (!isFunction(selector)) throw new Error(\"Expected 'selector' parameter to 'DataFrame.select' function to be a function.\");\n\n        return new DataFrame(() => {\n            const content = this.getContent();\n            return {\n                values: new SelectIterable<ValueT, ToT>(content.values, selector),\n                index: content.index,    \n            };\n        });\n    }\n\n    /**\n     * Generates a new dataframe by repeatedly calling a selector function on each row in the original dataframe.\n     * \n     * In this case the selector function produces a collection of output rows that are flattened to create the new dataframe.\n     *\n     * @param selector Selector function that transforms each row into a collection of output rows.\n     * \n     * @return  Returns a new dataframe with rows that have been produced by the selector function. \n     * \n     * @example\n     * <pre>\n     * \n     * function produceOutputRows (inputRow) {\n     *      const outputRows = [];\n     *      while (someCondition) {     *      \n     *          // ... generate zero or more output rows ...\n     *          outputRows.push(... some generated row ...);\n     *      }\n     *      return outputRows;\n     * }\n     * \n     * const modifiedDf = df.selectMany(row => produceOutputRows(row));\n     * </pre>\n     */\n    selectMany<ToT> (selector: SelectorWithIndexFn<ValueT, Iterable<ToT>>): IDataFrame<IndexT, ToT> {\n        if (!isFunction(selector)) throw new Error(\"Expected 'selector' parameter to 'DataFrame.selectMany' to be a function.\");\n\n        return new DataFrame(() => ({\n            pairs: new SelectManyIterable(\n                this.getContent().pairs, \n                (pair: [IndexT, ValueT], index: number): Iterable<[IndexT, ToT]> => {\n                    const outputPairs: [IndexT, ToT][] = [];\n                    for (const transformed of selector(pair[1], index)) {\n                        outputPairs.push([\n                            pair[0],\n                            transformed\n                        ]);\n                    }\n                    return outputPairs;\n                }\n            )\n        }));\n    }\n\n    /**\n     * Transform one or more columns. \n     * \n     * This is equivalent to extracting a {@link Series} with {@link getSeries}, then transforming it with {@link Series.select},\n     * and finally plugging it back in as the same column using {@link withSeries}.\n     *\n     * @param columnSelectors Object with field names for each column to be transformed. Each field specifies a selector function that transforms that column.\n     * \n     * @return Returns a new dataframe with 1 or more columns transformed.\n     * \n     * @example\n     * <pre>\n     * \n     * const modifiedDf = df.transformSeries({ \n     *      AColumnToTransform: columnValue => transformRow(columnValue) \n     * });\n     * </pre>\n     * \n     * @example\n     * <pre>\n     * \n     * const modifiedDf = df.transformSeries({ \n     *      ColumnA: columnValue => transformColumnA(columnValue),\n     *      ColumnB: columnValue => transformColumnB(columnValue)\n     * });\n     * </pre>\n     */\n    transformSeries<NewValueT = ValueT> (columnSelectors: IColumnTransformSpec): IDataFrame<IndexT, NewValueT> {\n\n        if (!isObject(columnSelectors)) throw new Error(\"Expected 'columnSelectors' parameter of 'DataFrame.transformSeries' function to be an object. Field names should specify columns to transform. Field values should be selector functions that specify the transformation for each column.\");\n\n        let working: IDataFrame<IndexT, any> = this;\n\n        for (const columnName of Object.keys(columnSelectors)) {\n            if (working.hasSeries(columnName)) {\n                working = working.withSeries(\n                    columnName, \n                    working.getSeries(columnName)\n                        .select(columnSelectors[columnName])\n                );\n            }\n        }\n\n        return working;\n    }\n\n    /** \n     * Generate new columns based on existing rows.\n     * \n     * This is equivalent to calling {@link select} to transform the original dataframe to a new dataframe with different column,\n     * then using {@link withSeries} to merge each the of both the new and original dataframes.\n     *\n     * @param generator Generator function that transforms each row to produce 1 or more new columns.\n     * Or use a column spec that has fields for each column, the fields specify a generate function that produces the value for each new column.\n     * \n     * @return Returns a new dataframe with 1 or more new columns.\n     * \n     * @example\n     * <pre>\n     * \n     * function produceNewColumns (inputRow) {\n     *      const newColumns = {\n     *          // ... specify new columns and their values based on the input row ...\n     *      };\n     * \n     *      return newColumns;\n     * };\n     * \n     * const dfWithNewSeries = df.generateSeries(row => produceNewColumns(row));\n     * </pre>\n     * \n     * @example\n     * <pre>\n     * \n     * const dfWithNewSeries = df.generateSeries({ \n     *      NewColumnA: row => produceNewColumnA(row),\n     *      NewColumnB: row => produceNewColumnB(row),\n     * })\n     * </pre>\n     */\n    generateSeries<NewValueT = ValueT> (generator: SelectorWithIndexFn<any, any> | IColumnTransformSpec): IDataFrame<IndexT, NewValueT> {\n\n        if (!isObject(generator)) {\n            if (!isFunction(generator)) {\n                throw new Error(\"Expected 'generator' parameter to 'DataFrame.generateSeries' function to be a function or an object.\");\n            }\n\n            const selector = generator as SelectorWithIndexFn<any, any>;\n            const newColumns = this.select(selector) // Build a new dataframe.\n                .bake(); //TODO: Bake should be needed here, but it causes problems if not.\n            const newColumnNames = newColumns.getColumnNames(); \n\n            let working: IDataFrame<IndexT, any> = this;\n \n            //TODO: There must be a cheaper implementation!\n            for (const newColumnName of newColumnNames) {\n                working = working.withSeries(newColumnName, newColumns.getSeries(newColumnName));\n            }\n\n            return working;\n        }\n        else {\n            const columnTransformSpec = generator as IColumnTransformSpec;\n            const newColumnNames = Object.keys(columnTransformSpec);\n            \n            let working: IDataFrame<IndexT, any> = this;\n\n            for (const newColumnName of newColumnNames) {\n                working = working.withSeries(newColumnName, working.select(columnTransformSpec[newColumnName]).deflate());\n            }\n\n            return working;\n        }\n    }    \n\n    /** \n     * Converts (deflates) a dataframe to a {@link Series}.\n     *\n     * @param [selector] Optional selector function that transforms each row to produce the series.\n     *\n     * @return Returns a series that was created from the deflated from  the original dataframe.\n     * \n     * @example\n     * <pre>\n     * \n     * const series = df.deflate(); // Deflate to a series of object.\n     * </pre>\n     * \n     * @example\n     * <pre>\n     * \n     * const series = df.deflate(row => row.SomeColumn); // Extract a particular column.\n     * </pre>\n     */\n    deflate<ToT = ValueT> (selector?: SelectorWithIndexFn<ValueT, ToT>): ISeries<IndexT, ToT> {\n\n        if (selector) {\n            if (!isFunction(selector)) throw new Error(\"Expected 'selector' parameter to 'DataFrame.deflate' function to be a selector function.\");\n        }\n\n        return new Series<IndexT, ToT>(() => { \n            const content = this.getContent();\n            if (selector) {\n                return {\n                    index: content.index,\n                    values: new SelectIterable<ValueT, ToT>(content.values, selector),\n                    pairs: new SelectIterable<[IndexT, ValueT], [IndexT, ToT]>(content.pairs, (pair, index) => {\n                        return [\n                            pair[0],\n                            selector(pair[1], index)\n                        ];\n                    }),    \n                };\n            }\n            else {\n                return {\n                    index: content.index,\n                    values: content.values as any as Iterable<ToT>,\n                    pairs: content.pairs as any as Iterable<[IndexT, ToT]>,\n                };\n            }\n        });\n    };\n\n    /** \n     * Inflate a named {@link Series} in the dataframe to 1 or more new series in the new dataframe.\n     * \n     * This is the equivalent of extracting the series using {@link getSeries}, transforming them with {@link Series.select}\n     * and then running {@link Series.inflate} to create a new dataframe, then merging each column of the new dataframe\n     *  into the original dataframe using {@link withSeries}.\n     *\n     * @param columnName Name of the series to inflate.\n     * @param [selector] Optional selector function that transforms each value in the column to new columns. If not specified it is expected that each value in the column is an object whose fields define the new column names.\n     * \n     * @return Returns a new dataframe with a column inflated to 1 or more new columns.\n     * \n     * @example\n     * <pre>\n     * \n     * function newColumnGenerator (row) {\n     *      const newColumns = {\n     *          // ... create 1 field per new column ...\n     *      };\n     * \n     *      return row;\n     * }\n     * \n     * const dfWithNewSeries = df.inflateSeries(\"SomeColumn\", newColumnGenerator);\n     * </pre>\n     */\n    inflateSeries<NewValueT = ValueT> (columnName: string, selector?: SelectorWithIndexFn<IndexT, any>): IDataFrame<IndexT, ValueT> {\n\n        if (!isString(columnName)) throw new Error(\"Expected 'columnName' parameter to 'DataFrame.inflateSeries' to be a string that is the name of the column to inflate.\");\n\n        if (selector) {\n            if (!isFunction(selector)) throw new Error(\"Expected optional 'selector' parameter to 'DataFrame.inflateSeries' to be a selector function, if it is specified.\");\n        }\n\n        return this.zip(\n            this.getSeries(columnName).inflate(selector),\n            (row1, row2) => Object.assign({}, row1, row2) //todo: this be should zip's default operation.\n        );\n    }\n\n    /**\n     * Partition a dataframe into a {@link Series} of *data windows*. \n     * Each value in the new series is a rolling chunk of data from the original dataframe.\n     *\n     * @param period The number of data rows to include in each data window.\n     * \n     * @return Returns a new series, each value of which is a chunk of the original dataframe.\n     * \n     * @example\n     * <pre>\n     * \n     * const windows = df.window(2); // Get values in pairs.\n     * const pctIncrease = windows.select(pair => (pair.last() - pair.first()) / pair.first());\n     * console.log(pctIncrease.toString());\n     * </pre>\n     * \n     * @example\n     * <pre>\n     * \n     * const salesDf = ... // Daily sales data.\n     * const weeklySales = salesDf.window(7); // Partition up into weekly data sets.\n     * console.log(weeklySales.toString());\n     * </pre>\n     */\n    window (period: number): ISeries<number, IDataFrame<IndexT, ValueT>> {\n\n        if (!isNumber(period)) throw new Error(\"Expected 'period' parameter to 'DataFrame.window' to be a number.\");\n\n        return new Series<number, IDataFrame<IndexT, ValueT>>(() => {\n            const content = this.getContent();\n            return {\n                values: new DataFrameWindowIterable<IndexT, ValueT>(content.columnNames, content.pairs, period)\n            };            \n        });\n    }\n\n    /** \n     * Partition a dataframe into a {@link Series} of *rolling data windows*. \n     * Each value in the new series is a rolling chunk of data from the original dataframe.\n     *\n     * @param period The number of data rows to include in each data window.\n     * \n     * @return Returns a new series, each value of which is a rolling chunk of the original dataframe.\n     * \n     * @example\n     * <pre>\n     * \n     * const salesDf = ... // Daily sales data.\n     * const rollingWeeklySales = salesDf.rollingWindow(7); // Get rolling window over weekly sales data.\n     * console.log(rollingWeeklySales.toString());\n     * </pre>\n     */\n    rollingWindow (period: number): ISeries<number, IDataFrame<IndexT, ValueT>> {\n\n        if (!isNumber(period)) throw new Error(\"Expected 'period' parameter to 'DataFrame.rollingWindow' to be a number.\");\n\n        return new Series<number, IDataFrame<IndexT, ValueT>>(() => {\n            const content = this.getContent();\n            return {\n                values: new DataFrameRollingWindowIterable<IndexT, ValueT>(content.columnNames, content.pairs, period)\n            };            \n        });\n    }\n\n    /**\n     * Partition a dataframe into a {@link Series} of variable-length *data windows* \n     * where the divisions between the data chunks are\n     * defined by a user-provided *comparer* function.\n     * \n     * @param comparer Function that compares two adjacent data rows and returns true if they should be in the same window.\n     * \n     * @return Returns a new series, each value of which is a chunk of data from the original dataframe.\n     * \n     * @example\n     * <pre>\n     * \n     * function rowComparer (rowA, rowB) {\n     *      if (... rowA should be in the same data window as rowB ...) {\n     *          return true;\n     *      }\n     *      else {\n     *          return false;\n     *      }\n     * };\n     * \n     * const variableWindows = df.variableWindow(rowComparer);\n     */\n    variableWindow (comparer: ComparerFn<ValueT, ValueT>): ISeries<number, IDataFrame<IndexT, ValueT>> {\n        \n        if (!isFunction(comparer)) throw new Error(\"Expected 'comparer' parameter to 'DataFrame.variableWindow' to be a function.\")\n\n        return new Series<number, IDataFrame<IndexT, ValueT>>(() => {\n            const content = this.getContent();\n            return {\n                values: new DataFrameVariableWindowIterable<IndexT, ValueT>(content.columnNames, content.pairs, comparer)\n            };            \n        });\n    }\n\n    /**\n     * Eliminates adjacent duplicate rows.\n     * \n     * For each group of adjacent rows that are equivalent only returns the last index/row for the group, \n     * thus ajacent equivalent rows are collapsed down to the last row.\n     *\n     * @param [selector] Optional selector function to determine the value used to compare for equivalence.\n     * \n     * @return Returns a new dataframe with groups of adjacent duplicate rows collapsed to a single row per group.\n     * \n     * @example\n     * <pre>\n     * \n     * const dfWithDuplicateRowsRemoved = df.sequentialDistinct(row => row.ColumnA);\n     * </pre>\n     */\n    sequentialDistinct<ToT = ValueT> (selector?: SelectorFn<ValueT, ToT>): IDataFrame<IndexT, ValueT> {\n        \n        if (selector) {\n            if (!isFunction(selector)) throw new Error(\"Expected 'selector' parameter to 'DataFrame.sequentialDistinct' to be a selector function that determines the value to compare for duplicates.\")\n        }\n        else {\n            selector = (value: ValueT): ToT => <ToT> <any> value;\n        }\n\n        return this.variableWindow((a, b) => selector!(a) === selector!(b))\n            .select((window): [IndexT, ValueT] => {\n                return [window.getIndex().first(), window.first()];\n            })\n            .withIndex(pair => pair[0])\n            .inflate(pair => pair[1]); //TODO: Should this be select?\n    }\n\n    /**\n     * Aggregate the rows in the dataframe to a single result.\n     *\n     * @param [seed] Optional seed value for producing the aggregation.\n     * @param selector Function that takes the seed and then each row in the dataframe and produces the aggregated value.\n     * \n     * @return Returns a new value that has been aggregated from the dataframe using the 'selector' function. \n     * \n     * @example\n     * <pre>\n     * \n     * const dailySalesDf = ... daily sales figures for the past month ...\n     * const totalSalesForthisMonth = dailySalesDf.aggregate(\n     *      0, // Seed - the starting value.\n     *      (accumulator, row) => accumulator + row.SalesAmount // Aggregation function.\n     * );\n     * </pre>\n     * \n     * @example\n     * <pre>\n     * \n     * const totalSalesAllTime = 500; // We'll seed the aggregation with this value.\n     * const dailySalesDf = ... daily sales figures for the past month ...\n     * const updatedTotalSalesAllTime = dailySalesDf.aggregate(\n     *      totalSalesAllTime, \n     *      (accumulator, row) => accumulator + row.SalesAmount\n     * );\n     * </pre>\n     * \n     * @example\n     * <pre>\n     * \n     * var salesDataSummary = salesDataDf.aggregate({\n     *      TotalSales: df => df.count(),\n     *      AveragePrice: df => df.deflate(row => row.Price).average(),\n     *      TotalRevenue: df => df.deflate(row => row.Revenue).sum(), \n     * });\n     * </pre>\n    */\n    aggregate<ToT = ValueT> (seedOrSelector: AggregateFn<ValueT, ToT> | ToT | IColumnAggregateSpec, selector?: AggregateFn<ValueT, ToT>): ToT {\n\n        if (isFunction(seedOrSelector) && !selector) {\n            return this.skip(1).aggregate(<ToT> <any> this.first(), seedOrSelector);\n        }\n        else if (selector) {\n            if (!isFunction(selector)) throw new Error(\"Expected 'selector' parameter to aggregate to be a function.\");\n\n            let accum = <ToT> seedOrSelector;\n\n            for (const value of this) {\n                accum = selector!(accum, value);                \n            }\n\n            return accum;\n        }\n        else {\n            //\n            //TODO:\n            // This approach is fairly limited because I can't provide a seed.\n            // Consider removing this and replacing it with a 'summarize' function.\n            //\n            if (!isObject(seedOrSelector)) throw new Error(\"Expected 'seed' parameter to aggregate to be an object.\");\n\n            const columnAggregateSpec = seedOrSelector as IColumnAggregateSpec;\n            const columnNames = Object.keys(columnAggregateSpec);\n            const aggregatedColumns = columnNames.map(columnName => {\n                var columnSelector = columnAggregateSpec[columnName];\n                if (!isFunction(columnSelector)) throw new Error(\"Expected column/selector pairs in 'seed' parameter to aggregate.\");\n                return [columnName, this.getSeries(columnName).aggregate(columnSelector)];\n            });\n\n            return toMap(aggregatedColumns, pair => pair[0], pair => pair[1]);\n        }\n    }\n    \n    /**\n     * Skip a number of rows in the dataframe.\n     *\n     * @param numValues Number of rows to skip.\n     * \n     * @return Returns a new dataframe with the specified number of rows skipped. \n     * \n     * @example\n     * <pre>\n     * \n     * const dfWithRowsSkipped = df.skip(10); // Skip 10 rows in the original dataframe.\n     * </pre>\n     */\n    skip (numValues: number): IDataFrame<IndexT, ValueT> {\n        if (!isNumber(numValues)) throw new Error(\"Expected 'numValues' parameter to 'DataFrame.skip' to be a number.\");\n\n        return new DataFrame<IndexT, ValueT>(() => {\n            const content = this.getContent();\n            return {\n                columnNames: content.columnNames,\n                values: new SkipIterable(content.values, numValues),\n                index: new SkipIterable(content.index, numValues),\n                pairs: new SkipIterable(content.pairs, numValues),\n            };\n        });\n    }\n\n    /**\n     * Skips rows in the dataframe while a condition evaluates to true or truthy.\n     *\n     * @param predicate Returns true/truthy to continue to skip rows in the original dataframe.\n     * \n     * @return Returns a new dataframe with all initial sequential rows removed while the predicate returned true/truthy.\n     * \n     * @example\n     * <pre>\n     * \n     * const dfWithRowsSkipped = df.skipWhile(row => row.CustomerName === \"Fred\"); // Skip initial customers named Fred.\n     * </pre>\n     */\n    skipWhile (predicate: PredicateFn<ValueT>): IDataFrame<IndexT, ValueT> {\n        if (!isFunction(predicate)) throw new Error(\"Expected 'predicate' parameter to 'DataFrame.skipWhile' function to be a predicate function that returns true/false.\");\n\n        return new DataFrame<IndexT, ValueT>(() => {\n            const content = this.getContent();\n            return {\n                columnNames: content.columnNames,\n                values: new SkipWhileIterable(content.values, predicate),\n                pairs: new SkipWhileIterable(content.pairs, pair => predicate(pair[1])),\n            };\n        });\n    }\n\n    /**\n     * Skips rows in the dataframe untils a condition evaluates to true or truthy.\n     *\n     * @param predicate Return true/truthy to stop skipping rows in the original dataframe.\n     * \n     * @return Returns a new dataframe with all initial sequential rows removed until the predicate returned true/truthy.\n     * \n     * @example\n     * <pre>\n     * \n     * const dfWithRowsSkipped = df.skipUntil(row => row.CustomerName === \"Fred\"); // Skip initial customers until we find Fred.\n     * </pre>\n     */\n    skipUntil (predicate: PredicateFn<ValueT>): IDataFrame<IndexT, ValueT> {\n        if (!isFunction(predicate)) throw new Error(\"Expected 'predicate' parameter to 'DataFrame.skipUntil' function to be a predicate function that returns true/false.\");\n\n        return this.skipWhile(value => !predicate(value)); \n    }\n\n    /**\n     * Take a number of rows from the dataframe.\n     *\n     * @param numValues Number of rows to take.\n     * \n     * @return Returns a new dataframe with only the specified number of rows taken from the original dataframe.\n     * \n     * @example\n     * <pre>\n     * \n     * const dfWithRowsTaken = df.take(15); // Take only the first 15 rows from the original dataframe.\n     * </pre>\n     */\n    take (numRows: number): IDataFrame<IndexT, ValueT> {\n        if (!isNumber(numRows)) throw new Error(\"Expected 'numRows' parameter to 'DataFrame.take' function to be a number.\");\n\n        return new DataFrame<IndexT, ValueT>(() => {\n            const content = this.getContent();\n            return {\n                columnNames: content.columnNames,\n                index: new TakeIterable(content.index, numRows),\n                values: new TakeIterable(content.values, numRows),\n                pairs: new TakeIterable(content.pairs, numRows)\n            };\n        });\n    };\n\n    /**\n     * Takes rows from the dataframe while a condition evaluates to true or truthy.\n     *\n     * @param predicate Returns true/truthy to continue to take rows from the original dataframe.\n     * \n     * @return Returns a new dataframe with only the initial sequential rows that were taken while the predicate returned true/truthy.\n     * \n     * @example\n     * <pre>\n     * \n     * const dfWithRowsTaken = df.takeWhile(row => row.CustomerName === \"Fred\"); // Take only initial customers named Fred.\n     * </pre>\n     */\n    takeWhile (predicate: PredicateFn<ValueT>): IDataFrame<IndexT, ValueT> {\n        if (!isFunction(predicate)) throw new Error(\"Expected 'predicate' parameter to 'DataFrame.takeWhile' function to be a predicate function that returns true/false.\");\n\n        return new DataFrame<IndexT, ValueT>(() => {\n            const content = this.getContent();\n            return {\n                columnNames: content.columnNames,\n                values: new TakeWhileIterable(content.values, predicate),\n                pairs: new TakeWhileIterable(content.pairs, pair => predicate(pair[1]))\n            };\n        });\n    }\n\n    /**\n     * Takes rows from the dataframe untils a condition evaluates to true or truthy.\n     *\n     * @param predicate Return true/truthy to stop taking rows in the original dataframe.\n     * \n     * @return Returns a new dataframe with only the initial sequential rows taken until the predicate returned true/truthy.\n     * \n     * @example\n     * <pre>\n     * \n     * const dfWithRowsTaken = df.takeUntil(row => row.CustomerName === \"Fred\"); // Take all initial customers until we find Fred.\n     * </pre>\n     */\n    takeUntil (predicate: PredicateFn<ValueT>): IDataFrame<IndexT, ValueT> {\n        if (!isFunction(predicate)) throw new Error(\"Expected 'predicate' parameter to 'DataFrame.takeUntil' function to be a predicate function that returns true/false.\");\n\n        return this.takeWhile(value => !predicate(value));\n    }\n\n    /**\n     * Count the number of rows in the dataframe\n     *\n     * @return Returns the count of all rows.\n     * \n     * @example\n     * <pre>\n     * \n     * const numRows = df.count();\n     * </pre>\n     */\n    count (): number {\n\n        let total = 0;\n        for (const value of this.getContent().values) {\n            ++total;\n        }\n        return total;\n    }\n\n    /**\n     * Get the first row of the dataframe.\n     *\n     * @return Returns the first row of the dataframe.\n     * \n     * @example\n     * <pre>\n     * \n     * const firstRow = df.first();\n     * </pre>\n     */\n    first (): ValueT {\n\n        for (const value of this) {\n            return value; // Only need the first value.\n        }\n\n        throw new Error(\"DataFrame.first: No values in DataFrame.\");\n    }\n\n    /**\n     * Get the last row of the dataframe.\n     *\n     * @return Returns the last row of the dataframe.\n     * \n     * @example\n     * <pre>\n     * \n     * const lastRow = df.last();\n     * </pre>\n     */\n    last (): ValueT {\n\n        let lastValue = null;\n\n        for (const value of this) {\n            lastValue = value; // Throw away all values until we get to the last one.\n        }\n\n        if (lastValue === null) {\n            throw new Error(\"DataFrame.last: No values in DataFrame.\");\n        }\n\n        return lastValue;\n    }    \n    \n    /**\n     * Get the row, if there is one, with the specified index.\n     *\n     * @param index Index to for which to retreive the row.\n     *\n     * @return Returns the row from the specified index in the dataframe or undefined if there is no such index in the present in the dataframe.\n     * \n     * @example\n     * <pre>\n     * \n     * const row = df.at(5); // Get the row at index 5 (with a default 0-based index).\n     * </pre>\n     * \n     * @example\n     * <pre>\n     * \n     * const date = ... some date ...\n     * // Retreive the row with specified date from a time-series dataframe (assuming date indexed has been applied).\n     * const row = df.at(date); \n     * </pre>\n     */\n    at (index: IndexT): ValueT | undefined {\n\n        if (this.none()) {\n            return undefined;\n        }\n\n        //\n        // This is pretty expensive.\n        // A specialised index could improve this.\n        //\n\n        for (const pair of this.getContent().pairs) {\n            if (pair[0] === index) {\n                return pair[1];\n            }\n        }\n\n        return undefined;\n    }\n    \n    /** \n     * Get X rows from the start of the dataframe.\n     * Pass in a negative value to get all rows at the head except for X rows at the tail.\n     *\n     * @param numValues Number of rows to take.\n     * \n     * @return Returns a new dataframe that has only the specified number of rows taken from the start of the original dataframe.  \n     * \n     * @examples\n     * <pre>\n     * \n     * const sample = df.head(10); // Take a sample of 10 rows from the start of the dataframe.\n     * </pre>\n     */\n    head (numValues: number): IDataFrame<IndexT, ValueT> {\n\n        if (!isNumber(numValues)) throw new Error(\"Expected 'numValues' parameter to 'DataFrame.head' function to be a number.\");\n\n        if (numValues === 0) {\n            return new DataFrame<IndexT, ValueT>(); // Empty dataframe.\n        }\n\n        const toTake = numValues < 0 ? this.count() - Math.abs(numValues) : numValues;\n        return this.take(toTake);\n    }\n\n    /** \n     * Get X rows from the end of the dataframe.\n     * Pass in a negative value to get all rows at the tail except X rows at the head.\n     *\n     * @param numValues Number of rows to take.\n     * \n     * @return Returns a new dataframe that has only the specified number of rows taken from the end of the original dataframe.  \n     * \n     * @examples\n     * <pre>\n     * \n     * const sample = df.tail(12); // Take a sample of 12 rows from the end of the dataframe.\n     * </pre>\n     */\n    tail (numValues: number): IDataFrame<IndexT, ValueT> {\n\n        if (!isNumber(numValues)) throw new Error(\"Expected 'numValues' parameter to 'DataFrame.tail' function to be a number.\");\n\n        if (numValues === 0) {\n            return new DataFrame<IndexT, ValueT>(); // Empty dataframe.\n        }\n\n        const toSkip = numValues > 0 ? this.count() - numValues : Math.abs(numValues);\n        return this.skip(toSkip);\n    }\n\n    /**\n     * Filter the dataframe using user-defined predicate function.\n     *\n     * @param predicate Predicte function to filter rows from the dataframe. Returns true/truthy to keep rows, or false/falsy to omit rows.\n     * \n     * @return Returns a new dataframe containing only the rows from the original dataframe that matched the predicate. \n     * \n     * @example\n     * <pre>\n     * \n     * const filteredDf = df.where(row => row.CustomerName === \"Fred\"); // Filter so we only have customers named Fred.\n     * </pre>\n     */\n    where (predicate: PredicateFn<ValueT>): IDataFrame<IndexT, ValueT> {\n\n        if (!isFunction(predicate)) throw new Error(\"Expected 'predicate' parameter to 'DataFrame.where' function to be a function.\");\n\n        return new DataFrame<IndexT, ValueT>(() => {\n            const content = this.getContent();\n            return {\n                columnNames: content.columnNames,\n                values: new WhereIterable(content.values, predicate),\n                pairs: new WhereIterable(content.pairs, pair => predicate(pair[1]))\n            };\n        });\n    }\n\n    /**\n     * Invoke a callback function for each row in the dataframe.\n     *\n     * @param callback The calback function to invoke for each row.\n     * \n     * @return Returns the original dataframe with no modifications.\n     * \n     * @example\n     * <pre>\n     * \n     * df.forEach(row => {\n     *      // ... do something with the row ...\n     * });\n     * </pre>\n     */\n    forEach (callback: CallbackFn<ValueT>): IDataFrame<IndexT, ValueT> {\n        if (!isFunction(callback)) throw new Error(\"Expected 'callback' parameter to 'DataFrame.forEach' to be a function.\");\n\n        let index = 0;\n        for (const value of this) {\n            callback(value, index++);\n        }\n\n        return this;\n    }\n\n    /**\n     * Evaluates a predicate function for every row in the dataframe to determine \n     * if some condition is true/truthy for **all** rows in the dataframe.\n     * \n     * @param predicate Predicate function that receives each row. It should returns true/truthy for a match, otherwise false/falsy.\n     *\n     * @return Returns true if the predicate has returned true or truthy for every row in the dataframe, otherwise returns false. Returns false for an empty dataframe. \n     * \n     * @example\n     * <pre>\n     * \n     * const everyoneIsNamedFred = df.all(row => row.CustomerName === \"Fred\"); // Check if all customers are named Fred.\n     * </pre>\n     */\n    all (predicate: PredicateFn<ValueT>): boolean {\n        if (!isFunction(predicate)) throw new Error(\"Expected 'predicate' parameter to 'DataFrame.all' to be a function.\")\n\n        let count = 0;\n\n        for (const value of this) {\n            if (!predicate(value)) {\n                return false;\n            }\n\n            ++count;\n        }\n\n        return count > 0;\n    }\n\n    /**\n     * Evaluates a predicate function for every row in the dataframe to determine \n     * if some condition is true/truthy for **any** of rows in the dataframe.\n     * \n     * If no predicate is specified then it simply checks if the dataframe contains more than zero rows.\n     *\n     * @param [predicate] Optional predicate function that receives each row. It should return true/truthy for a match, otherwise false/falsy.\n     *\n     * @return Returns true if the predicate has returned truthy for any row in the dataframe, otherwise returns false. \n     * If no predicate is passed it returns true if the dataframe contains any rows at all. \n     * Returns false for an empty dataframe.\n     * \n     * @example\n     * <pre>\n     * \n     * const anyFreds = df.any(row => row.CustomerName === \"Fred\"); // Do we have any customers named Fred?\n     * </pre>\n     * \n     * @example\n     * <pre>\n     * \n     * const anyCustomers = df.any(); // Do we have any customers at all?\n     * </pre>\n     */\n    any (predicate?: PredicateFn<ValueT>): boolean {\n        if (predicate) {\n            if (!isFunction(predicate)) throw new Error(\"Expected optional 'predicate' parameter to 'DataFrame.any' to be a function.\")\n        }\n\n        if (predicate) {\n            // Use the predicate to check each value.\n            for (const value of this) {\n                if (predicate(value)) {\n                    return true;\n                }\n            }\n        }\n        else {\n            // Just check if there is at least one item.\n            const iterator = this[Symbol.iterator]()\n            return !iterator.next().done;\n        }\n\n        return false; // Nothing passed.\n    }\n\n    /**\n     * Evaluates a predicate function for every row in the dataframe to determine \n     * if some condition is true/truthy for **none** of rows in the dataframe.\n     * \n     * If no predicate is specified then it simply checks if the dataframe contains zero rows.\n     *\n     * @param [predicate] Optional predicate function that receives each row. It should return true/truthy for a match, otherwise false/falsy.\n     *\n     * @return Returns true if the predicate has returned truthy for zero rows in the dataframe, otherwise returns false. Returns false for an empty dataframe.\n     * \n     * @example\n     * <pre>\n     * \n     * const noFreds = df.none(row => row.CustomerName === \"Fred\"); // Do we have zero customers named Fred?\n     * </pre>\n     * \n     * @example\n     * <pre>\n     * \n     * const noCustomers = df.none(); // Do we have zero customers?\n     * </pre>\n     */\n    none (predicate?: PredicateFn<ValueT>): boolean {\n\n        if (predicate) {\n            if (!isFunction(predicate)) throw new Error(\"Expected 'predicate' parameter to 'DataFrame.none' to be a function.\")\n        }\n\n        if (predicate) {\n            // Use the predicate to check each value.\n            for (const value of this) {\n                if (predicate(value)) {\n                    return false;\n                }\n            }\n        }\n        else {\n            // Just check if empty.\n            const iterator = this[Symbol.iterator]()\n            return iterator.next().done;\n        }\n\n        return true; // Nothing failed the predicate.\n    }\n\n    //TODO: Improve this example (and subsequent examples, they look like series setup rather than dataframe)..\n    /**\n     * Gets a new dataframe containing all rows starting at or after the specified index value.\n     * \n     * @param indexValue The index value at which to start the new dataframe.\n     * \n     * @return Returns a new dataframe containing all rows starting at or after the specified index value. \n     * \n     * @example\n     * <pre>\n     * \n     * const df = new DataFrame({ \n     *      index: [0, 1, 2, 3], // This is the default index.\n     *      values: [10, 20, 30, 40],\n     * });\n     * \n     * const lastHalf = df.startAt(2);\n     * expect(lastHalf.toArray()).to.eql([30, 40]);\n     * </pre>\n     * \n     * @example\n     * <pre>\n     * \n     * const timeSeriesDf = ... a dataframe indexed by date/time ...\n     * \n     * // Get all rows starting at (or after) a particular date.\n     * const result = timeSeriesDf.startAt(new Date(2016, 5, 4)); \n     * </pre>\n     */\n    startAt (indexValue: IndexT): IDataFrame<IndexT, ValueT> {\n\n        return new DataFrame<IndexT, ValueT>(() => {\n            const content = this.getContent();\n            const lessThan = this.getIndex().getLessThan();\n            return {                \n                columnNames: content.columnNames,\n                index: new SkipWhileIterable(content.index, index => lessThan(index, indexValue)),\n                pairs: new SkipWhileIterable(content.pairs, pair => lessThan(pair[0], indexValue)),\n            };\n        });\n    }\n\n    /**\n     * Gets a new dataframe containing all rows up until and including the specified index value (inclusive).\n     * \n     * @param indexValue The index value at which to end the new dataframe.\n     * \n     * @return Returns a new dataframe containing all rows up until and including the specified index value.\n     * \n     * @example\n     * <pre>\n     * \n     * const df = new DataFrame({ \n     *      index: [0, 1, 2, 3], // This is the default index.\n     *      values: [10, 20, 30, 40],\n     * });\n     * \n     * const firstHalf = df.endAt(1);\n     * expect(firstHalf.toArray()).to.eql([10, 20]);\n     * </pre>\n     * \n     * @example\n     * <pre>\n     * \n     * const timeSeriesDf = ... a dataframe indexed by date/time ...\n     * \n     * // Get all rows ending at a particular date.\n     * const result = timeSeriesDf.endAt(new Date(2016, 5, 4)); \n     * </pre>\n     */\n    endAt (indexValue: IndexT): IDataFrame<IndexT, ValueT> {\n\n        return new DataFrame<IndexT, ValueT>(() => {\n            const content = this.getContent();\n            const lessThanOrEqualTo = this.getIndex().getLessThanOrEqualTo();\n            return {\n                columnNames: content.columnNames,\n                index: new TakeWhileIterable(content.index, index => lessThanOrEqualTo(index, indexValue)),\n                pairs: new TakeWhileIterable(content.pairs, pair => lessThanOrEqualTo(pair[0], indexValue)),\n            };\n        });\n    }\n\n    /**\n     * Gets a new dataframe containing all rows up to the specified index value (exclusive).\n     * \n     * @param indexValue The index value at which to end the new dataframe.\n     * \n     * @return Returns a new dataframe containing all rows up to (but not including) the specified index value. \n     * \n     * @example\n     * <pre>\n     * \n     * const df = new DataFrame({ \n     *      index: [0, 1, 2, 3], // This is the default index.\n     *      values: [10, 20, 30, 40],\n     * });\n     * \n     * const firstHalf = df.before(2);\n     * expect(firstHalf.toArray()).to.eql([10, 20]);\n     * </pre>\n     * \n     * @example\n     * <pre>\n     * \n     * const timeSeriesDf = ... a dataframe indexed by date/time ...\n     * \n     * // Get all rows before the specified date.\n     * const result = timeSeriesDf.before(new Date(2016, 5, 4)); \n     * </pre>\n     */\n    before (indexValue: IndexT): IDataFrame<IndexT, ValueT> {\n\n        return new DataFrame<IndexT, ValueT>(() => {\n            const content = this.getContent();\n            const lessThan = this.getIndex().getLessThan();\n            return {\n                columnNames: content.columnNames,\n                index: new TakeWhileIterable(content.index, index => lessThan(index, indexValue)),\n                pairs: new TakeWhileIterable(content.pairs, pair => lessThan(pair[0], indexValue)),\n            };\n        });\n    }\n\n    /**\n     * Gets a new dataframe containing all rows after the specified index value (exclusive).\n     * \n     * @param indexValue The index value after which to start the new dataframe.\n     * \n     * @return Returns a new dataframe containing all rows after the specified index value.\n     * \n     * @example\n     * <pre>\n     * \n     * const df = new DataFrame({ \n     *      index: [0, 1, 2, 3], // This is the default index.\n     *      values: [10, 20, 30, 40],\n     * });\n     * \n     * const lastHalf = df.before(1);\n     * expect(lastHalf.toArray()).to.eql([30, 40]);\n     * </pre>\n     * \n     * @example\n     * <pre>\n     * \n     * const timeSeriesDf = ... a dataframe indexed by date/time ...\n     * \n     * // Get all rows after the specified date.\n     * const result = timeSeriesDf.after(new Date(2016, 5, 4)); \n     * </pre>\n     */\n    after (indexValue: IndexT): IDataFrame<IndexT, ValueT> {\n        return new DataFrame<IndexT, ValueT>(() => {\n            const content = this.getContent();\n            const lessThanOrEqualTo = this.getIndex().getLessThanOrEqualTo();\n            return {\n                columnNames: content.columnNames,\n                index: new SkipWhileIterable(content.index, index => lessThanOrEqualTo(index, indexValue)),\n                pairs: new SkipWhileIterable(content.pairs, pair => lessThanOrEqualTo(pair[0], indexValue)),\n            };\n        });\n    }\n\n    /**\n     * Gets a new dataframe containing all rows between the specified index values (inclusive).\n     * \n     * @param startIndexValue The index at which to start the new dataframe.\n     * @param endIndexValue The index at which to end the new dataframe.\n     * \n     * @return Returns a new dataframe containing all values between the specified index values (inclusive).\n     * \n     * @example\n     * <pre>\n     * \n     * const df = new DataFrame({ \n     *      index: [0, 1, 2, 3, 4, 6], // This is the default index.\n     *      values: [10, 20, 30, 40, 50, 60],\n     * });\n     * \n     * const middleSection = df.between(1, 4);\n     * expect(middleSection.toArray()).to.eql([20, 30, 40, 50]);\n     * </pre>\n     * \n     * @example\n     * <pre>\n     * \n     * const timeSeriesDf = ... a dataframe indexed by date/time ...\n     * \n     * // Get all rows between the start and end dates (inclusive).\n     * const result = timeSeriesDf.after(new Date(2016, 5, 4), new Date(2016, 5, 22)); \n     * </pre>\n     */\n    between (startIndexValue: IndexT, endIndexValue: IndexT): IDataFrame<IndexT, ValueT> {\n        return this.startAt(startIndexValue).endAt(endIndexValue); \n    }\n\n    /** \n     * Format the dataframe for display as a string.\n     * This forces lazy evaluation to complete.\n     * \n     * @return Generates and returns a string representation of the dataframe.\n     * \n     * @example\n     * <pre>\n     * \n     * console.log(df.toString());\n     * </pre>\n     */\n    toString (): string {\n\n        const columnNames = this.getColumnNames();\n        const header = [\"__index__\"].concat(columnNames);\n\n        const table = new Table();\n        //TODO: for (const pair of this.asPairs()) {\n        for (const pair of this.toPairs()) {\n            const index = pair[0];\n            const value = pair[1] as any;\n            table.cell(header[0], index);\n            for (let columnIndex = 0; columnIndex < columnNames.length; ++columnIndex) {\n                const columnName = columnNames[columnIndex];\n                table.cell(header[columnIndex+1], value[columnName]);\n            }\n            table.newRow();\n        }\n\n        return table.toString();\n    }\n\n    /**\n     * Parse a column with string values and convert it to a column with int values.\n     *\n     * @param columnNameOrNames Specifies the column name or array of column names to parse.\n     * \n     * @return Returns a new dataframe with values of particular named column(s) parsed from strings to ints.\n     * \n     * @example\n     * <pre>\n     * \n     * const parsed = df.parseInts(\"MyIntColumn\");\n     * </pre>\n     * \n     * @example\n     * <pre>\n     * \n     * const parsed = df.parseInts([\"MyIntColumnA\", \"MyIntColumnA\"]);\n     * </pre>\n     */\n    parseInts (columnNameOrNames: string | string[]): IDataFrame<IndexT, ValueT> {\n\n        if (isArray(columnNameOrNames)) {\n            let working: IDataFrame<IndexT, ValueT> = this;\n            for (const columnName of columnNameOrNames) {\n                working = working.parseInts(columnName);\n            }\n            \n            return working;\n        }\n        else {\n            return this.withSeries(columnNameOrNames, this.getSeries(columnNameOrNames).parseInts());\n        }\n    }\n\n    /**\n     * Parse a column with string values and convert it to a column with float values.\n     *\n     * @param columnNameOrNames Specifies the column name or array of column names to parse.\n     * \n     * @return Returns a new dataframe with values of particular named column(s) parsed from strings to floats.\n     * \n     * @example\n     * <pre>\n     * \n     * const parsed = df.parseFloats(\"MyFloatColumn\");\n     * </pre>\n     * \n     * @example\n     * <pre>\n     * \n     * const parsed = df.parseFloats([\"MyFloatColumnA\", \"MyFloatColumnA\"]);\n     * </pre>\n     */\n    parseFloats (columnNameOrNames: string | string[]): IDataFrame<IndexT, ValueT> {\n\n        if (isArray(columnNameOrNames)) {\n            let working: IDataFrame<IndexT, ValueT> = this;\n            for (const columnName of columnNameOrNames) {\n                working = working.parseFloats(columnName);\n            }\n            \n            return working;\n        }\n        else {\n            return this.withSeries(columnNameOrNames, this.getSeries(columnNameOrNames).parseFloats());\n        }\n    }\n\n    /**\n     * Parse a column with string values and convert it to a column with date values.\n     *\n     * @param columnNameOrNames Specifies the column name or array of column names to parse.\n     * @param [formatString] Optional formatting string for dates.\n     * \n     * Moment is used for date parsing.\n     * https://momentjs.com\n     * \n     * @return Returns a new dataframe with values of particular named column(s) parsed from strings to dates.\n     * \n     * @example\n     * <pre>\n     * \n     * const parsed = df.parseDates(\"MyDateColumn\");\n     * </pre>\n     * \n     * @example\n     * <pre>\n     * \n     * const parsed = df.parseDates([\"MyDateColumnA\", \"MyDateColumnA\"]);\n     * </pre>\n     */\n    parseDates (columnNameOrNames: string | string[], formatString?: string): IDataFrame<IndexT, ValueT> {\n\n        if (formatString) {\n            if (!isString(formatString)) throw new Error(\"Expected optional 'formatString' parameter to 'DataFrame.parseDates' to be a string (if specified).\");\n        }\n\n        if (isArray(columnNameOrNames)) {\n            let working: IDataFrame<IndexT, ValueT> = this;\n            for (const columnName of columnNameOrNames) {\n                working = working.parseDates(columnName, formatString);\n            }\n            \n            return working;\n        }\n        else {\n            return this.withSeries(columnNameOrNames, this.getSeries(columnNameOrNames).parseDates(formatString));\n        }\n    }\n\n    /**\n     * Convert a column of values of different types to a column of string values.\n     *\n     * @param columnNames Specifies the column name or array of column names to convert to strings. Can also be a format spec that specifies which columns to convert and what their format should be. \n     * @param [formatString] Optional formatting string for dates.\n     * \n     * Numeral.js is used for number formatting.\n     * http://numeraljs.com/\n     * \n     * Moment is used for date formatting.\n     * https://momentjs.com/docs/#/parsing/string-format/\n     * \n     * @return Returns a new dataframe with a particular named column converted from values to strings.\n     * \n     * @example\n     * <pre>\n     * \n     * const result = df.toStrings(\"MyDateColumn\", \"YYYY-MM-DD\");\n     * </pre>\n     * \n     * @example\n     * <pre>\n     * \n     * const result = df.toStrings(\"MyFloatColumn\", \"0.00\");\n     * </pre>\n     */\n    toStrings (columnNames: string | string[] | IFormatSpec, formatString?: string): IDataFrame<IndexT, ValueT> {\n\n        if (isObject(columnNames)) {\n            for (const columnName of Object.keys(columnNames)) {\n                if (!isString((columnNames as any)[columnName])) throw new Error(\"Expected values of 'columnNames' parameter to be strings when a format spec is passed in.\");\n            }\n\n            if (!isUndefined(formatString)) throw new Error(\"Optional 'formatString' parameter to 'DataFrame.toStrings' should not be set when passing in a format spec.\");\n        }\n        else {\n            if (!isArray(columnNames)) {\n                if (!isString(columnNames)) throw new Error(\"Expected 'columnNames' parameter to 'DataFrame.toStrings' to be a string, array of strings or format spec that specifes which columns should be converted to strings.\");\n            }\n\n            if (formatString) {\n                if (!isString(formatString)) throw new Error(\"Expected optional 'formatString' parameter to 'DataFrame.toStrings' to be a string (if specified).\");\n            }    \n        }\n\n        if (isObject(columnNames)) {\n            let working: IDataFrame<IndexT, ValueT> = this;\n            for (const columnName of Object.keys(columnNames)) {\n                working = working.toStrings(columnName, formatString);\n            }\n            \n            return working;\n        }\n        else if (isArray(columnNames)) {\n            let working: IDataFrame<IndexT, ValueT> = this;\n            for (const columnName of columnNames) {\n                const columnFormatString = (columnNames as any)[columnName];\n                working = working.toStrings(columnName, columnFormatString);\n            }\n            \n            return working;\n        }\n        else {\n            const singleColumnName = columnNames as string;\n            return this.withSeries(singleColumnName, this.getSeries(singleColumnName).toStrings(formatString));\n        }\n    }\n\n    /**\n     * Produces a new dataframe with all string values truncated to the requested maximum length.\n     *\n     * @param maxLength The maximum length of the string values after truncation.\n     * \n     * @return Returns a new dataframe with all strings truncated to the specified maximum length.\n     * \n     * @example\n     * <pre>\n     * \n     * // Truncate all string columns to 100 characters maximum.\n     * const truncatedDf = df.truncateString(100);\n     * </pre>\n     */\n    truncateStrings (maxLength: number): IDataFrame<IndexT, ValueT> {\n        if (!isNumber(maxLength)) throw new Error(\"Expected 'maxLength' parameter to 'truncateStrings' to be an integer.\");\n\n        return this.select((row: any) => {\n            const output: any = {};\n            for (const key of Object.keys(row)) {\n                const value = row[key];\n                if (isString(value)) {\n                    output[key] = value.substring(0, maxLength);\n                }\n                else {\n                    output[key] = value;\n                }\n            }\n           return <ValueT> output;\n        });\n    }\n\n    /**\n     * Forces lazy evaluation to complete and 'bakes' the dataframe into memory.\n     * \n     * @return Returns a dataframe that has been 'baked', all lazy evaluation has completed.  \n     * \n     * @example\n     * <pre>\n     * \n     * const baked = df.bake();\n     * </pre>\n     */\n    bake (): IDataFrame<IndexT, ValueT> {\n\n        if (this.getContent().isBaked) {\n            // Already baked.\n            return this;\n        }\n\n        return new DataFrame({\n            columnNames: this.getColumnNames(),\n            values: this.toArray(),\n            pairs: this.toPairs(),\n            baked: true,\n        });\n    }\n\n    /** \n     * Gets a new dataframe in reverse order.\n     * \n     * @return Returns a new dataframe that is the reverse of the input.\n     * \n     * @example\n     * <pre>\n     * \n     * const reversedDf = df.reverse();\n     * </pre>\n     */\n    reverse (): IDataFrame<IndexT, ValueT> {\n        return new DataFrame<IndexT, ValueT>(() => {\n            const content = this.getContent();\n            return {\n                columnNames: content.columnNames,\n                values: new ReverseIterable(content.values),\n                index: new ReverseIterable(content.index),\n                pairs: new ReverseIterable(content.pairs)\n            };\n        });\n    }\n\n    /**\n     * Returns only the set of rows in the dataframe that are distinct according to some criteria.\n     * This can be used to remove duplicate rows from the dataframe.\n     *\n     * @param selector User-defined selector function that specifies the criteria used to make comparisons for duplicate rows.\n     * \n     * @return Returns a dataframe containing only unique values as determined by the 'selector' function. \n     * \n     * @example\n     * <pre>\n     * \n     * // Remove duplicate rows by customer id. Will return only a single row per customer.\n     * const distinctCustomers = salesDf.distinct(sale => sale.CustomerId);\n     * </pre>\n     */\n    distinct<ToT> (selector?: SelectorFn<ValueT, ToT>): IDataFrame<IndexT, ValueT> {\n        return new DataFrame<IndexT, ValueT>(() => {\n            const content = this.getContent();\n            return {\n                columnNames: content.columnNames,\n                values: new DistinctIterable<ValueT, ToT>(content.values, selector),\n                pairs: new DistinctIterable<[IndexT, ValueT],ToT>(content.pairs, (pair: [IndexT, ValueT]): ToT => selector && selector(pair[1]) || <ToT> <any> pair[1])\n            };\n        });\n    }\n\n    /**\n     * Collects rows in the dataframe into a series of groups according to the user-defined selector function that defines the group for each row.\n     *\n     * @param selector User-defined selector function that defines the value to group by.\n     *\n     * @return Returns a {@link Series} of groups. Each group is a dataframe with values that have been grouped by the 'selector' function.\n     * \n     * @example\n     * <pre>\n     * \n     * const salesDf = ... product sales ...\n     * const salesByProduct = salesDf.groupBy(sale => sale.ProductId);\n     * for (const productSalesGroup of salesByProduct) {\n     *      // ... do something with each product group ...\n     *      const productId = productSalesGroup.first().ProductId;\n     *      const totalSalesForProduct = productSalesGroup.deflate(sale => sale.Amount).sum();\n     *      console.log(totalSalesForProduct);\n     * }\n     * </pre>\n     */\n    groupBy<GroupT> (selector: SelectorWithIndexFn<ValueT, GroupT>): ISeries<number, IDataFrame<IndexT, ValueT>> {\n\n        if (!isFunction(selector)) throw new Error(\"Expected 'selector' parameter to 'DataFrame.groupBy' to be a selector function that determines the value to group the series by.\");\n\n        return new Series<number, IDataFrame<IndexT, ValueT>>(() => {\n            const groups: any[] = []; // Each group, in order of discovery.\n            const groupMap: any = {}; // Group map, records groups by key.\n            \n            let valueIndex = 0;\n    \n            for (const pair of this.getContent().pairs) {\n                const groupKey = selector(pair[1], valueIndex);\n                ++valueIndex;\n                const existingGroup = groupMap[groupKey];\n                if (existingGroup) {\n                    existingGroup.push(pair);\n                }\n                else {\n                    const newGroup: any[] = [];\n                    newGroup.push(pair);\n                    groups.push(newGroup);\n                    groupMap[groupKey] = newGroup;\n                }\n            }\n\n            return {\n                values: groups.map(group => new DataFrame<IndexT, ValueT>({ pairs: group }))\n            };\n        });\n    }\n    \n    /**\n     * Collects rows in the dataframe into a series of groups according to a user-defined selector function that identifies adjacent rows that should be in the same group.\n     *\n     * @param selector Optional selector that defines the value to group by.\n     *\n     * @return Returns a {@link Series} of groups. Each group is a dataframe with values that have been grouped by the 'selector' function.\n     * \n     * @example\n     * <pre>\n     * \n     * // Some ultra simple stock trading strategy backtesting...\n     * const dailyStockPriceDf = ... daily stock price for a company ...\n     * const priceGroups  = dailyStockPriceDf.groupBy(day => day.close > day.movingAverage);\n     * for (const priceGroup of priceGroups) {\n     *      // ... do something with each stock price group ...\n     * \n     *      const firstDay = priceGroup.first();\n     *      if (firstDay.close > movingAverage) {\n     *          // This group of days has the stock price above its moving average.\n     *          // ... maybe enter a long trade here ...\n     *      }\n     *      else {\n     *          // This group of days has the stock price below its moving average.\n     *          // ... maybe enter a short trade here ...\n     *      }\n     * }\n     * </pre>\n     */\n    groupSequentialBy<GroupT> (selector?: SelectorFn<ValueT, GroupT>): ISeries<number, IDataFrame<IndexT, ValueT>> {\n\n        if (selector) {\n            if (!isFunction(selector)) throw new Error(\"Expected 'selector' parameter to 'DataFrame.groupSequentialBy' to be a selector function that determines the value to group the series by.\")\n        }\n        else {\n            selector = value => <GroupT> <any> value;\n        }\n        \n        return this.variableWindow((a: ValueT, b: ValueT): boolean => selector!(a) === selector!(b));\n    }\n\n    /**\n     * Concatenate multiple dataframes into a single dataframe.\n     *\n     * @param dataframes Array of dataframes to concatenate.\n     * \n     * @return Returns a single dataframe concatenated from multiple input dataframes. \n     * \n     * @example\n     * <pre>\n     * \n     * const df1 = ...\n     * const df2 = ...\n     * const df3 = ...\n     * const concatenatedDf = DataFrame.concat([df1, df2, df3]);\n     * </pre>\n     * \n     * @example\n     * <pre>\n     * \n     * const dfs = [... array of dataframes...];\n     * const concatenatedDf = DataFrame.concat(dfs);\n     * </pre>\n     */\n    static concat<IndexT = any, ValueT = any> (dataframes: IDataFrame<IndexT, ValueT>[]): IDataFrame<IndexT, ValueT > {\n        if (!isArray(dataframes)) throw new Error(\"Expected 'dataframes' parameter to 'DataFrame.concat' to be an array of dataframes.\");\n\n        return new DataFrame(() => {\n            const upcast = <DataFrame<IndexT, ValueT>[]> dataframes; // Upcast so that we can access private index, values and pairs.\n            const contents = upcast.map(dataframe => dataframe.getContent());\n\n            let columnNames: string[] = [];\n            for (const content of contents) {\n                for (const columnName of content.columnNames) {\n                    columnNames.push(columnName);\n                }\n            }\n\n            columnNames = makeDistinct(columnNames);\n\n            return {\n                columnNames: columnNames,\n                values: new ConcatIterable(contents.map(content => content.values)),\n                pairs: new ConcatIterable(contents.map(content => content.pairs)),\n            };\n        });    \n    }\n    \n    /**\n     * Concatenate multiple other dataframes onto this dataframe.\n     * \n     * @param dataframes Multiple arguments. Each can be either a dataframe or an array of dataframes.\n     * \n     * @return Returns a single dataframes concatenated from multiple input dataframes. \n     * \n     * @example\n     * <pre>\n     * \n     * const concatenatedDf = dfA.concat(dfB);\n     * </pre>\n     * \n     * @example\n     * <pre>\n     * \n     * const concatenatedDf = dfA.concat(dfB, dfC);\n     * </pre>\n     * \n     * @example\n     * <pre>\n     * \n     * const concatenatedDf = dfA.concat([dfB, dfC]);\n     * </pre>\n     * \n     * @example\n     * <pre>\n     * \n     * const concatenatedDf = dfA.concat(dfB, [dfC, dfD]);\n     * </pre>\n     * \n     * @example\n     * <pre>\n     * \n     * const otherDfs = [... array of dataframes...];\n     * const concatenatedDf = dfA.concat(otherDfs);\n     * </pre>\n     */    \n    concat (...dataframes: (IDataFrame<IndexT, ValueT>[] | IDataFrame<IndexT, ValueT>)[]): IDataFrame<IndexT, ValueT> {\n        const concatInput: IDataFrame<IndexT, ValueT>[] = [this];\n\n        for (const input of dataframes) {\n            if (isArray(input)) {\n                for (const subInput of input) {\n                    concatInput.push(subInput);\n                }\n            }\n            else {\n                concatInput.push(input);\n            }\n        }\n\n        return DataFrame.concat<IndexT, ValueT>(concatInput);\n    }\n   \n    /**\n    * Zip (or merge) together multiple dataframes to create a new dataframe.\n    * Preserves the index of the first dataframe.\n    *\n    * @param input An iterable of datafames to be zipped.\n    * @param zipper User-defined zipper function that merges rows. It produces rows for the new dataframe based-on rows from the input dataframes.\n    * \n    * @return Returns a single dataframe zipped (or merged) from multiple input dataframes. \n    * \n    * @example\n    * <pre>\n    * \n    * function produceNewRow (inputRows) {\n    *       const outputRow = {\n    *           // Produce output row based on the contents of the input rows.\n    *       };\n    *       return outputRow;\n    * }\n    * \n    * const inputDfs = [... array of input dataframes ...];\n    * const zippedDf = DataFrame.zip(inputDfs, produceNewRow);\n    * \n    * </pre>\n    * \n    * @example\n    * <pre>\n    * \n    * function produceNewRow (inputRows) {\n    *       const outputRow = {\n    *           // Produce output row based on the contents of the input rows.\n    *       };\n    *       return outputRow;\n    * }\n    * \n    * const dfA = new DataFrame([ { Value: 10 }, { Value: 20 }, { Value: 30 }]);\n    * const dfB = new DataFrame([ { Value: 100 }, { Value: 200 }, { Value: 300 }]);\n    * const zippedDf = DataFrame.zip([dfA, dfB], produceNewRow);\n    * </pre>\n    */\n    static zip<IndexT = any, ValueT = any, ResultT = any> (dataframes: Iterable<IDataFrame<IndexT, ValueT>>, zipper: ZipNFn<ValueT, ResultT>): IDataFrame<IndexT, ResultT> {\n\n        const input = Array.from(dataframes);\n\n        if (input.length === 0) {\n            return new DataFrame<IndexT, ResultT>();\n        }\n\n        const firstSeries = input[0];\n        if (firstSeries.none()) {\n            return new DataFrame<IndexT, ResultT>();\n        }\n\n        return new DataFrame<IndexT, ResultT>(() => {\n            const firstSeriesUpCast = <DataFrame<IndexT, ValueT>> firstSeries;\n            const upcast = <DataFrame<IndexT, ValueT>[]> input; // Upcast so that we can access private index, values and pairs.\n            \n            return {\n                index: <Iterable<IndexT>> firstSeriesUpCast.getContent().index,\n                values: new ZipIterable<ValueT, ResultT>(upcast.map(s => s.getContent().values), zipper),\n            };\n        });\n    }\n    \n    /**\n    * Zip (or merge) together multiple dataframes to create a new dataframe.\n    * Preserves the index of the first dataframe.\n    * \n    * @param s2, s3, s4, s4 Multiple dataframes to zip.\n    * @param zipper User-defined zipper function that merges rows. It produces rows for the new dataframe based-on rows from the input dataframes.\n    * \n    * @return Returns a single dataframe zipped (or merged) from multiple input dataframes. \n    * \n    * @example\n    * <pre>\n    * \n    * function produceNewRow (rowA, rowB) {\n    *       const outputRow = {\n    *           ValueA: rowA.Value,\n    *           ValueB: rowB.Value,\n    *       };\n    *       return outputRow;\n    * }\n    * \n    * const dfA = new DataFrame([ { Value: 10 }, { Value: 20 }, { Value: 30 }]);\n    * const dfB = new DataFrame([ { Value: 100 }, { Value: 200 }, { Value: 300 }]);\n    * const zippedDf = dfA.zip(dfB, produceNewRow);\n    * </pre>\n    */    \n    zip<Index2T, Value2T, ResultT>  (s2: IDataFrame<Index2T, Value2T>, zipper: Zip2Fn<ValueT, Value2T, ResultT> ): IDataFrame<IndexT, ResultT>;\n    zip<Index2T, Value2T, Index3T, Value3T, ResultT>  (s2: IDataFrame<Index2T, Value2T>, s3: IDataFrame<Index3T, Value3T>, zipper: Zip3Fn<ValueT, Value2T, Value3T, ResultT> ): IDataFrame<IndexT, ResultT>;\n    zip<Index2T, Value2T, Index3T, Value3T, Index4T, Value4T, ResultT>  (s2: IDataFrame<Index2T, Value2T>, s3: IDataFrame<Index3T, Value3T>, s4: IDataFrame<Index4T, Value4T>, zipper: Zip3Fn<ValueT, Value2T, Value3T, ResultT> ): IDataFrame<IndexT, ResultT>;\n    zip<ResultT>  (...args: any[]): IDataFrame<IndexT, ResultT> {\n\n        const selector: Function = args[args.length-1];\n        const input: IDataFrame<IndexT, any>[] = [this].concat(args.slice(0, args.length-1));\n        return DataFrame.zip<IndexT, any, ResultT>(input, values => selector(...values));\n    }    \n\n    /**\n     * Sorts the dataframe in ascending order by a value defined by the user-defined selector function. \n     * \n     * @param selector User-defined selector function that selects the value to sort by.\n     * \n     * @return Returns a new dataframe that has been ordered accorrding to the value chosen by the selector function. \n     * \n     * @example\n     * <pre>\n     * \n     * // Order sales by amount from least to most.\n     * const orderedDf = salesDf.orderBy(sale => sale.Amount); \n     * </pre>\n     */\n    orderBy<SortT> (selector: SelectorWithIndexFn<ValueT, SortT>): IOrderedDataFrame<IndexT, ValueT, SortT> {\n        const content = this.getContent();\n        return new OrderedDataFrame<IndexT, ValueT, SortT>({\n            columnNames: content.columnNames,\n            values: content.values, \n            pairs: content.pairs, \n            selector: selector, \n            direction: Direction.Ascending, \n            parent: null,\n        });\n    }\n\n    /**\n     * Sorts the dataframe in descending order by a value defined by the user-defined selector function. \n     * \n     * @param selector User-defined selector function that selects the value to sort by.\n     * \n     * @return Returns a new dataframe that has been ordered accorrding to the value chosen by the selector function. \n     * \n     * @example\n     * <pre>\n     * \n     * // Order sales by amount from most to least\n     * const orderedDf = salesDf.orderByDescending(sale => sale.Amount); \n     * </pre>\n     */\n    orderByDescending<SortT> (selector: SelectorWithIndexFn<ValueT, SortT>): IOrderedDataFrame<IndexT, ValueT, SortT> {\n        const content = this.getContent();\n        return new OrderedDataFrame<IndexT, ValueT, SortT>({\n            columnNames: content.columnNames,\n            values: content.values, \n            pairs: content.pairs, \n            selector: selector, \n            direction: Direction.Descending, \n            parent: null,\n        });\n    }\n        \n    /**\n     * Creates a new dataframe by merging two input dataframes.\n     * The resulting dataframe contains the union of rows from the two input dataframes.\n     * These are the unique combination of rows in both dataframe.\n     * This is basically a concatenation and then elimination of duplicates.\n     *\n     * @param other The other dataframes to merge.\n     * @param [selector] Optional user-defined selector function that selects the value to compare to detemrine distinctness.\n     * \n     * @return Returns the union of the two dataframes.\n     * \n     * @example\n     * <pre>\n     *\n     * const dfA = ...\n     * const dfB = ...\n     * const merged = dfA.union(dfB);\n     * </pre>\n     * \n     * @example\n     * <pre>\n     *\n     * // Merge two sets of customer records that may contain the same\n     * // customer record in each set. This is basically a concatenation\n     * // of the dataframes and then an elimination of any duplicate records\n     * // that result.\n     * const customerRecordsA = ...\n     * const customerRecordsB = ...\n     * const mergedCustomerRecords = customerRecordsA.union(\n     *      customerRecordsB, \n     *      customerRecord => customerRecord.CustomerId\n     * );\n     * </pre>\n     * \n     * \n     * @example\n     * <pre>\n     *\n     * // Note that you can achieve the exact same result as the previous\n     * // example by doing a {@link DataFrame.concat) and {@link DataFrame.distinct}\n     * // of the dataframes and then an elimination of any duplicate records\n     * // that result.\n     * const customerRecordsA = ...\n     * const customerRecordsB = ...\n     * const mergedCustomerRecords = customerRecordsA\n     *      .concat(customerRecordsB)\n     *      .distinct(customerRecord => customerRecord.CustomerId);\n     * </pre>\n     * \n     */\n    union<KeyT = ValueT> (\n        other: IDataFrame<IndexT, ValueT>, \n        selector?: SelectorFn<ValueT, KeyT>): \n            IDataFrame<IndexT, ValueT> {\n\n        if (selector) {\n            if (!isFunction(selector)) throw new Error(\"Expected optional 'selector' parameter to 'DataFrame.union' to be a selector function.\");\n        }\n\n        return this.concat(other).distinct(selector);\n    };\n\n    /**\n     * Creates a new dataframe by merging two input dataframes.\n     * The resulting dataframe contains the intersection of rows from the two input dataframes.\n     * These are only the rows that appear in both dataframes.\n     *\n     * @param inner The inner dataframe to merge (the dataframe you call the function on is the 'outer' dataframe).\n     * @param [outerSelector] Optional user-defined selector function that selects the key from the outer dataframe that is used to match the two dataframes.\n     * @param [innerSelector] Optional user-defined selector function that selects the key from the inner dataframe that is used to match the two dataframes.\n     * \n     * @return Returns a new dataframe that contains the intersection of rows from the two input dataframes.\n     * \n     * @example\n     * <pre>\n     * \n     * const dfA = ...\n     * const dfB = ...\n     * const mergedDf = dfA.intersection(dfB);\n     * </pre>\n     * \n     * @example\n     * <pre>\n     *\n     * // Merge two sets of customer records to find only the\n     * // customers that appears in both.\n     * const customerRecordsA = ...\n     * const customerRecordsB = ...\n     * const intersectionOfCustomerRecords = customerRecordsA.intersection(\n     *      customerRecordsB, \n     *      customerRecord => customerRecord.CustomerId\n     * );\n     * </pre>     \n     * */\n    intersection<InnerIndexT = IndexT, InnerValueT = ValueT, KeyT = ValueT> (\n        inner: IDataFrame<InnerIndexT, InnerValueT>, \n        outerSelector?: SelectorFn<ValueT, KeyT>,\n        innerSelector?: SelectorFn<InnerValueT, KeyT>): \n            IDataFrame<IndexT, ValueT> {\n\n        if (outerSelector) {\n            if (!isFunction(outerSelector)) throw new Error(\"Expected optional 'outerSelector' parameter to 'DataFrame.intersection' to be a function.\");\n        }\n        else {\n            outerSelector = value => <KeyT> <any> value;\n        }\n        \n        if (innerSelector) {\n            if (!isFunction(innerSelector)) throw new Error(\"Expected optional 'innerSelector' parameter to 'DataFrame.intersection' to be a function.\");\n        }\n        else {\n            innerSelector = value => <KeyT> <any> value;\n        }\n\n        const outer = this;\n        return outer.where(outerValue => {\n                const outerKey = outerSelector!(outerValue);\n                return inner\n                    .where(innerValue => outerKey === innerSelector!(innerValue))\n                    .any();\n            });\n    };\n\n    /**\n     * Creates a new dataframe by merging two input dataframes.\n     * The resulting dataframe contains only the rows from the 1st dataframe that don't appear in the 2nd dataframe.\n     * This is essentially subtracting the rows from the 2nd dataframe from the 1st and creating a new dataframe with the remaining rows.\n     *\n     * @param inner The inner dataframe to merge (the dataframe you call the function on is the 'outer' dataframe).\n     * @param [outerSelector] Optional user-defined selector function that selects the key from the outer dataframe that is used to match the two dataframes.\n     * @param [innerSelector] Optional user-defined selector function that selects the key from the inner dataframe that is used to match the two dataframes.\n     * \n     * @return Returns a new dataframe that contains only the rows from the 1st dataframe that don't appear in the 2nd dataframe.\n     * \n     * @example\n     * <pre>\n     * \n     * const dfA = ...\n     * const dfB = ...\n     * const remainingDf = dfA.except(dfB);\n     * </pre>\n     * \n     * @example\n     * <pre>\n     *\n     * // Find the list of customers haven't bought anything recently.\n     * const allCustomers = ... list of all customers ...\n     * const recentCustomers = ... list of customers who have purchased recently ...\n     * const remainingCustomers = allCustomers.except(\n     *      recentCustomers, \n     *      customerRecord => customerRecord.CustomerId\n     * );\n     * </pre>\n     */\n    except<InnerIndexT = IndexT, InnerValueT = ValueT, KeyT = ValueT> (\n        inner: IDataFrame<InnerIndexT, InnerValueT>, \n        outerSelector?: SelectorFn<ValueT, KeyT>,\n        innerSelector?: SelectorFn<InnerValueT, KeyT>): \n            IDataFrame<IndexT, ValueT> {\n\n        if (outerSelector) {\n            if (!isFunction(outerSelector)) throw new Error(\"Expected optional 'outerSelector' parameter to 'DataFrame.except' to be a function.\");\n        }\n        else {\n            outerSelector = value => <KeyT> <any> value;\n        }\n\n        if (innerSelector) {\n            if (!isFunction(innerSelector)) throw new Error(\"Expected optional 'innerSelector' parameter to 'DataFrame.except' to be a function.\");\n        }\n        else {\n            innerSelector = value => <KeyT> <any> value;\n        }\n\n        const outer = this;\n        return outer.where(outerValue => {\n                const outerKey = outerSelector!(outerValue);\n                return inner\n                    .where(innerValue => outerKey === innerSelector!(innerValue))\n                    .none();\n            });\n    };\n\n   /**\n     * Creates a new dataframe by merging two input dataframes.\n     * The resulting dataframe contains only those rows that have matching keys in both input dataframes.\n     *\n     * @param inner The 'inner' dataframe to join (the dataframe you are callling the function on is the 'outer' dataframe).\n     * @param outerKeySelector User-defined selector function that chooses the join key from the outer dataframe.\n     * @param innerKeySelector User-defined selector function that chooses the join key from the inner dataframe.\n     * @param resultSelector User-defined function that merges outer and inner values.\n     * \n     * @return Returns the new merged dataframe.\n     * \n     * @example\n     * <pre>\n     * \n     * // Join together two sets of customers to find those\n     * // that have bought both product A and product B.\n     * const customerWhoBoughtProductA = ...\n     * const customerWhoBoughtProductB = ...\n     * const customersWhoBoughtBothProductsDf = customerWhoBoughtProductA.join(\n     *          customerWhoBoughtProductB,\n     *          customerA => customerA.CustomerId, // Join key.\n     *          customerB => customerB.CustomerId, // Join key.\n     *          (customerA, customerB) => {\n     *              return {\n     *                  // ... merge the results ...\n     *              };\n     *          }\n     *      );\n     * </pre>\n     */\n    join<KeyT, InnerIndexT, InnerValueT, ResultValueT> (\n        inner: IDataFrame<InnerIndexT, InnerValueT>, \n        outerKeySelector: SelectorFn<ValueT, KeyT>, \n        innerKeySelector: SelectorFn<InnerValueT, KeyT>, \n        resultSelector: JoinFn<ValueT, InnerValueT, ResultValueT>):\n            IDataFrame<number, ResultValueT> {\n\n        if (!isFunction(outerKeySelector)) throw new Error(\"Expected 'outerKeySelector' parameter of 'DataFrame.join' to be a selector function.\");\n        if (!isFunction(innerKeySelector)) throw new Error(\"Expected 'innerKeySelector' parameter of 'DataFrame.join' to be a selector function.\");\n        if (!isFunction(resultSelector)) throw new Error(\"Expected 'resultSelector' parameter of 'DataFrame.join' to be a selector function.\");\n\n        const outer = this;\n\n        return new DataFrame<number, ResultValueT>(() => {\n            const innerMap = inner\n                .groupBy(innerKeySelector)\n                .toObject(\n                    group => innerKeySelector(group.first()), \n                    group => group\n                );\n\n            const outerContent = outer.getContent();\n\n            const output: ResultValueT[] = [];\n            \n            for (const outerValue of outer) { //TODO: There should be an enumerator that does this.\n                const outerKey = outerKeySelector(outerValue);\n                const innerGroup = innerMap[outerKey];\n                if (innerGroup) {\n                    for (const innerValue of innerGroup) {\n                        output.push(resultSelector(outerValue, innerValue));\n                    }    \n                }\n            }\n\n            return {\n                values: output\n            };\n        });\n    }\n\n    /**\n     * Creates a new dataframe by merging two input dataframes.\n     * The resulting dataframe contains only those rows that are only present in or or the other of the dataframes, not both.\n     *\n     * @param inner The 'inner' dataframe to join (the dataframe you are callling the function on is the 'outer' dataframe).\n     * @param outerKeySelector User-defined selector function that chooses the join key from the outer dataframe.\n     * @param innerKeySelector User-defined selector function that chooses the join key from the inner dataframe.\n     * @param resultSelector User-defined function that merges outer and inner values.\n     * \n     * Implementation from here:\n     * \n     * \thttp://blogs.geniuscode.net/RyanDHatch/?p=116\n     * \n     * @return Returns the new merged dataframe.\n     * \n     * @example\n     * <pre>\n     * \n     * // Join together two sets of customers to find those\n     * // that have bought either product A or product B, not not both.\n     * const customerWhoBoughtProductA = ...\n     * const customerWhoBoughtProductB = ...\n     * const customersWhoBoughtEitherProductButNotBothDf = customerWhoBoughtProductA.joinOuter(\n     *          customerWhoBoughtProductB,\n     *          customerA => customerA.CustomerId, // Join key.\n     *          customerB => customerB.CustomerId, // Join key.\n     *          (customerA, customerB) => {\n     *              return {\n     *                  // ... merge the results ...\n     *              };\n     *          }\n     *      );\n     * </pre>\n     */\n    joinOuter<KeyT, InnerIndexT, InnerValueT, ResultValueT> (\n        inner: IDataFrame<InnerIndexT, InnerValueT>, \n        outerKeySelector: SelectorFn<ValueT, KeyT>, \n        innerKeySelector: SelectorFn<InnerValueT, KeyT>, \n        resultSelector: JoinFn<ValueT | null, InnerValueT | null, ResultValueT>):\n            IDataFrame<number, ResultValueT> {\n\n        if (!isFunction(outerKeySelector)) throw new Error(\"Expected 'outerKeySelector' parameter of 'DataFrame.joinOuter' to be a selector function.\");\n        if (!isFunction(innerKeySelector)) throw new Error(\"Expected 'innerKeySelector' parameter of 'DataFrame.joinOuter' to be a selector function.\");\n        if (!isFunction(resultSelector)) throw new Error(\"Expected 'resultSelector' parameter of 'DataFrame.joinOuter' to be a selector function.\");\n\n        // Get the results in the outer that are not in the inner.\n        const outer = this;\n        const outerResult = outer.except<InnerIndexT, InnerValueT, KeyT>(inner, outerKeySelector, innerKeySelector)\n            .select(outer => resultSelector(outer, null))\n            .resetIndex();\n\n        // Get the results in the inner that are not in the outer.\n        const innerResult = inner.except<IndexT, ValueT, KeyT>(outer, innerKeySelector, outerKeySelector)\n            .select(inner => resultSelector(null, inner))\n            .resetIndex();\n\n        // Get the intersection of results between inner and outer.\n        const intersectionResults = outer.join<KeyT, InnerIndexT, InnerValueT, ResultValueT>(inner, outerKeySelector, innerKeySelector, resultSelector);\n\n        return outerResult\n            .concat(intersectionResults)\n            .concat(innerResult)\n            .resetIndex();\n    };\n\n    /**\n     * Creates a new dataframe by merging two input dataframes.\n     * The resulting dataframe contains only those rows that present either in both dataframes or only in the outer (left) dataframe.\n     * \n     * @param inner The 'inner' dataframe to join (the dataframe you are callling the function on is the 'outer' dataframe).\n     * @param outerKeySelector User-defined selector function that chooses the join key from the outer dataframe.\n     * @param innerKeySelector User-defined selector function that chooses the join key from the inner dataframe.\n     * @param resultSelector User-defined function that merges outer and inner values.\n     * \n     * Implementation from here:\n     * \n     * \thttp://blogs.geniuscode.net/RyanDHatch/?p=116\n     * \n     * @return Returns the new merged dataframe.\n     * \n     * @example\n     * <pre>\n     * \n     * // Join together two sets of customers to find those\n     * // that have bought either just product A or both product A and product B.\n     * const customerWhoBoughtProductA = ...\n     * const customerWhoBoughtProductB = ...\n     * const boughtJustAorAandB = customerWhoBoughtProductA.joinOuterLeft(\n     *          customerWhoBoughtProductB,\n     *          customerA => customerA.CustomerId, // Join key.\n     *          customerB => customerB.CustomerId, // Join key.\n     *          (customerA, customerB) => {\n     *              return {\n     *                  // ... merge the results ...\n     *              };\n     *          }\n     *      );\n     * </pre>\n     */\n    joinOuterLeft<KeyT, InnerIndexT, InnerValueT, ResultValueT> (\n        inner: IDataFrame<InnerIndexT, InnerValueT>, \n        outerKeySelector: SelectorFn<ValueT, KeyT>, \n        innerKeySelector: SelectorFn<InnerValueT, KeyT>, \n        resultSelector: JoinFn<ValueT | null, InnerValueT | null, ResultValueT>):\n            IDataFrame<number, ResultValueT> {\n\n        if (!isFunction(outerKeySelector)) throw new Error(\"Expected 'outerKeySelector' parameter of 'DataFrame.joinOuterLeft' to be a selector function.\");\n        if (!isFunction(innerKeySelector)) throw new Error(\"Expected 'innerKeySelector' parameter of 'DataFrame.joinOuterLeft' to be a selector function.\");\n        if (!isFunction(resultSelector)) throw new Error(\"Expected 'resultSelector' parameter of 'DataFrame.joinOuterLeft' to be a selector function.\");\n\n        // Get the results in the outer that are not in the inner.\n        const outer = this;\n        const outerResult = outer.except<InnerIndexT, InnerValueT, KeyT>(inner, outerKeySelector, innerKeySelector)\n            .select(outer => resultSelector(outer, null))\n            .resetIndex();\n\n        // Get the intersection of results between inner and outer.\n        const intersectionResults = outer.join<KeyT, InnerIndexT, InnerValueT, ResultValueT>(inner, outerKeySelector, innerKeySelector, resultSelector);\n\n        return outerResult\n            .concat(intersectionResults)\n            .resetIndex();\n    };\n\n    /**\n     * Creates a new dataframe by merging two input dataframes.\n     * The resulting dataframe contains only those rows that present either in both dataframes or only in the inner (right) dataframe.\n     *\n     * @param inner The 'inner' dataframe to join (the dataframe you are callling the function on is the 'outer' dataframe).\n     * @param outerKeySelector User-defined selector function that chooses the join key from the outer dataframe.\n     * @param innerKeySelector User-defined selector function that chooses the join key from the inner dataframe.\n     * @param resultSelector User-defined function that merges outer and inner values.\n     * \n     * Implementation from here:\n     * \n     * \thttp://blogs.geniuscode.net/RyanDHatch/?p=116\n     * \n     * @return Returns the new merged dataframe.\n     * \n     * @example\n     * <pre>\n     * \n     * // Join together two sets of customers to find those\n     * // that have bought either just product B or both product A and product B.\n     * const customerWhoBoughtProductA = ...\n     * const customerWhoBoughtProductB = ...\n     * const boughtJustAorAandB = customerWhoBoughtProductA.joinOuterRight(\n     *          customerWhoBoughtProductB,\n     *          customerA => customerA.CustomerId, // Join key.\n     *          customerB => customerB.CustomerId, // Join key.\n     *          (customerA, customerB) => {\n     *              return {\n     *                  // ... merge the results ...\n     *              };\n     *          }\n     *      );\n     * </pre>\n     */\n    joinOuterRight<KeyT, InnerIndexT, InnerValueT, ResultValueT> (\n        inner: IDataFrame<InnerIndexT, InnerValueT>, \n        outerKeySelector: SelectorFn<ValueT, KeyT>, \n        innerKeySelector: SelectorFn<InnerValueT, KeyT>, \n        resultSelector: JoinFn<ValueT | null, InnerValueT | null, ResultValueT>):\n            IDataFrame<number, ResultValueT> {\n\n        if (!isFunction(outerKeySelector)) throw new Error(\"Expected 'outerKeySelector' parameter of 'DataFrame.joinOuterRight' to be a selector function.\");\n        if (!isFunction(innerKeySelector)) throw new Error(\"Expected 'innerKeySelector' parameter of 'DataFrame.joinOuterRight' to be a selector function.\");\n        if (!isFunction(resultSelector)) throw new Error(\"Expected 'resultSelector' parameter of 'DataFrame.joinOuterRight' to be a selector function.\");\n\n        // Get the results in the inner that are not in the outer.\n        const outer = this;\n        const innerResult = inner.except<IndexT, ValueT, KeyT>(outer, innerKeySelector, outerKeySelector)\n            .select(inner => resultSelector(null, inner))\n            .resetIndex();\n\n        // Get the intersection of results between inner and outer.\n        const intersectionResults = outer.join<KeyT, InnerIndexT, InnerValueT, ResultValueT>(inner, outerKeySelector, innerKeySelector, resultSelector);\n\n        return intersectionResults\n            .concat(innerResult)\n            .resetIndex();\n    }    \n\n    /**\n     * Produces a summary of dataframe. A bit like the 'aggregate' function but much simpler.\n     * \n     * @param [spec] Optional parameter that specifies which columns to aggregate and how to aggregate them. Leave this out to produce a default summary of all columns.\n     * \n     * @returns A object with fields that summary the values in the dataframe.\n     * \n     * @example\n     * <pre>\n     * \n     * const summary = df.summarize();\n     * console.log(summary);\n     * </pre>\n     * \n     * @example\n     * <pre>\n     * \n     * const summary = df.summarize({ // Summarize using pre-defined functions.\n     *      Column1: Series.sum,\n     *      Column2: Series.average,\n     *      Column3: Series.count,\n     * });\n     * console.log(summary);\n     * </pre>\n     * \n     * @example\n     * <pre>\n     * \n     * const summary = df.summarize({ // Summarize using custom functions.\n     *      Column1: series => series.sum(),\n     *      Column2: series => series.std(),\n     *      ColumnN: whateverFunctionYouWant,\n     * });\n     * console.log(summary);\n     * </pre>\n     * \n     * @example\n     * <pre>\n     * \n     * const summary = df.summarize({ // Multiple output fields per column.\n     *      Column1: {\n     *          OutputField1: Series.sum,\n     *          OutputField2: Series.average,\n     *      },\n     *      Column2: {\n     *          OutputField3: series => series.sum(),\n     *          OutputFieldN: whateverFunctionYouWant,\n     *      },\n     * });\n     * console.log(summary);\n     * </pre>\n     */\n    summarize<OutputValueT = any> (\n        spec?: IMultiColumnAggregatorSpec\n            ): OutputValueT {\n\n        if (spec && !isObject(spec)) {\n            throw new Error(\"Expected 'spec' parameter to 'DataFrame.summarize' to be an object that specifies how to summarize the dataframe.\");\n        }\n\n        if (!spec) {\n            spec = {};\n\n            for (const columnName of this.getColumnNames()) {\n                const columnSpec: any = {};\n                columnSpec[columnName + \"_sum\"] = Series.sum;\n                columnSpec[columnName + \"_average\"] = Series.average;\n                columnSpec[columnName + \"_count\"] = Series.count;\n                spec[columnName] = columnSpec;\n\n            }\n        }\n\n        for (const inputColumnName of Object.keys(spec)) {\n            const inputSpec = spec[inputColumnName];\n            if (isFunction(inputSpec)) {\n                spec[inputColumnName] = {}; // Expand the spec.\n                (spec[inputColumnName] as IColumnAggregatorSpec) [inputColumnName] = inputSpec;\n            }\n        }\n\n        const inputColumnNames = Object.keys(spec);\n        const outputFieldsMap = toMap(\n            inputColumnNames, \n            valueColumnName => valueColumnName, \n            inputColumnName => Object.keys(spec![inputColumnName])\n        );\n\n        const output: any = {};\n        \n        for (const inputColumnName of inputColumnNames) {\n            const outputFieldNames = outputFieldsMap[inputColumnName];\n            for (const outputFieldName of outputFieldNames) {\n                const aggregatorFn = (spec[inputColumnName] as IColumnAggregatorSpec)[outputFieldName];\n                output[outputFieldName] = aggregatorFn(this.getSeries(inputColumnName));\n            }\n        }\n\n        return output;\n    }\n    \n    /**\n     * Reshape (or pivot) a dataframe based on column values.\n     * This is a powerful function that combines grouping, aggregation and sorting.\n     *\n     * @param columnOrColumns Column name whose values make the new DataFrame's columns.\n     * @param valueColumnNameOrSpec Column name or column spec that defines the columns whose values should be aggregated.\n     * @param [aggregator] Optional function used to aggregate pivotted vales. \n     *\n     * @return Returns a new dataframe that has been pivoted based on a particular column's values. \n     * \n     * @example\n     * <pre>\n     * \n     * // Simplest example.\n     * // Group by the values in 'PivotColumn'.\n     * // The unique set of values in 'PivotColumn' becomes the columns in the resulting dataframe.\n     * // The column 'ValueColumn' is aggregated for each group and this becomes the \n     * // values in the new output column.\n     * const pivottedDf = df.pivot(\"PivotColumn\", \"ValueColumn\", values => values.average());\n     * </pre>\n     * \n     * @example\n     * <pre>\n     * \n     * // Multiple input column example.\n     * // Similar to the previous example except now we are aggregating multiple input columns.\n     * // Each group has the average computed for 'ValueColumnA' and the sum for 'ValueColumnB'.\n     * const pivottedDf = df.pivot(\"PivotColumn\", { \n     *      ValueColumnA: aValues => aValues.average(),\n     *      ValueColumnB:  bValues => bValues.sum(),\n     * });\n     * </pre>\n     * \n     * @example\n     * <pre>\n     * \n     * // Multiple output column example.\n     * // Similar to the previous example except now we are doing multiple aggregations for each input column.\n     * // The example produces an output dataframe with columns OutputColumnA, B, C and D.\n     * // OutputColumnA/B are the sum and average of ValueColumnA across each group as defined by PivotColumn.\n     * // OutputColumnC/D are the sum and average of ValueColumnB across each group as defined by PivotColumn.\n     * const pivottedDf = df.pivot(\"PivotColumn\", { \n     *      ValueColumnA: {\n     *          OutputColumnA: aValues => aValues.sum(),\n     *          OutputColumnB: aValues => aValues.average(),\n     *      },\n     *      ValueColumnB: {\n     *          OutputColumnC: bValues => aValues.sum(),\n     *          OutputColumnD: bValues => aValues.average(),\n     *      },\n     * });\n     * </pre>\n     * \n     * @example\n     * <pre>\n     * \n     * // Full multi-column example.\n     * // Similar to the previous example now we are pivotting on multiple columns.\n     * // We now group by the 'PivotColumnA' and then by 'PivotColumnB', effectively creating a \n     * // multi-level group.\n     * const pivottedDf = df.pivot([\"PivotColumnA\", \"PivotColumnB\" ], { \n     *      ValueColumnA: aValues => aValues.average(),\n     *      ValueColumnB:  bValues => bValues.sum(),\n     * });\n     * </pre>\n     * \n     * @example\n     * <pre>\n     * \n     * // To help understand the pivot function, let's look at what it does internally.\n     * // Take the simplest example:\n     * const pivottedDf = df.pivot(\"PivotColumn\", \"ValueColumn\", values => values.average());\n     * \n     * // If we expand out the internals of the pivot function, it will look something like this:\n     * const pivottedDf = df.groupBy(row => row.PivotColumn)\n     *          .select(group => ({\n     *              PivotColumn: group.deflate(row.ValueColumn).average()\n     *          }))\n     *          .orderBy(row  => row.PivotColumn);\n     * \n     * // You can see that pivoting a dataframe is the same as grouping, aggregating and sorting it.\n     * // Does pivoting seem simpler now?\n     * \n     * // It gets more complicated than that of course, because the pivot function supports multi-level nested \n     * // grouping and aggregation of multiple columns. So a full expansion of the pivot function is rather complex.\n     * </pre>\n     */\n    pivot<NewValueT = ValueT> (\n        columnOrColumns: string | Iterable<string>, \n        valueColumnNameOrSpec: string | IMultiColumnAggregatorSpec, \n        aggregator?: (values: ISeries<number, any>) => any\n            ): IDataFrame<number, NewValueT> {\n\n        let columnNames: string[];\n\n        if (isString(columnOrColumns)) {\n            columnNames = [columnOrColumns];\n        }\n        else {\n            if (!isArray(columnOrColumns)) throw new Error(\"Expected 'columnOrColumns' parameter to 'DataFrame.pivot' to be a string or an array of strings that identifies the column(s) whose values make the new DataFrame's columns.\");\n\n            columnNames = Array.from(columnOrColumns);\n\n            if (columnNames.length === 0) throw new Error(\"Expected 'columnOrColumns' parameter to 'DataFrame.pivot' to contain at least one string.\");\n\n            for (const columnName of columnNames) {\n                if (!isString(columnName)) throw new Error(\"Expected 'columnOrColumns' parameter to 'DataFrame.pivot' to be an array of strings, each string identifies a column in the DataFrame on which to pivot.\");\n            }\n        }\n\n        let aggSpec: IMultiColumnAggregatorSpec;\n\n        if (!isObject(valueColumnNameOrSpec)) {\n            if (!isString(valueColumnNameOrSpec)) throw new Error(\"Expected 'value' parameter to 'DataFrame.pivot' to be a string that identifies the column whose values to aggregate or a column spec that defines which column contains the value ot aggregate and the ways to aggregate that value.\");\n            if (!isFunction(aggregator)) throw new Error(\"Expected 'aggregator' parameter to 'DataFrame.pivot' to be a function to aggegrate pivoted values.\");\n\n            const aggColumnName = valueColumnNameOrSpec as string;\n\n            const outputSpec: IColumnAggregatorSpec = {};\n            outputSpec[aggColumnName] = aggregator!;\n\n            aggSpec = {};\n            aggSpec[aggColumnName] = outputSpec;\n        }\n        else {\n            aggSpec = valueColumnNameOrSpec as IMultiColumnAggregatorSpec;\n\n            for (const inputColumnName of Object.keys(aggSpec)) {\n                const columnAggSpec = aggSpec[inputColumnName];\n                if (isFunction(columnAggSpec)) {\n                    aggSpec[inputColumnName] = {}; // Expand the pivot spec.\n                    (aggSpec[inputColumnName] as IColumnAggregatorSpec) [inputColumnName] = columnAggSpec;\n                }\n            }\n        }\n\n        const firstColumnName = columnNames[0];\n        let working = this.groupBy((row: any) => row[firstColumnName])\n            .select(group => {\n                const output: any = {};\n                output[firstColumnName] = (group.first() as any)[firstColumnName];\n                output.src = group;\n                return output;\n            });\n\n        for (let columnNameIndex = 1; columnNameIndex < columnNames.length; ++columnNameIndex) {\n            const nextColumnName = columnNames[columnNameIndex];\n            working = working.selectMany(parentGroup => {\n                    const src: IDataFrame<IndexT, ValueT> = parentGroup.src;\n                    return src.groupBy((row: any) => row[nextColumnName])\n                        .select(subGroup => {\n                            const output = Object.assign({}, parentGroup);\n                            output[nextColumnName] = (subGroup.first() as any)[nextColumnName];\n                            output.src = subGroup;\n                            return output;\n                        });\n                });\n        }\n\n        const valueColumnNames = Object.keys(aggSpec);\n        const outputColumnsMap = toMap(\n            valueColumnNames, \n            valueColumnName => valueColumnName, \n            valueColumnName => Object.keys(aggSpec[valueColumnName])\n        );\n        \n        const pivotted = working.inflate<NewValueT>((row: any) => {\n            for (const valueColumnName of valueColumnNames) {\n                const outputColumnNames = outputColumnsMap[valueColumnName];\n                for (const outputColumName of outputColumnNames) {\n                    const aggregatorFn = (aggSpec[valueColumnName] as IColumnAggregatorSpec)[outputColumName];\n                    row[outputColumName] = aggregatorFn(row.src.deflate((srcRow: any) => srcRow[valueColumnName])) \n                }\n            }\n\n            delete row.src;\n            return row;\n        });\n\n        let ordered = pivotted.orderBy((row: any) => row[firstColumnName]);\n        for (let columnNameIndex = 1; columnNameIndex < columnNames.length; ++columnNameIndex) {\n            const nextColumnName = columnNames[columnNameIndex];\n            ordered = ordered.thenBy((row: any) => row[nextColumnName]);\n        }\n\n        return ordered;\n    }\n    \n    /**\n     * Insert a pair at the start of the dataframe.\n     * Doesn't modify the original dataframe! The returned dataframe is entirely new and contains rows from the original dataframe plus the inserted pair.\n     *\n     * @param pair The pair to insert.\n     * \n     * @return Returns a new dataframe with the specified pair inserted.\n     * \n     * @example\n     * <pre>\n     * \n     * const newIndex = ... index of the new row ...\n     * const newRow = ... the new data row to insert ...\n     * const insertedDf = df.insertPair([newIndex, newRows]);\n     * </pre>\n     */\n    insertPair (pair: [IndexT, ValueT]): IDataFrame<IndexT, ValueT> {\n        if (!isArray(pair)) throw new Error(\"Expected 'pair' parameter to 'DataFrame.insertPair' to be an array.\");\n        if (pair.length !== 2) throw new Error(\"Expected 'pair' parameter to 'DataFrame.insertPair' to be an array with two elements. The first element is the index, the second is the value.\");\n\n        return (new DataFrame<IndexT, ValueT>({ pairs: [pair] })).concat(this);\n    }\n\n    /**\n     * Append a pair to the end of a dataframe.\n     * Doesn't modify the original dataframe! The returned dataframe is entirely new and contains rows from the original dataframe plus the appended pair.\n     *\n     * @param pair - The pair to append.\n     *  \n     * @return Returns a new dataframe with the specified pair appended.\n     * \n     * @example\n     * <pre>\n     * \n     * const newIndex = ... index of the new row ...\n     * const newRow = ... the new data row to append ...\n     * const appendedDf = df.appendPair([newIndex, newRows]);\n     * </pre>\n     */\n    appendPair (pair: [IndexT, ValueT]): IDataFrame<IndexT, ValueT> {\n        if (!isArray(pair)) throw new Error(\"Expected 'pair' parameter to 'DataFrame.appendPair' to be an array.\");\n        if (pair.length !== 2) throw new Error(\"Expected 'pair' parameter to 'DataFrame.appendPair' to be an array with two elements. The first element is the index, the second is the value.\");\n\n        return this.concat(new DataFrame<IndexT, ValueT>({ pairs: [pair] }));\n    }\n\n    /**\n     * Fill gaps in a dataframe.\n     *\n     * @param comparer User-defined comparer function that is passed pairA and pairB, two consecutive rows, return truthy if there is a gap between the rows, or falsey if there is no gap.\n     * @param generator User-defined generator function that is passed pairA and pairB, two consecutive rows, returns an array of pairs that fills the gap between the rows.\n     *\n     * @return Returns a new dataframe with gaps filled in.\n     * \n     * @example\n     * <pre>\n     * \n     *   var sequenceWithGaps = ...\n     *\n     *  // Predicate that determines if there is a gap.\n     *  var gapExists = (pairA, pairB) => {\n     *      // Returns true if there is a gap.\n     *      return true;\n     *  };\n     *\n     *  // Generator function that produces new rows to fill the game.\n     *  var gapFiller = (pairA, pairB) => {\n     *      // Create an array of index, value pairs that fill the gaps between pairA and pairB.\n     *      return [\n     *          newPair1,\n     *          newPair2,\n     *          newPair3,\n     *      ];\n     *  };\n     *\n     *  var sequenceWithoutGaps = sequenceWithGaps.fillGaps(gapExists, gapFiller);\n     * </pre>\n     */\n    fillGaps (comparer: ComparerFn<[IndexT, ValueT], [IndexT, ValueT]>, generator: GapFillFn<[IndexT, ValueT], [IndexT, ValueT]>): IDataFrame<IndexT, ValueT> {\n        if (!isFunction(comparer)) throw new Error(\"Expected 'comparer' parameter to 'DataFrame.fillGaps' to be a comparer function that compares two values and returns a boolean.\")\n        if (!isFunction(generator)) throw new Error(\"Expected 'generator' parameter to 'DataFrame.fillGaps' to be a generator function that takes two values and returns an array of generated pairs to span the gap.\")\n\n        return this.rollingWindow(2)\n            .selectMany(window => {\n                const pairs = window.toPairs();\n                const pairA = pairs[0];\n                const pairB = pairs[1];\n                if (!comparer(pairA, pairB)) {\n                    return [pairA];\n                }\n\n                const generatedRows = generator(pairA, pairB);\n                if (!isArray(generatedRows)) throw new Error(\"Expected return from 'generator' parameter to 'DataFrame.fillGaps' to be an array of pairs, instead got a \" + typeof(generatedRows));\n\n                return [pairA].concat(generatedRows);\n            })\n            .withIndex(pair => pair[0])\n            .inflate(pair => pair[1])\n            .concat(this.tail(1));\n            \n    }\n\n    /**\n     * Returns the specified default dataframe if the dataframe is empty. \n     *\n     * @param defaultDataFrame Default dataframe to return if the dataframe is empty.\n     * \n     * @return Returns 'defaultDataFrame' if the dataframe is empty. \n     * \n     * @example\n     * <pre>\n     * \n     * const emptyDataFrame = new DataFrame();\n     * const defaultDataFrame = new DataFrame([ { A: 1 }, { A: 2 }, { A: 3 } ]);\n     * expect(emptyDataFrame.defaultIfEmpty(defaultDataFrame)).to.eql(defaultDataFrame);\n     * </pre>\n     * \n     * @example\n     * <pre>\n     * \n     * const nonEmptyDataFrame = new DataFrame([ { A: 100 }]);\n     * const defaultDataFrame = new DataFrame([ { A: 1 }, { A: 2 }, { A: 3 } ]);\n     * expect(nonEmptyDataFrame.defaultIfEmpty(defaultDataFrame)).to.eql(nonEmptyDataFrame);\n     * </pre>\n     */\n    defaultIfEmpty (defaultDataFrame: ValueT[] | IDataFrame<IndexT, ValueT>): IDataFrame<IndexT, ValueT> {\n\n        if (this.none()) {\n            if (defaultDataFrame instanceof DataFrame) {\n                return <IDataFrame<IndexT, ValueT>> defaultDataFrame;\n            }\n            else if (isArray(defaultDataFrame)) {\n                return new DataFrame<IndexT, ValueT>(defaultDataFrame);\n            }\n            else {\n                throw new Error(\"Expected 'defaultSequence' parameter to 'DataFrame.defaultIfEmpty' to be an array or a series.\");\n            }\n        } \n        else {\n            return this;\n        }\n    }\n\n    /**\n     * Detect the the frequency of the types of the values in the dataframe.\n     * This is a good way to understand the shape of your data.\n     *\n     * @return Returns a dataframe with rows that confirm to {@link ITypeFrequency} that describes the data types contained in the original dataframe.\n     * \n     * @example\n     * <pre>\n     * \n     * const df = dataForge.readFileSync(\"./my-data.json\").parseJSON();\n     * const dataTypes = df.detectTypes();\n     * console.log(dataTypes.toString());\n     * </pre>\n     */\n    detectTypes (): IDataFrame<number, ITypeFrequency> {\n        return new DataFrame<number, ITypeFrequency>(() => {\n            const typeFrequencies = this.getColumns()\n                .selectMany(column => {\n                    return column.series.detectTypes()\n                        .select((typeFrequency: any) => {\n                            const output = Object.assign({}, typeFrequency);\n                            output.Column = column.name;\n                            return output;\n                        });\n                });\n            return {\n                columnNames: [\"Type\", \"Frequency\", \"Column\"],\n                values: typeFrequencies,\n            };\n        });\n    }\n    \n    /**\n     * Detect the frequency of the values in the dataframe.\n     * This is a good way to understand the shape of your data.\n     *\n     * @return Returns a dataframe with rows that conform to {@link IValueFrequency} that describes the values contained in the dataframe.\n     * \n     * @example\n     * <pre>\n     * \n     * const df = dataForge.readFileSync(\"./my-data.json\").parseJSON();\n     * const dataValues = df.detectedValues();\n     * console.log(dataValues.toString());\n     * </pre>\n     */\n    detectValues (): IDataFrame<number, IValueFrequency> {\n        return new DataFrame<number, IValueFrequency>(() => {\n            const valueFrequencies = this.getColumns()\n                .selectMany(column => {\n                    return column.series.detectValues()\n                        .select((valueFrequency: any) => {\n                            const output = Object.assign({}, valueFrequency);\n                            output.Column = column.name;\n                            return output;\n                        });\n                });\n            return {\n                columnNames: [\"Value\", \"Frequency\", \"Column\"],\n                values: valueFrequencies,\n            };\n        });\n    }\n\n    /**\n     * Serialize the dataframe to the JSON data format.\n     * \n     * @return Returns a string in the JSON data format that represents the dataframe.\n     * \n     * @example\n     * <pre>\n     * \n     * const jsonData = df.toJSON();\n     * console.log(jsonData);\n     * </pre>\n     */\n    toJSON (): string {\n        return JSON.stringify(this.toArray(), null, 4);\n    }\n\n    /**\n     * Serialize the dataframe to the CSV data format.\n     * \n     * @return Returns a string in the CSV data format that represents the dataframe.\n     * \n     * @example\n     * <pre>\n     * \n     * const csvData = df.toCSV();\n     * console.log(csvData);\n     * </pre>\n     * \n     * @example\n     * <pre>\n     * \n     * const csvData = df.toCSV({ header: false });\n     * console.log(csvData);\n     * </pre>\n     */\n    toCSV (options?: ICSVOutputOptions): string {\n        const headerLine = options === undefined || options.header === undefined || options.header\n            ? [this.getColumnNames()]\n            : []\n            ;\n        const rows = headerLine.concat(this.toRows());\n        return PapaParse.unparse(rows, options);\n    }\n\n    /**\n     * Serialize the dataframe to HTML.\n     * \n     * @return Returns a string in HTML format that represents the dataframe.\n     */\n    toHTML (): string {\n\n        const columNames = this.getColumnNames();\n        const header = columNames.map(columnName => \"            <th>\" + columnName + \"</th>\").join(\"\\n\");\n        const pairs = this.toPairs();\n\n        return '<table border=\"1\" class=\"dataframe\">\\n' + \n            '    <thead>\\n' +\n            '        <tr style=\"text-align: right;\">\\n' +\n            '            <th></th>\\n' +\n\n            header +\n\n            '\\n' +\n            '       </tr>\\n' +\n            '    </thead>\\n' +\n            '    <tbody>\\n' +\n\n            pairs.map(pair => {\n                const index = pair[0];\n                const value: any = pair[1];\n                return '        <tr>\\n' +\n                    '            <th>' + index + '</th>\\n' +\n                    columNames.map(columName => {\n                            return '            <td>' + value[columName] + '</td>';\n                        })\n                        .join('\\n') +\n                        '\\n' +\n                        '        </tr>';\n                })\n                .join('\\n') +\n\n            '\\n' +\n            '    </tbody>\\n' +\n            '</table>';\n    }    \n\n    /**\n     * Serialize the dataframe to an ordinary JavaScript data structure.\n     * The resulting data structure is suitable for further serialization to JSON and can be used to \n     * transmit a DataFrame and its internal structure over the wire.\n     * Use the {@link deserialize} function to later reconstitute the serialized dataframe.\n     * \n     * @return Returns a JavaScript data structure conforming to {@link ISerializedDataFrame} that represents the dataframe and its internal structure.\n     * \n     * @example\n     * <pre>\n     * \n     * const jsDataStructure = df.serialize();\n     * const jsonData = JSON.stringify(jsDataStructure);\n     * console.log(jsonData);\n     * const deserializedJsDataStructure = JSON.parse(jsonData);\n     * const deserializedDf = DataFrame.deserialize(deserializedJsDataStructure); // Reconsituted.\n     * </pre>\n     */\n    serialize (): ISerializedDataFrame {\n        let rows = this.toArray(); // Bake the dataframe to an array.\n        const index = this.getIndex(); // Extract the index.\n        let indexValues = index.head(rows.length).toArray() as any[];\n        const columns = this.getColumns();\n        const serializedColumns = toMap(columns, column => column.name, column => column.type);\n        const indexType = index.getType();\n        \n        if (indexType === \"date\") {\n            indexValues = indexValues.map(index => moment(index).toISOString()); // Manually serialize date value, they aren't supported directly by JSON.\n        }\n\n        let cloned = false;\n\n        // Serialize date values.\n        for (const column of columns) {\n            if (column.type === \"date\") {\n                if (!cloned) {\n                    rows = rows.map(row => Object.assign({}, row)); // Clone so we don't modify any original data.\n                    cloned = true;\n                }\n\n                for (const row of rows) {\n                    row[column.name] = moment(row[column.name]).toISOString(); // Manually serialize date value.\n                }\n            }\n        }\n        \n        return {\n            columnOrder: this.getColumnNames(),\n            columns: serializedColumns,\n            index: {\n                type: indexType,\n                values: indexValues,\n            },\n            values: rows,\n        };\n    }\n\n    /**\n     * Deserialize the dataframe from an ordinary JavaScript data structure.\n     * Can reconstitute a dataframe that previously serialized with the {@link serialize} function.\n     * This can rebuilds the dataframe with the exact same internal structure after it has been transmitted over the wire.\n     * \n     * @param input The serialize JavaScript data structure for the dataframe.\n     * \n     * @return Returns the deserialized/reconstituted dataframe.    \n     * \n     * @example\n     * <pre>\n     * \n     * const jsDataStructure = df.serialize();\n     * const jsonData = JSON.stringify(jsDataStructure);\n     * console.log(jsonData);\n     * const deserializedJsDataStructure = JSON.parse(jsonData);\n     * const deserializedDf = DataFrame.deserialize(deserializedJsDataStructure); // Reconsituted.\n     * </pre>\n     */\n    static deserialize<IndexT = any,  ValueT = any> (input: ISerializedDataFrame): IDataFrame<IndexT, ValueT> {\n\n        let indexValues = input.index && input.index.values || [];\n        let rows = input.values && input.values || [];\n        let cloned = false;\n\n        // Deserialize dates.\n        if (input.columns) {\n            for (const columnName of Object.keys(input.columns)) {\n                if (input.columns[columnName] !== \"date\") {\n                    continue; // No need to process other types, they are natively supported by JSON.\n                }\n\n                if (!cloned) {\n                    rows = rows.map(row => Object.assign({}, row)); // Clone so we don't modify any original data.\n                    cloned = true;\n                }\n    \n                for (const row of rows) {\n                    row[columnName] = moment(row[columnName]).toDate(); // Manually deserialize data value.\n                }\n            }\n        }\n\n        if (input.index && input.index.type === \"date\") {\n            indexValues = indexValues.map(value => moment(value).toDate()); // Manually deserialize data value.\n        }\n\n        return new DataFrame<IndexT, ValueT>({\n            columnNames: input.columnOrder || [],\n            index: indexValues,\n            values: rows,\n        });\n    }\n\n    /***\n     * Allows the dataframe to be queried to confirm that it is actually a dataframe.\n     * Used from JavaScript to tell the difference between a Series and a DataFrame.\n     * \n     * @return Returns the string \"dataframe\".\n     */\n    getTypeCode (): string {\n        return \"dataframe\";\n    }\n}\n\n/**\n * @hidden\n * The configuration for an ordered dataframe.\n */\ninterface IOrderedDataFrameConfig<IndexT, ValueT, SortT> {\n    //\n    // The order of columns for the data frame.\n    //\n    columnNames: string[] | Iterable<string>;\n\n    //\n    // The source values for the ordered dataframe.\n    //\n    values: Iterable<ValueT>;\n\n    //\n    // The source pairs (index,value) for the ordered dataframe.\n    //\n    pairs: Iterable<[IndexT, ValueT]>;\n\n    //\n    // The selector used to get the sorting key for the orderby operation.\n    //\n    selector: SelectorWithIndexFn<ValueT, SortT>;\n\n    //\n    // The sort direction, ascending or descending.\n    //\n    direction: Direction;\n\n    //\n    // The parent dataframe in the orderby operation or null if none.\n    //\n    parent: OrderedDataFrame<IndexT, ValueT, any> | null;\n}\n\n/**\n * @hidden\n * Represents a dataframe that has been sorted.\n */\nclass OrderedDataFrame<IndexT = number, ValueT = any, SortT = any> \n    extends DataFrame<IndexT, ValueT>\n    implements IOrderedDataFrame<IndexT, ValueT, SortT> {\n\n    //\n    // Configuration for the ordered dataframe.\n    //\n    private config: IOrderedDataFrameConfig<IndexT, ValueT, SortT>;\n\n    //\n    // Helper function to create a sort spec.\n    //\n    private static makeSortSpec (sortLevel: number, selector: SortSelectorFn, direction: Direction): ISortSpec {\n        return { sortLevel: sortLevel, selector: selector, direction: direction };\n    }\n\n    //\n    // Helper function to make a sort selector for pairs, this captures the parent correct when generating the closure.\n    //\n    private static makePairsSelector (selector: SortSelectorFn): SortSelectorFn {\n        return (pair: any, index: number) => selector(pair[1], index);\n    }\n\n    constructor(config: IOrderedDataFrameConfig<IndexT, ValueT, SortT>) {\n\n        const valueSortSpecs: ISortSpec[] = [];\n        const pairSortSpecs: ISortSpec[] = [];\n        let sortLevel = 0;\n\n        let parent = config.parent;\n        const parents = [];\n        while (parent !== null) {\n            parents.push(parent);\n            parent = parent.config.parent;\n        }\n\n        parents.reverse();\n\n        for (const parent of parents) {\n            const parentConfig = parent.config;\n            valueSortSpecs.push(OrderedDataFrame.makeSortSpec(sortLevel, parentConfig.selector, parentConfig.direction));\n            pairSortSpecs.push(OrderedDataFrame.makeSortSpec(sortLevel, OrderedDataFrame.makePairsSelector(parentConfig.selector), parentConfig.direction));\n            ++sortLevel;\n        }\n\n        valueSortSpecs.push(OrderedDataFrame.makeSortSpec(sortLevel, config.selector, config.direction));\n        pairSortSpecs.push(OrderedDataFrame.makeSortSpec(sortLevel, OrderedDataFrame.makePairsSelector(config.selector), config.direction));\n\n        super({\n            columnNames: config.columnNames,\n            values: new OrderedIterable(config.values, valueSortSpecs),\n            pairs: new OrderedIterable(config.pairs, pairSortSpecs)\n        });\n\n        this.config = config;\n    }\n\n    /** \n     * Applys additional sorting (ascending) to an already sorted dataframe.\n     * \n     * @param selector User-defined selector that selects the additional value to sort by.\n     * \n     * @return Returns a new dataframe has been additionally sorted by the value chosen by the selector function. \n     * \n     * @example\n     * <pre>\n     * \n     * // Order sales by salesperson and then by amount (from least to most).\n     * const orderedDf = salesDf.orderBy(sale => sale.SalesPerson).thenBy(sale => sale.Amount);\n     * </pre>\n     */\n    thenBy<SortT> (selector: SelectorWithIndexFn<ValueT, SortT>): IOrderedDataFrame<IndexT, ValueT, SortT> {\n        return new OrderedDataFrame<IndexT, ValueT, SortT>({\n            columnNames: this.config.columnNames,\n            values: this.config.values, \n            pairs: this.config.pairs, \n            selector: selector, \n            direction: Direction.Ascending, \n            parent: this,\n        });\n    }\n\n    /** \n     * Applys additional sorting (descending) to an already sorted dataframe.\n     * \n     * @param selector User-defined selector that selects the additional value to sort by.\n     * \n     * @return Returns a new dataframe has been additionally sorted by the value chosen by the selector function. \n     * \n     * @example\n     * <pre>\n     * \n     * // Order sales by salesperson and then by amount (from most to least).\n     * const orderedDf = salesDf.orderBy(sale => sale.SalesPerson).thenByDescending(sale => sale.Amount);\n     * </pre>\n     */\n    thenByDescending<SortT> (selector: SelectorWithIndexFn<ValueT, SortT>): IOrderedDataFrame<IndexT, ValueT, SortT> {\n        return new OrderedDataFrame<IndexT, ValueT, SortT>({\n            columnNames: this.config.columnNames,\n            values: this.config.values, \n            pairs: this.config.pairs, \n            selector: selector, \n            direction: Direction.Descending, \n            parent: this,\n        });\n    }\n}","export { Index, IIndex } from './lib/index';\nexport { Series, ISeries, SelectorWithIndexFn } from './lib/series';\nexport { DataFrame, IDataFrame } from './lib/dataframe';\nimport { ArrayIterable } from './lib/iterables/array-iterable';\nimport { CsvRowsIterable } from './lib/iterables/csv-rows-iterable';\nimport { Series, ISeries } from '.';\nimport { DataFrame, IDataFrame } from '.';\nimport { isString, isObject, isArray, isNumber } from './lib/utils';\nimport { isFunction } from 'util';\n\nconst PapaParse = require('papaparse');\n\n/**\n * Represents a field from a JavaScript object.\n */\nexport interface IFieldRecord {\n    /**\n     * The name of the field.\n     */\n    Field: string;\n\n    /**\n     * The value of the field.\n     */\n    Value: any;\n};\n\n/**\n * Convert a regular JavaScript obejct to a dataframe.\n * Each row in the dataframe represents a field from the object.\n * \n * @param obj - The JavaScript object to convert to a dataframe.\n * \n * @returns Returns a dataframe that lists the fields in the pass-in object.\n */\nexport function fromObject (obj: any): IDataFrame<number, IFieldRecord> {\n    return new DataFrame<number, IFieldRecord>(\n        Object.keys(obj)\n            .map(fieldName => ({\n                Field: fieldName,\n                Value: obj[fieldName],\n            }))\n    );\n}\n\n/**\n * Deserialize a dataframe from a JSON text string.\n *\n * @param jsonTextString The JSON text to deserialize.\n * \n * @returns Returns a dataframe that has been deserialized from the JSON data.\n */\nexport function fromJSON (jsonTextString: string): IDataFrame<number, any> {\n    \n    if (!isString(jsonTextString)) throw new Error(\"Expected 'jsonTextString' parameter to 'dataForge.fromJSON' to be a string containing data encoded in the JSON format.\");\n\n    return new DataFrame<number, any>({\n        values: JSON.parse(jsonTextString)\n    });\n}\n\n/**\n * Options for parsing CSV data.\n */\nexport interface ICSVOptions {\n    /**\n     * Optionally specifies the column names (when enabled, assumes that the header row is not read from the CSV data).\n     * Default: undefined\n     */\n    columnNames?: Iterable<string>;\n\n    /**\n     * Automatically pick types based on what the value looks like.\n     * Default: false.\n     */\n    dynamicTyping?: boolean;\n\n    /**\n     * Skip empty lines in the input.\n     * Default: true\n     */\n    skipEmptyLines?: boolean;\n}\n\n/**\n * Deserialize a DataFrame from a CSV text string.\n *\n * @param csvTextString The CSV text to deserialize.\n * @param [config] Optional configuration options for parsing the CSV data.\n * \n * @returns Returns a dataframe that has been deserialized from the CSV data.\n */\nexport function fromCSV (csvTextString: string, config?: ICSVOptions) {\n    if (!isString(csvTextString)) throw new Error(\"Expected 'csvTextString' parameter to 'dataForge.fromCSV' to be a string containing data encoded in the CSV format.\");\n\n    if (config) {\n        if (!isObject(config)) throw new Error(\"Expected 'config' parameter to 'dataForge.fromCSV' to be an object with CSV parsing configuration options.\");\n\n        if (config.columnNames) {\n            if (!isFunction(config.columnNames[Symbol.iterator])) {\n                if (!isArray(config.columnNames)) throw new Error(\"Expect 'columnNames' field of 'config' parameter to DataForge.fromCSV to be an array or iterable of strings that specifies column names.\")\n            }\n\n\n            for (const columnName of config.columnNames) {\n                if (!isString(columnName)) throw new Error(\"Expect 'columnNames' field of 'config' parameter to DataForge.fromCSV to be an array of strings that specify column names.\")\n            }\n        }\n        \n        if (config.skipEmptyLines === undefined) {\n            config = Object.assign({}, config); // Clone the config. Don't want to modify the original.\n            config.skipEmptyLines = true;\n        }\n    }\n    else {\n        config = {\n            skipEmptyLines: true,\n        }\n    }\n\n    const parsed = PapaParse.parse(csvTextString, config as any);\n    let rows = <string[][]> parsed.data;\n\n    if (rows.length === 0) {\n        return new DataFrame<number, any>();\n    }\n\n    let columnNames;\n    rows = rows.map(row => {\n            return row.map(cell => isString(cell) ? cell.trim() : cell); // Trim each cell that is still a string.\n        });\n\n    if (config && config.columnNames) {\n        columnNames = config.columnNames;\n    }\n    else {\n        columnNames = rows.shift();\n    }\n\n    return new DataFrame<number, any>({\n        rows: rows,\n        columnNames: columnNames,\n    });\n}\n\nconst concat = Series.concat;\n\n/**\n * Concatenate multiple series into a single series.\n * THIS FUNCTION IS DEPRECATED. Instead use dataFrame.Series.concat.\n * \n * @param {array} series - Array of series to concatenate.\n *\n * @returns {Series} - Returns the single concatendated series.  \n */\nexport { concat as concatSeries };\n\nconst zip = Series.zip;\n\n/**\n * Zip together multiple series to create a new series.\n * THIS FUNCTION IS DEPRECATED. Instead use dataFrame.Series.zip.\n *\n * @param {array} series - Array of series to zip together.\n * @param {function} selector - Selector function that produces a new series based on the input series.\n * \n * @returns {Series} Returns a single series that is the combination of multiple input series that have been 'zipped' together by the 'selector' function.\n */\nexport { zip as zipSeries }\n\n/**\n * Generate a series from a range of numbers.\n *\n * @param start - The value of the first number in the range.\n * @param count - The number of sequential values in the range.\n * \n * @returns Returns a series with a sequence of generated values. The series contains 'count' values beginning at 'start'. \n */\nexport function range (start: number, count: number): ISeries<number, number> {\n\n    if (!isNumber(start)) throw new Error(\"Expect 'start' parameter to 'dataForge.range' function to be a number.\");\n    if (!isNumber(count)) throw new Error(\"Expect 'count' parameter to 'dataForge.range' function to be a number.\");\n\n    const values: number[] = [];\n    for (let valueIndex = 0; valueIndex < count; ++valueIndex) {\n        values.push(start + valueIndex);\n    }\n\n    return new Series<number, number>(values);\n}\n\n/**\n * Replicate a particular value N times to create a series.\n * \n * @param value The value to replicate.\n * @param count The number of times to replicate the value.\n * \n * @returns Returns a new series that contains N copies of the value.\n */\nexport function replicate<ValueT> (value: ValueT, count: number): ISeries<number, ValueT> {\n    const values: ValueT[] = [];\n    for (let i = 0; i < count; ++i) {\n        values.push(value);\n    }\n\n    return new Series<number, ValueT>(values);\n}\n\n/**\n * Generate a data-frame containing a matrix of values.\n *\n * @param numColumns - The number of columns in the data-frame.\n * @param numRows - The number of rows in the data-frame.\n * @param start - The starting value.\n * @param increment - The value to increment by for each new value.\n * \n * @returns Returns a dataframe that contains a matrix of generated values.\n */\nexport function matrix (numColumns: number, numRows: number, start: number, increment: number): IDataFrame<number, any> {\n    if (!isNumber(numColumns)) throw new Error(\"Expect 'numColumns' parameter to 'dataForge.matrix' function to be a number.\");\n    if (!isNumber(numRows)) throw new Error(\"Expect 'numRows' parameter to 'dataForge.matrix' function to be a number.\");\n    if (!isNumber(start)) throw new Error(\"Expect 'start' parameter to 'dataForge.matrix' function to be a number.\");\n    if (!isNumber(increment)) throw new Error(\"Expect 'increment' parameter to 'dataForge.matrix' function to be a number.\");\n\n    const rows: number[][] = [];\n    const columnNames: string[] = [];\n    var nextValue = start;\n\n    for (let colIndex = 0; colIndex < numColumns; ++colIndex) {\n        columnNames.push((colIndex+1).toString());\n    }\n    \n    for (let rowIndex = 0; rowIndex < numRows; ++rowIndex) {\n        var row: number[] = [];\n\n        for (let colIndex = 0; colIndex < numColumns; ++colIndex) {\n            row.push(nextValue + (colIndex * increment));\n        }\n\n        nextValue += numColumns * increment;\n        rows.push(row);\n    }\n\n    return new DataFrame({\n        columnNames: columnNames,\n        rows: rows,\n    });\n}\n","import * as moment from \"dayjs\";\nconst t = require('typy').default;\n\n//\n// Various shared utility functions.\n//\n\nexport function* mapIterable<InT, OutT> (items: Iterable<InT>, mapFn: (item: InT) => OutT): Iterable<OutT> {\n    const iterator = items[Symbol.iterator]();\n    while (true) {\n        let result = iterator.next();\n        if (result.done) {\n            break;\n        }\n        yield mapFn(result.value);\n    }\n}\n\n//\n// Helper function to only return distinct items.\n//\nexport function makeDistinct<ItemT, KeyT>(items: Iterable<ItemT>, selector?: (item: ItemT) => KeyT): ItemT[] {\n    let set: any = {};\n    let output: any[] = [];\n    for (const item of items) {\n        var key = selector && selector(item) || item;\n        if (!set[key]) {\n            // Haven't yet seen this key.\n            set[key] = true;\n            output.push(item);\n        }\n    }\n\n    return output;\n}\n\n//\n// Helper function to map an array of objects.\n//\nexport function toMap<InT, KeyT, ValueT>(items: Iterable<InT>, keySelector: (item: InT) => KeyT, valueSelector: (item: InT) => ValueT): any {\n    let output: any = {};\n    for (const item of items) {\n        var key = keySelector(item);\n        output[key] = valueSelector(item);\n    }\n    return output;\n}\n\n//\n// Helper function to map an array of objects.\n//\nexport function toMap2<InT, KeyT, ValueT>(items: Iterable<InT>, keySelector: (item: InT) => KeyT, valueSelector: (item: InT) => ValueT): Map<KeyT, ValueT> {\n    let output = new Map<KeyT, ValueT>();\n    for (const item of items) {\n        output.set(keySelector(item), valueSelector(item));\n    }\n    return output;\n}\n\n//\n// Determine the type of a value.\n//\nexport function determineType (value: any): string {\n    if (value === undefined) {\n        return \"undefined\";\n    }\n    else if (isNumber(value)) {\n        return \"number\";\n    }\n    else if (isString(value)) {\n        return \"string\";\n    }\n    else if (value instanceof Date) {\n        return \"date\";\n    }\n    else if (isBoolean(value)) {\n        return \"boolean\";\n    }\n    else {\n        return \"unsupported\";\n    }\n}\n\nexport function isObject(v: any): boolean {\n    return t(v).isObject && !isDate(v);\n}\n\nexport function isFunction(v: any): v is Function {\n    return t(v).isFunction;\n}\n\nexport function isString(v: any): v is string {\n    return t(v).isString;\n}\n\nexport function isDate(v: any): v is Date {\n    return Object.prototype.toString.call(v) === \"[object Date]\";\n}\n\nexport function isBoolean(v: any): v is boolean {\n    return t(v).isBoolean;\n}\n\nexport function isNumber(v: any): v is number {\n    return t(v).isNumber;\n}\n\nexport function isArray(v: any): v is Array<any> {\n    return t(v).isArray;\n}\n\nexport function isUndefined(v: any): boolean {\n    return v === undefined;\n}\n","import { ISeries, Series, SeriesConfigFn } from './series';\r\nimport * as moment from \"dayjs\";\r\nimport { determineType } from './utils';\r\n\r\n/**\r\n * A predicate function for testing a value against another.\r\n */\r\nexport type PredicateFn = (value: any, against: any) => boolean;\r\n\r\n/**\r\n * Interface that represents an index for a Series.\r\n */\r\nexport interface IIndex<IndexT> extends ISeries<number, IndexT> {\r\n\r\n    /**\r\n     * Get the type of the index.\r\n     * \r\n     * @returns Returns a string that specifies the type of the index.\r\n     */\r\n    getType (): string;\r\n\r\n    /**\r\n     * Get the less than operation for the index.\r\n     * \r\n     * @returns Returns a function that can be used to compare a value against an index value.\r\n     */\r\n    getLessThan (): PredicateFn;\r\n\r\n    /**\r\n     * Get the less than or equal to operation for the index.\r\n     * \r\n     * @returns Returns a function that can be used to compare a value against an index value.\r\n     */\r\n    getLessThanOrEqualTo (): PredicateFn;\r\n\r\n    /**\r\n     * Get the greater than operation for the index.\r\n     * \r\n     * @returns Returns a function that can be used to compare a value against an index value.\r\n     */\r\n    getGreaterThan (): PredicateFn;\r\n    \r\n}\r\n\r\n/**\r\n * Class that represents an index for a Series.\r\n */\r\nexport class Index<IndexT> extends Series<number, IndexT> implements IIndex<IndexT> {\r\n\r\n    //\r\n    // Records the type of the index.\r\n    //\r\n    private _type?: string;\r\n\r\n    constructor(config?: any | SeriesConfigFn<number, IndexT>) {\r\n        super(config);\r\n    }\r\n\r\n    /**\r\n     * Get the type of the index.\r\n     * \r\n     * @returns Returns a string that specifies the type of the index.\r\n     */\r\n    getType (): string {\r\n\r\n        if (!this._type) {\r\n            //\r\n            // Detect the type.\r\n            //\r\n            if (this.any()) {\r\n                this._type = determineType(this.first());\r\n            }\r\n            else {\r\n                this._type = 'empty';\r\n            }\r\n        }\r\n\r\n        return this._type;\r\n    };\r\n\r\n    /**\r\n     * Get the less than operation for the index.\r\n     * \r\n     * @returns Returns a function that can be used to compare a value against an index value.\r\n     */\r\n    getLessThan (): PredicateFn {\r\n\r\n        switch (this.getType()) {\r\n            case \"date\":\r\n                return (d1: Date, d2: Date) => moment(d1).isBefore(d2);\r\n\r\n            case \"string\":\r\n            case \"number\":\r\n                return (v1: any, v2: any) => v1 < v2;\r\n\r\n            case \"empty\":\r\n                return () => true; // Series is empty, so this makes no difference.\r\n\r\n            default:\r\n                throw new Error(\"No less than operation available for type: \" + this.getType());\r\n        }\r\n    };\r\n\r\n    /**\r\n     * Get the less than or equal to operation for the index.\r\n     * \r\n     * @returns Returns a function that can be used to compare a value against an index value.\r\n     */\r\n    getLessThanOrEqualTo (): PredicateFn {\r\n        return (v1: any, v2: any) => !this.getGreaterThan()(v1, v2); //TODO: Should expand  this out.\r\n    }\r\n    \r\n    /**\r\n     * Get the greater than operation for the index.\r\n     * \r\n     * @returns Returns a function that can be used to compare a value against an index value.\r\n     */\r\n    getGreaterThan (): PredicateFn {\r\n\r\n        switch (this.getType()) {\r\n            case \"date\":\r\n                return (d1: Date, d2: Date) => moment(d1).isAfter(d2);\r\n\r\n            case \"string\":\r\n            case \"number\":\r\n                return (v1: any, v2: any) => v1 > v2;\r\n\r\n            case \"empty\":\r\n                return () => true; // Series is empty, so this makes no difference.\r\n\r\n            default:\r\n                throw new Error(\"No greater than operation available for type: \" + this.getType());\r\n        }\r\n    };\r\n\r\n}\r\n","//\r\n// An iterator that iterates the elements of an array.\r\n//\r\n\r\nexport class ArrayIterator<T> implements Iterator<T> {\r\n\r\n    arr: T[];\r\n\r\n    index: number = 0;\r\n\r\n    constructor(arr: T[]) {\r\n        this.arr = arr;\r\n    }\r\n\r\n    next(): IteratorResult<T> {\r\n        if (this.index < this.arr.length) {\r\n            return {\r\n                done: false, \r\n                value: this.arr[this.index++],\r\n            };\r\n        }\r\n        else {\r\n            // https://github.com/Microsoft/TypeScript/issues/8938\r\n            return ({ done: true } as IteratorResult<T>)  // <= explicit cast here!;\r\n        }\r\n    }\r\n\r\n}","!function(t,n){\"object\"==typeof exports&&\"undefined\"!=typeof module?module.exports=n():\"function\"==typeof define&&define.amd?define(n):t.dayjs=n()}(this,function(){\"use strict\";var t=\"millisecond\",n=\"second\",e=\"minute\",i=\"hour\",r=\"day\",s=\"week\",u=\"month\",a=\"quarter\",o=\"year\",h=/^(\\d{4})-?(\\d{1,2})-?(\\d{0,2})[^0-9]*(\\d{1,2})?:?(\\d{1,2})?:?(\\d{1,2})?.?(\\d{1,3})?$/,f=/\\[([^\\]]+)]|Y{2,4}|M{1,4}|D{1,2}|d{1,4}|H{1,2}|h{1,2}|a|A|m{1,2}|s{1,2}|Z{1,2}|SSS/g,c=function(t,n,e){var i=String(t);return!i||i.length>=n?t:\"\"+Array(n+1-i.length).join(e)+t},d={s:c,z:function(t){var n=-t.utcOffset(),e=Math.abs(n),i=Math.floor(e/60),r=e%60;return(n<=0?\"+\":\"-\")+c(i,2,\"0\")+\":\"+c(r,2,\"0\")},m:function(t,n){var e=12*(n.year()-t.year())+(n.month()-t.month()),i=t.clone().add(e,u),r=n-i<0,s=t.clone().add(e+(r?-1:1),u);return Number(-(e+(n-i)/(r?i-s:s-i))||0)},a:function(t){return t<0?Math.ceil(t)||0:Math.floor(t)},p:function(h){return{M:u,y:o,w:s,d:r,h:i,m:e,s:n,ms:t,Q:a}[h]||String(h||\"\").toLowerCase().replace(/s$/,\"\")},u:function(t){return void 0===t}},$={name:\"en\",weekdays:\"Sunday_Monday_Tuesday_Wednesday_Thursday_Friday_Saturday\".split(\"_\"),months:\"January_February_March_April_May_June_July_August_September_October_November_December\".split(\"_\")},l=\"en\",m={};m[l]=$;var y=function(t){return t instanceof S},M=function(t,n,e){var i;if(!t)return null;if(\"string\"==typeof t)m[t]&&(i=t),n&&(m[t]=n,i=t);else{var r=t.name;m[r]=t,i=r}return e||(l=i),i},g=function(t,n,e){if(y(t))return t.clone();var i=n?\"string\"==typeof n?{format:n,pl:e}:n:{};return i.date=t,new S(i)},D=d;D.l=M,D.i=y,D.w=function(t,n){return g(t,{locale:n.$L,utc:n.$u})};var S=function(){function c(t){this.$L=this.$L||M(t.locale,null,!0)||l,this.parse(t)}var d=c.prototype;return d.parse=function(t){this.$d=function(t){var n=t.date,e=t.utc;if(null===n)return new Date(NaN);if(D.u(n))return new Date;if(n instanceof Date)return new Date(n);if(\"string\"==typeof n&&!/Z$/i.test(n)){var i=n.match(h);if(i)return e?new Date(Date.UTC(i[1],i[2]-1,i[3]||1,i[4]||0,i[5]||0,i[6]||0,i[7]||0)):new Date(i[1],i[2]-1,i[3]||1,i[4]||0,i[5]||0,i[6]||0,i[7]||0)}return new Date(n)}(t),this.init()},d.init=function(){var t=this.$d;this.$y=t.getFullYear(),this.$M=t.getMonth(),this.$D=t.getDate(),this.$W=t.getDay(),this.$H=t.getHours(),this.$m=t.getMinutes(),this.$s=t.getSeconds(),this.$ms=t.getMilliseconds()},d.$utils=function(){return D},d.isValid=function(){return!(\"Invalid Date\"===this.$d.toString())},d.isSame=function(t,n){var e=g(t);return this.startOf(n)<=e&&e<=this.endOf(n)},d.isAfter=function(t,n){return g(t)<this.startOf(n)},d.isBefore=function(t,n){return this.endOf(n)<g(t)},d.$g=function(t,n,e){return D.u(t)?this[n]:this.set(e,t)},d.year=function(t){return this.$g(t,\"$y\",o)},d.month=function(t){return this.$g(t,\"$M\",u)},d.day=function(t){return this.$g(t,\"$W\",r)},d.date=function(t){return this.$g(t,\"$D\",\"date\")},d.hour=function(t){return this.$g(t,\"$H\",i)},d.minute=function(t){return this.$g(t,\"$m\",e)},d.second=function(t){return this.$g(t,\"$s\",n)},d.millisecond=function(n){return this.$g(n,\"$ms\",t)},d.unix=function(){return Math.floor(this.valueOf()/1e3)},d.valueOf=function(){return this.$d.getTime()},d.startOf=function(t,a){var h=this,f=!!D.u(a)||a,c=D.p(t),d=function(t,n){var e=D.w(h.$u?Date.UTC(h.$y,n,t):new Date(h.$y,n,t),h);return f?e:e.endOf(r)},$=function(t,n){return D.w(h.toDate()[t].apply(h.toDate(),(f?[0,0,0,0]:[23,59,59,999]).slice(n)),h)},l=this.$W,m=this.$M,y=this.$D,M=\"set\"+(this.$u?\"UTC\":\"\");switch(c){case o:return f?d(1,0):d(31,11);case u:return f?d(1,m):d(0,m+1);case s:var g=this.$locale().weekStart||0,S=(l<g?l+7:l)-g;return d(f?y-S:y+(6-S),m);case r:case\"date\":return $(M+\"Hours\",0);case i:return $(M+\"Minutes\",1);case e:return $(M+\"Seconds\",2);case n:return $(M+\"Milliseconds\",3);default:return this.clone()}},d.endOf=function(t){return this.startOf(t,!1)},d.$set=function(s,a){var h,f=D.p(s),c=\"set\"+(this.$u?\"UTC\":\"\"),d=(h={},h[r]=c+\"Date\",h.date=c+\"Date\",h[u]=c+\"Month\",h[o]=c+\"FullYear\",h[i]=c+\"Hours\",h[e]=c+\"Minutes\",h[n]=c+\"Seconds\",h[t]=c+\"Milliseconds\",h)[f],$=f===r?this.$D+(a-this.$W):a;if(f===u||f===o){var l=this.clone().set(\"date\",1);l.$d[d]($),l.init(),this.$d=l.set(\"date\",Math.min(this.$D,l.daysInMonth())).toDate()}else d&&this.$d[d]($);return this.init(),this},d.set=function(t,n){return this.clone().$set(t,n)},d.get=function(t){return this[D.p(t)]()},d.add=function(t,a){var h,f=this;t=Number(t);var c=D.p(a),d=function(n){var e=new Date(f.$d);return e.setDate(e.getDate()+n*t),D.w(e,f)};if(c===u)return this.set(u,this.$M+t);if(c===o)return this.set(o,this.$y+t);if(c===r)return d(1);if(c===s)return d(7);var $=(h={},h[e]=6e4,h[i]=36e5,h[n]=1e3,h)[c]||1,l=this.valueOf()+t*$;return D.w(l,this)},d.subtract=function(t,n){return this.add(-1*t,n)},d.format=function(t){var n=this;if(!this.isValid())return\"Invalid Date\";var e=t||\"YYYY-MM-DDTHH:mm:ssZ\",i=D.z(this),r=this.$locale(),s=r.weekdays,u=r.months,a=function(t,n,e,i){return t&&t[n]||e[n].substr(0,i)},o=function(t){return D.s(n.$H%12||12,t,\"0\")},h={YY:String(this.$y).slice(-2),YYYY:String(this.$y),M:String(this.$M+1),MM:D.s(this.$M+1,2,\"0\"),MMM:a(r.monthsShort,this.$M,u,3),MMMM:u[this.$M],D:String(this.$D),DD:D.s(this.$D,2,\"0\"),d:String(this.$W),dd:a(r.weekdaysMin,this.$W,s,2),ddd:a(r.weekdaysShort,this.$W,s,3),dddd:s[this.$W],H:String(this.$H),HH:D.s(this.$H,2,\"0\"),h:o(1),hh:o(2),a:this.$H<12?\"am\":\"pm\",A:this.$H<12?\"AM\":\"PM\",m:String(this.$m),mm:D.s(this.$m,2,\"0\"),s:String(this.$s),ss:D.s(this.$s,2,\"0\"),SSS:D.s(this.$ms,3,\"0\"),Z:i};return e.replace(f,function(t,n){return n||h[t]||i.replace(\":\",\"\")})},d.utcOffset=function(){return 15*-Math.round(this.$d.getTimezoneOffset()/15)},d.diff=function(t,h,f){var c,d=D.p(h),$=g(t),l=6e4*($.utcOffset()-this.utcOffset()),m=this-$,y=D.m(this,$);return y=(c={},c[o]=y/12,c[u]=y,c[a]=y/3,c[s]=(m-l)/6048e5,c[r]=(m-l)/864e5,c[i]=m/36e5,c[e]=m/6e4,c[n]=m/1e3,c)[d]||m,f?y:D.a(y)},d.daysInMonth=function(){return this.endOf(u).$D},d.$locale=function(){return m[this.$L]},d.locale=function(t,n){if(!t)return this.$L;var e=this.clone();return e.$L=M(t,n,!0),e},d.clone=function(){return D.w(this.toDate(),this)},d.toDate=function(){return new Date(this.$d)},d.toJSON=function(){return this.toISOString()},d.toISOString=function(){return this.$d.toISOString()},d.toString=function(){return this.$d.toUTCString()},c}();return g.prototype=S.prototype,g.extend=function(t,n){return t(n,S,g),g},g.locale=M,g.isDayjs=y,g.unix=function(t){return g(1e3*t)},g.en=m[l],g.Ls=m,g});\n","//\r\n// An iterable that returns no values.\r\n//\r\n\r\nimport { EmptyIterator } from '../iterators/empty-iterator';\r\n\r\nexport class EmptyIterable implements Iterable<any> {\r\n\r\n    [Symbol.iterator](): Iterator<any> {\r\n        return new EmptyIterator();\r\n    }\r\n}","//\r\n// An iterable that simply counts up from zero.\r\n// This creates the default index in Data-Forge.\r\n//\r\n\r\nimport { CountIterator } from '../iterators/count-iterator';\r\n\r\nexport class CountIterable implements Iterable<any> {\r\n\r\n    [Symbol.iterator](): Iterator<any> {\r\n        return new CountIterator();\r\n    }\r\n}","//\r\n// An iterable that allows multiple other iterables to be iterated at once.\r\n// This allows iterables to be composed.\r\n// This is used in Data-Forge to combine iterables for index and values.\r\n//\r\n\r\nimport { MultiIterator } from '../iterators/multi-iterator';\r\n\r\nexport class MultiIterable implements Iterable<any[]> {\r\n\r\n    iterables: Iterable<any>[];\r\n\r\n    constructor(iterables: Iterable<any>[]) {\r\n        this.iterables = iterables;\r\n    }\r\n\r\n    [Symbol.iterator](): Iterator<any> {\r\n        var iterators: Iterator<any>[] = [];\r\n\r\n        for (const iterable of this.iterables) {\r\n            iterators.push(iterable[Symbol.iterator]());\r\n        }\r\n\r\n        return new MultiIterator(iterators);\r\n    }\r\n}","//\r\n// An iterable that applies a selector function to each item.\r\n//\r\n\r\nimport { SelectorFn, SelectIterator } from '../iterators/select-iterator';\r\n\r\nexport class SelectIterable<ValueT, ToT> implements Iterable<ToT> {\r\n\r\n    iterable: Iterable<ValueT>;\r\n    selector: SelectorFn<ValueT, ToT>;\r\n\r\n    constructor(iterable: Iterable<ValueT>, selector: SelectorFn<ValueT, ToT>) {\r\n        this.iterable = iterable;\r\n        this.selector = selector;\r\n    }\r\n\r\n    [Symbol.iterator](): Iterator<ToT> {\r\n        var iterator = this.iterable[Symbol.iterator]();\r\n        return new SelectIterator<ValueT, ToT>(iterator, this.selector);\r\n    }\r\n}","//\r\n// An iterable that applies a selector function to each item.\r\n//\r\n\r\nimport { SelectorFn, SelectManyIterator } from '../iterators/select-many-iterator';\r\n\r\nexport class SelectManyIterable<ValueT, ToT> implements Iterable<ToT> {\r\n\r\n    iterable: Iterable<ValueT>;\r\n    selector: SelectorFn<ValueT, ToT>;\r\n\r\n    constructor(iterable: Iterable<ValueT>, selector: SelectorFn<ValueT, ToT>) {\r\n        this.iterable = iterable;\r\n        this.selector = selector;\r\n    }\r\n\r\n    [Symbol.iterator](): Iterator<ToT> {\r\n        var iterator = this.iterable[Symbol.iterator]();\r\n        return new SelectManyIterator<ValueT, ToT>(iterator, this.selector);\r\n    }\r\n}","//\r\n// An iterable that takes a certain number of elements from a child iterable.\r\n//\r\n\r\nimport { TakeIterator } from '../iterators/take-iterator';\r\n\r\nexport class TakeIterable<T> implements Iterable<T> {\r\n\r\n    childIterable: Iterable<T>;\r\n    numElements: number;\r\n\r\n    constructor(childIterable: Iterable<T>, numElements: number) {\r\n        this.childIterable = childIterable;\r\n        this.numElements = numElements;\r\n    }\r\n\r\n    [Symbol.iterator](): Iterator<any> {\r\n        var childIterator = this.childIterable[Symbol.iterator]();\r\n        return new TakeIterator(childIterator, this.numElements);\r\n    }\r\n}","//\r\n// An iterable that takes a sequence of elements while a predicate function returns true.\r\n//\r\n\r\nimport { TakeWhileIterator, PredicateFn } from '../iterators/take-while-iterator';\r\n\r\nexport class TakeWhileIterable<T> implements Iterable<T> {\r\n\r\n    childIterable: Iterable<T>;\r\n    predicate: PredicateFn<T>;\r\n\r\n    constructor(childIterable: Iterable<T>, predicate: PredicateFn<T>) {\r\n        this.childIterable = childIterable;\r\n        this.predicate = predicate;\r\n    }\r\n\r\n    [Symbol.iterator](): Iterator<any> {\r\n        var childIterator = this.childIterable[Symbol.iterator]();\r\n        return new TakeWhileIterator(childIterator, this.predicate);\r\n    }\r\n}","//\r\n// An iterable that takes elements from a child iterable based on a predicate function.\r\n//\r\n\r\nimport { WhereIterator, PredicateFn } from '../iterators/where-iterator';\r\n\r\nexport class WhereIterable<T> implements Iterable<T> {\r\n\r\n    childIterable: Iterable<T>;\r\n    predicate: PredicateFn<T>;\r\n\r\n    constructor(childIterable: Iterable<T>, predicate: PredicateFn<T>) {\r\n        this.childIterable = childIterable;\r\n        this.predicate = predicate;\r\n    }\r\n\r\n    [Symbol.iterator](): Iterator<any> {\r\n        var childIterator = this.childIterable[Symbol.iterator]();\r\n        return new WhereIterator(childIterator, this.predicate);\r\n    }\r\n}","//\r\n// An iterable that concatenates multiple iterables.\r\n//\r\n\r\nimport { ConcatIterator } from '../iterators/concat-iterator';\r\n\r\nexport class ConcatIterable<T> implements Iterable<T> {\r\n\r\n    iterables: Iterable<Iterable<T>>;\r\n\r\n    constructor(iterables: Iterable<Iterable<T>>) {\r\n        this.iterables = iterables;\r\n    }\r\n\r\n    [Symbol.iterator](): Iterator<any> {\r\n        return new ConcatIterator(this.iterables);\r\n    }\r\n}","//\r\n// An iterable that iterates the elements in reverse.\r\n//\r\n\r\nimport { ArrayIterator } from '../iterators/array-iterator';\r\n\r\nexport class ReverseIterable<T> implements Iterable<T> {\r\n\r\n    iterable: Iterable<T>;\r\n\r\n    constructor(iterable: Iterable<T>) {\r\n        this.iterable = iterable\r\n    }\r\n\r\n    [Symbol.iterator](): Iterator<any> {\r\n        const working = [];\r\n        for (const value of this.iterable) {\r\n            working.push(value);\r\n        }\r\n        working.reverse();\r\n        return new ArrayIterator(working);\r\n    }\r\n}","//\r\n// An iterable that zips together each set of elements in child iterables.\r\n//\r\n\r\nimport { ZipIterator, ZipFn } from '../iterators/zip-iterator';\r\n\r\nexport class ZipIterable<ValueT, ReturnT> implements Iterable<ReturnT> {\r\n\r\n    iterables: Iterable<ValueT>[];\r\n    zipper: ZipFn<ValueT, ReturnT>;\r\n\r\n    constructor(iterables: Iterable<ValueT>[], zipper: ZipFn<ValueT, ReturnT>) {\r\n        this.iterables = iterables;\r\n        this.zipper = zipper;\r\n    }\r\n\r\n    [Symbol.iterator](): Iterator<ReturnT> {\r\n        return new ZipIterator<ValueT, ReturnT>(this.iterables, this.zipper);\r\n    }\r\n}","//\r\n// An iterable that iterates the only distinct elements of another iterable.\r\n//\r\n\r\nimport { DistinctIterator, SelectorFnNoIndex } from '../iterators/distinct-iterator';\r\n\r\nexport class DistinctIterable<FromT, ToT> implements Iterable<FromT> {\r\n\r\n    iterable: Iterable<FromT>;\r\n    selector?: SelectorFnNoIndex<FromT, ToT>;\r\n\r\n    constructor(iterable: Iterable<FromT>, selector?: SelectorFnNoIndex<FromT, ToT>) {\r\n        this.iterable = iterable;\r\n        this.selector = selector;\r\n    }\r\n\r\n    [Symbol.iterator](): Iterator<FromT> {\r\n        return new DistinctIterator(this.iterable, this.selector);\r\n    }\r\n}","//\r\n// An iterable that sorts it's input before iterating it.\r\n//\r\n\r\nimport { ArrayIterator } from '../iterators/array-iterator';\r\n\r\nexport type SelectorFn = (value: any, index: number) => any;\r\n\r\nexport enum Direction {\r\n    Ascending,\r\n    Descending\r\n}\r\n\r\nexport interface ISortSpec {\r\n    sortLevel: number; // Debug helper. Sort level 0 is the first level.\r\n    selector: SelectorFn;\r\n    direction: Direction,\r\n}\r\n\r\nclass SortOperation {\r\n\r\n    values: any[];\r\n    sortSpec: ISortSpec;\r\n    keys: any[];\r\n\r\n    constructor(values: any[], sortSpec: ISortSpec) {\r\n        this.values = values;\r\n        this.sortSpec = sortSpec;\r\n        this.keys = [];\r\n    }\r\n\r\n    genKeys (): void {\r\n        if (this.keys.length > 0) {\r\n            // Already cached.\r\n            return;\r\n        }\r\n        \r\n        const index = 0;\r\n        for (const value of this.values) {\r\n            this.keys.push(this.sortSpec.selector(value, index));\r\n        }        \r\n    }\r\n\r\n    compare (indexA: number, indexB: number): number {\r\n        this.genKeys();\r\n\r\n        const keyA = this.keys[indexA];\r\n        const keyB = this.keys[indexB];\r\n        let comparison = -1;\r\n        if (keyA === keyB) {\r\n            comparison = 0;\r\n        }\r\n        else if (keyA > keyB) {\r\n            comparison = 1;\r\n        }\r\n\r\n        return (this.sortSpec.direction === Direction.Descending) ? -comparison : comparison;\r\n    }\r\n};\r\n\r\nexport class OrderedIterable implements Iterable<any> {\r\n\r\n    //TODO: Would probably be good to cache the sorted data here.\r\n\r\n    iterable: Iterable<any>;\r\n    sortSpec: ISortSpec[];\r\n\r\n    constructor(iterable: Iterable<any>, sortSpec: ISortSpec[]) {\r\n        this.iterable = iterable;\r\n        this.sortSpec = sortSpec;\r\n    }\r\n\r\n    [Symbol.iterator](): Iterator<any> {\r\n\r\n        const indexes: number[] = [];\r\n        const values: any[] = [];\r\n\r\n        let index = 0;\r\n        for (const value of this.iterable) {\r\n            indexes.push(index);\r\n            values.push(value);\r\n            ++index;\r\n        }\r\n\r\n        const sortOperations: SortOperation[] = [];\r\n        for (const sortSpec of this.sortSpec) {\r\n            sortOperations.push(new SortOperation(values, sortSpec));\r\n        }\r\n\r\n        sortOperations[0].genKeys();\r\n\r\n        indexes.sort((indexA: number, indexB: number): number => {\r\n            for (const sortOperation of sortOperations) {\r\n                const comparison = sortOperation.compare(indexA, indexB);\r\n                if (comparison !== 0) {\r\n                    return comparison;\r\n                }\r\n            }\r\n\r\n            return 0;\r\n        });\r\n\r\n        const sortedValues: any[] = [];\r\n\r\n        for (const index of indexes) {\r\n            sortedValues.push(values[index]);\r\n        }        \r\n\r\n        return new ArrayIterator(sortedValues);\r\n    }\r\n}","//\r\n// An iterable to extact an element from an array.\r\n//\r\n\r\nimport { ExtractElementIterator } from '../iterators/extract-element-iterator';\r\n\r\nexport class ExtractElementIterable implements Iterable<any> {\r\n\r\n    arrayIterable: Iterable<any[]>;\r\n    extractIndex: number;\r\n\r\n    constructor(arrayIterable: Iterable<any[]>, extractIndex: number) {\r\n        this.arrayIterable = arrayIterable;\r\n        this.extractIndex = extractIndex;\r\n    }\r\n\r\n    [Symbol.iterator](): Iterator<any> {\r\n        var arrayIterator = this.arrayIterable[Symbol.iterator]();\r\n        return new ExtractElementIterator(arrayIterator, this.extractIndex);\r\n    }\r\n}","//\r\n// An iterable that skips a number of values.\r\n//\r\n\r\nimport { SkipIterator } from '../iterators/skip-iterator';\r\n\r\nexport class SkipIterable implements Iterable<any> {\r\n\r\n    iterable: Iterable<any>;\r\n    numValues: number;\r\n\r\n    constructor(iterable: Iterable<any>, numValues: number) {\r\n        this.iterable = iterable;\r\n        this.numValues = numValues;\r\n    }\r\n\r\n    [Symbol.iterator](): Iterator<any> {\r\n        var iterator = this.iterable[Symbol.iterator]();\r\n        return new SkipIterator(iterator, this.numValues);\r\n    }\r\n}","//\r\n// An iterable that skips a sequence of elements while a predicate function returns true.\r\n//\r\n\r\nimport { SkipWhileIterator, PredicateFn } from '../iterators/skip-while-iterator';\r\n\r\nexport class SkipWhileIterable<T> implements Iterable<T> {\r\n\r\n    childIterable: Iterable<T>;\r\n    predicate: PredicateFn<T>;\r\n\r\n    constructor(childIterable: Iterable<T>, predicate: PredicateFn<T>) {\r\n        this.childIterable = childIterable;\r\n        this.predicate = predicate;\r\n    }\r\n\r\n    [Symbol.iterator](): Iterator<any> {\r\n        var childIterator = this.childIterable[Symbol.iterator]();\r\n        return new SkipWhileIterator(childIterator, this.predicate);\r\n    }\r\n}","var wcwidth\n\ntry {\n  wcwidth = require('wcwidth')\n} catch(e) {}\n\nmodule.exports = Table\n\nfunction Table() {\n  this.rows = []\n  this.row = {__printers : {}}\n}\n\n/**\n * Push the current row to the table and start a new one\n *\n * @returns {Table} `this`\n */\n\nTable.prototype.newRow = function() {\n  this.rows.push(this.row)\n  this.row = {__printers : {}}\n  return this\n}\n\n/**\n * Write cell in the current row\n *\n * @param {String} col          - Column name\n * @param {Any} val             - Cell value\n * @param {Function} [printer]  - Printer function to format the value\n * @returns {Table} `this`\n */\n\nTable.prototype.cell = function(col, val, printer) {\n  this.row[col] = val\n  this.row.__printers[col] = printer || string\n  return this\n}\n\n/**\n * String to separate columns\n */\n\nTable.prototype.separator = '  '\n\nfunction string(val) {\n  return val === undefined ? '' : ''+val\n}\n\nfunction length(str) {\n  var s = str.replace(/\\u001b\\[\\d+m/g, '')\n  return wcwidth == null ? s.length : wcwidth(s)\n}\n\n/**\n * Default printer\n */\n\nTable.string = string\n\n/**\n * Create a printer which right aligns the content by padding with `ch` on the left\n *\n * @param {String} ch\n * @returns {Function}\n */\n\nTable.leftPadder = leftPadder\n\nfunction leftPadder(ch) {\n  return function(val, width) {\n    var str = string(val)\n    var len = length(str)\n    var pad = width > len ? Array(width - len + 1).join(ch) : ''\n    return pad + str\n  }\n}\n\n/**\n * Printer which right aligns the content\n */\n\nvar padLeft = Table.padLeft = leftPadder(' ')\n\n/**\n * Create a printer which pads with `ch` on the right\n *\n * @param {String} ch\n * @returns {Function}\n */\n\nTable.rightPadder = rightPadder\n\nfunction rightPadder(ch) {\n  return function padRight(val, width) {\n    var str = string(val)\n    var len = length(str)\n    var pad = width > len ? Array(width - len + 1).join(ch) : ''\n    return str + pad\n  }\n}\n\nvar padRight = rightPadder(' ')\n\n/**\n * Create a printer for numbers\n *\n * Will do right alignment and optionally fix the number of digits after decimal point\n *\n * @param {Number} [digits] - Number of digits for fixpoint notation\n * @returns {Function}\n */\n\nTable.number = function(digits) {\n  return function(val, width) {\n    if (val == null) return ''\n    if (typeof val != 'number')\n      throw new Error(''+val + ' is not a number')\n    var str = digits == null ? val+'' : val.toFixed(digits)\n    return padLeft(str, width)\n  }\n}\n\nfunction each(row, fn) {\n  for(var key in row) {\n    if (key == '__printers') continue\n    fn(key, row[key])\n  }\n}\n\n/**\n * Get list of columns in printing order\n *\n * @returns {string[]}\n */\n\nTable.prototype.columns = function() {\n  var cols = {}\n  for(var i = 0; i < 2; i++) { // do 2 times\n    this.rows.forEach(function(row) {\n      var idx = 0\n      each(row, function(key) {\n        idx = Math.max(idx, cols[key] || 0)\n        cols[key] = idx\n        idx++\n      })\n    })\n  }\n  return Object.keys(cols).sort(function(a, b) {\n    return cols[a] - cols[b]\n  })\n}\n\n/**\n * Format just rows, i.e. print the table without headers and totals\n *\n * @returns {String} String representaion of the table\n */\n\nTable.prototype.print = function() {\n  var cols = this.columns()\n  var separator = this.separator\n  var widths = {}\n  var out = ''\n\n  // Calc widths\n  this.rows.forEach(function(row) {\n    each(row, function(key, val) {\n      var str = row.__printers[key].call(row, val)\n      widths[key] = Math.max(length(str), widths[key] || 0)\n    })\n  })\n\n  // Now print\n  this.rows.forEach(function(row) {\n    var line = ''\n    cols.forEach(function(key) {\n      var width = widths[key]\n      var str = row.hasOwnProperty(key)\n        ? ''+row.__printers[key].call(row, row[key], width)\n        : ''\n      line += padRight(str, width) + separator\n    })\n    line = line.slice(0, -separator.length)\n    out += line + '\\n'\n  })\n\n  return out\n}\n\n/**\n * Format the table\n *\n * @returns {String}\n */\n\nTable.prototype.toString = function() {\n  var cols = this.columns()\n  var out = new Table()\n\n  // copy options\n  out.separator = this.separator\n\n  // Write header\n  cols.forEach(function(col) {\n    out.cell(col, col)\n  })\n  out.newRow()\n  out.pushDelimeter(cols)\n\n  // Write body\n  out.rows = out.rows.concat(this.rows)\n\n  // Totals\n  if (this.totals && this.rows.length) {\n    out.pushDelimeter(cols)\n    this.forEachTotal(out.cell.bind(out))\n    out.newRow()\n  }\n\n  return out.print()\n}\n\n/**\n * Push delimeter row to the table (with each cell filled with dashs during printing)\n *\n * @param {String[]} [cols]\n * @returns {Table} `this`\n */\n\nTable.prototype.pushDelimeter = function(cols) {\n  cols = cols || this.columns()\n  cols.forEach(function(col) {\n    this.cell(col, undefined, leftPadder('-'))\n  }, this)\n  return this.newRow()\n}\n\n/**\n * Compute all totals and yield the results to `cb`\n *\n * @param {Function} cb - Callback function with signature `(column, value, printer)`\n */\n\nTable.prototype.forEachTotal = function(cb) {\n  for(var key in this.totals) {\n    var aggr = this.totals[key]\n    var acc = aggr.init\n    var len = this.rows.length\n    this.rows.forEach(function(row, idx) {\n      acc = aggr.reduce.call(row, acc, row[key], idx, len)\n    })\n    cb(key, acc, aggr.printer)\n  }\n}\n\n/**\n * Format the table so that each row represents column and each column represents row\n *\n * @param {Object} [opts]\n * @param {String} [ops.separator] - Column separation string\n * @param {Function} [opts.namePrinter] - Printer to format column names\n * @returns {String}\n */\n\nTable.prototype.printTransposed = function(opts) {\n  opts = opts || {}\n  var out = new Table\n  out.separator = opts.separator || this.separator\n  this.columns().forEach(function(col) {\n    out.cell(0, col, opts.namePrinter)\n    this.rows.forEach(function(row, idx) {\n      out.cell(idx+1, row[col], row.__printers[col])\n    })\n    out.newRow()\n  }, this)\n  return out.print()\n}\n\n/**\n * Sort the table\n *\n * @param {Function|string[]} [cmp] - Either compare function or a list of columns to sort on\n * @returns {Table} `this`\n */\n\nTable.prototype.sort = function(cmp) {\n  if (typeof cmp == 'function') {\n    this.rows.sort(cmp)\n    return this\n  }\n\n  var keys = Array.isArray(cmp) ? cmp : this.columns()\n\n  var comparators = keys.map(function(key) {\n    var order = 'asc'\n    var m = /(.*)\\|\\s*(asc|des)\\s*$/.exec(key)\n    if (m) {\n      key = m[1]\n      order = m[2]\n    }\n    return function (a, b) {\n      return order == 'asc'\n        ? compare(a[key], b[key])\n        : compare(b[key], a[key])\n    }\n  })\n\n  return this.sort(function(a, b) {\n    for (var i = 0; i < comparators.length; i++) {\n      var order = comparators[i](a, b)\n      if (order != 0) return order\n    }\n    return 0\n  })\n}\n\nfunction compare(a, b) {\n  if (a === b) return 0\n  if (a === undefined) return 1\n  if (b === undefined) return -1\n  if (a === null) return 1\n  if (b === null) return -1\n  if (a > b) return 1\n  if (a < b) return -1\n  return compare(String(a), String(b))\n}\n\n/**\n * Add a total for the column\n *\n * @param {String} col - column name\n * @param {Object} [opts]\n * @param {Function} [opts.reduce = sum] - reduce(acc, val, idx, length) function to compute the total value\n * @param {Function} [opts.printer = padLeft] - Printer to format the total cell\n * @param {Any} [opts.init = 0] - Initial value for reduction\n * @returns {Table} `this`\n */\n\nTable.prototype.total = function(col, opts) {\n  opts = opts || {}\n  this.totals = this.totals || {}\n  this.totals[col] = {\n    reduce: opts.reduce || Table.aggr.sum,\n    printer: opts.printer || padLeft,\n    init: opts.init == null ? 0 : opts.init\n  }\n  return this\n}\n\n/**\n * Predefined helpers for totals\n */\n\nTable.aggr = {}\n\n/**\n * Create a printer which formats the value with `printer`,\n * adds the `prefix` to it and right aligns the whole thing\n *\n * @param {String} prefix\n * @param {Function} printer\n * @returns {printer}\n */\n\nTable.aggr.printer = function(prefix, printer) {\n  printer = printer || string\n  return function(val, width) {\n    return padLeft(prefix + printer(val), width)\n  }\n}\n\n/**\n * Sum reduction\n */\n\nTable.aggr.sum = function(acc, val) {\n  return acc + val\n}\n\n/**\n * Average reduction\n */\n\nTable.aggr.avg = function(acc, val, idx, len) {\n  acc = acc + val\n  return idx + 1 == len ? acc/len : acc\n}\n\n/**\n * Print the array or object\n *\n * @param {Array|Object} obj - Object to print\n * @param {Function|Object} [format] - Format options\n * @param {Function} [cb] - Table post processing and formating\n * @returns {String}\n */\n\nTable.print = function(obj, format, cb) {\n  var opts = format || {}\n\n  format = typeof format == 'function'\n    ? format\n    : function(obj, cell) {\n      for(var key in obj) {\n        if (!obj.hasOwnProperty(key)) continue\n        var params = opts[key] || {}\n        cell(params.name || key, obj[key], params.printer)\n      }\n    }\n\n  var t = new Table\n  var cell = t.cell.bind(t)\n\n  if (Array.isArray(obj)) {\n    cb = cb || function(t) { return t.toString() }\n    obj.forEach(function(item) {\n      format(item, cell)\n      t.newRow()\n    })\n  } else {\n    cb = cb || function(t) { return t.printTransposed({separator: ' : '}) }\n    format(obj, cell)\n    t.newRow()\n  }\n\n  return cb(t)\n}\n\n/**\n * Same as `Table.print()` but yields the result to `console.log()`\n */\n\nTable.log = function(obj, format, cb) {\n  console.log(Table.print(obj, format, cb))\n}\n\n/**\n * Same as `.toString()` but yields the result to `console.log()`\n */\n\nTable.prototype.log = function() {\n  console.log(this.toString())\n}\n","/*@license\n\tPapa Parse\n\tv4.4.0\n\thttps://github.com/mholt/PapaParse\n\tLicense: MIT\n*/\n(function(root, factory)\n{\n\t/* globals define */\n\tif (typeof define === 'function' && define.amd)\n\t{\n\t\t// AMD. Register as an anonymous module.\n\t\tdefine([], factory);\n\t}\n\telse if (typeof module === 'object' && typeof exports !== 'undefined')\n\t{\n\t\t// Node. Does not work with strict CommonJS, but\n\t\t// only CommonJS-like environments that support module.exports,\n\t\t// like Node.\n\t\tmodule.exports = factory();\n\t}\n\telse\n\t{\n\t\t// Browser globals (root is window)\n\t\troot.Papa = factory();\n\t}\n}(this, function()\n{\n\t'use strict';\n\n\tvar global = (function() {\n\t\t// alternative method, similar to `Function('return this')()`\n\t\t// but without using `eval` (which is disabled when\n\t\t// using Content Security Policy).\n\n\t\tif (typeof self !== 'undefined') { return self; }\n\t\tif (typeof window !== 'undefined') { return window; }\n\t\tif (typeof global !== 'undefined') { return global; }\n\n\t\t// When running tests none of the above have been defined\n\t\treturn {};\n\t})();\n\n\n\tvar IS_WORKER = !global.document && !!global.postMessage,\n\t\tIS_PAPA_WORKER = IS_WORKER && /(\\?|&)papaworker(=|&|$)/.test(global.location.search),\n\t\tLOADED_SYNC = false, AUTO_SCRIPT_PATH;\n\tvar workers = {}, workerIdCounter = 0;\n\n\tvar Papa = {};\n\n\tPapa.parse = CsvToJson;\n\tPapa.unparse = JsonToCsv;\n\n\tPapa.RECORD_SEP = String.fromCharCode(30);\n\tPapa.UNIT_SEP = String.fromCharCode(31);\n\tPapa.BYTE_ORDER_MARK = '\\ufeff';\n\tPapa.BAD_DELIMITERS = ['\\r', '\\n', '\"', Papa.BYTE_ORDER_MARK];\n\tPapa.WORKERS_SUPPORTED = !IS_WORKER && !!global.Worker;\n\tPapa.SCRIPT_PATH = null;\t// Must be set by your code if you use workers and this lib is loaded asynchronously\n\n\t// Configurable chunk sizes for local and remote files, respectively\n\tPapa.LocalChunkSize = 1024 * 1024 * 10;\t// 10 MB\n\tPapa.RemoteChunkSize = 1024 * 1024 * 5;\t// 5 MB\n\tPapa.DefaultDelimiter = ',';\t\t\t// Used if not specified and detection fails\n\n\t// Exposed for testing and development only\n\tPapa.Parser = Parser;\n\tPapa.ParserHandle = ParserHandle;\n\tPapa.NetworkStreamer = NetworkStreamer;\n\tPapa.FileStreamer = FileStreamer;\n\tPapa.StringStreamer = StringStreamer;\n\tPapa.ReadableStreamStreamer = ReadableStreamStreamer;\n\n\tif (global.jQuery)\n\t{\n\t\tvar $ = global.jQuery;\n\t\t$.fn.parse = function(options)\n\t\t{\n\t\t\tvar config = options.config || {};\n\t\t\tvar queue = [];\n\n\t\t\tthis.each(function(idx)\n\t\t\t{\n\t\t\t\tvar supported = $(this).prop('tagName').toUpperCase() === 'INPUT'\n\t\t\t\t\t\t\t\t&& $(this).attr('type').toLowerCase() === 'file'\n\t\t\t\t\t\t\t\t&& global.FileReader;\n\n\t\t\t\tif (!supported || !this.files || this.files.length === 0)\n\t\t\t\t\treturn true;\t// continue to next input element\n\n\t\t\t\tfor (var i = 0; i < this.files.length; i++)\n\t\t\t\t{\n\t\t\t\t\tqueue.push({\n\t\t\t\t\t\tfile: this.files[i],\n\t\t\t\t\t\tinputElem: this,\n\t\t\t\t\t\tinstanceConfig: $.extend({}, config)\n\t\t\t\t\t});\n\t\t\t\t}\n\t\t\t});\n\n\t\t\tparseNextFile();\t// begin parsing\n\t\t\treturn this;\t\t// maintains chainability\n\n\n\t\t\tfunction parseNextFile()\n\t\t\t{\n\t\t\t\tif (queue.length === 0)\n\t\t\t\t{\n\t\t\t\t\tif (isFunction(options.complete))\n\t\t\t\t\t\toptions.complete();\n\t\t\t\t\treturn;\n\t\t\t\t}\n\n\t\t\t\tvar f = queue[0];\n\n\t\t\t\tif (isFunction(options.before))\n\t\t\t\t{\n\t\t\t\t\tvar returned = options.before(f.file, f.inputElem);\n\n\t\t\t\t\tif (typeof returned === 'object')\n\t\t\t\t\t{\n\t\t\t\t\t\tif (returned.action === 'abort')\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\terror('AbortError', f.file, f.inputElem, returned.reason);\n\t\t\t\t\t\t\treturn;\t// Aborts all queued files immediately\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse if (returned.action === 'skip')\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tfileComplete();\t// parse the next file in the queue, if any\n\t\t\t\t\t\t\treturn;\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse if (typeof returned.config === 'object')\n\t\t\t\t\t\t\tf.instanceConfig = $.extend(f.instanceConfig, returned.config);\n\t\t\t\t\t}\n\t\t\t\t\telse if (returned === 'skip')\n\t\t\t\t\t{\n\t\t\t\t\t\tfileComplete();\t// parse the next file in the queue, if any\n\t\t\t\t\t\treturn;\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\t// Wrap up the user's complete callback, if any, so that ours also gets executed\n\t\t\t\tvar userCompleteFunc = f.instanceConfig.complete;\n\t\t\t\tf.instanceConfig.complete = function(results)\n\t\t\t\t{\n\t\t\t\t\tif (isFunction(userCompleteFunc))\n\t\t\t\t\t\tuserCompleteFunc(results, f.file, f.inputElem);\n\t\t\t\t\tfileComplete();\n\t\t\t\t};\n\n\t\t\t\tPapa.parse(f.file, f.instanceConfig);\n\t\t\t}\n\n\t\t\tfunction error(name, file, elem, reason)\n\t\t\t{\n\t\t\t\tif (isFunction(options.error))\n\t\t\t\t\toptions.error({name: name}, file, elem, reason);\n\t\t\t}\n\n\t\t\tfunction fileComplete()\n\t\t\t{\n\t\t\t\tqueue.splice(0, 1);\n\t\t\t\tparseNextFile();\n\t\t\t}\n\t\t};\n\t}\n\n\n\tif (IS_PAPA_WORKER)\n\t{\n\t\tglobal.onmessage = workerThreadReceivedMessage;\n\t}\n\telse if (Papa.WORKERS_SUPPORTED)\n\t{\n\t\tAUTO_SCRIPT_PATH = getScriptPath();\n\n\t\t// Check if the script was loaded synchronously\n\t\tif (!document.body)\n\t\t{\n\t\t\t// Body doesn't exist yet, must be synchronous\n\t\t\tLOADED_SYNC = true;\n\t\t}\n\t\telse\n\t\t{\n\t\t\tdocument.addEventListener('DOMContentLoaded', function() {\n\t\t\t\tLOADED_SYNC = true;\n\t\t\t}, true);\n\t\t}\n\t}\n\n\n\n\n\tfunction CsvToJson(_input, _config)\n\t{\n\t\t_config = _config || {};\n\t\tvar dynamicTyping = _config.dynamicTyping || false;\n\t\tif (isFunction(dynamicTyping)) {\n\t\t\t_config.dynamicTypingFunction = dynamicTyping;\n\t\t\t// Will be filled on first row call\n\t\t\tdynamicTyping = {};\n\t\t}\n\t\t_config.dynamicTyping = dynamicTyping;\n\n\t\tif (_config.worker && Papa.WORKERS_SUPPORTED)\n\t\t{\n\t\t\tvar w = newWorker();\n\n\t\t\tw.userStep = _config.step;\n\t\t\tw.userChunk = _config.chunk;\n\t\t\tw.userComplete = _config.complete;\n\t\t\tw.userError = _config.error;\n\n\t\t\t_config.step = isFunction(_config.step);\n\t\t\t_config.chunk = isFunction(_config.chunk);\n\t\t\t_config.complete = isFunction(_config.complete);\n\t\t\t_config.error = isFunction(_config.error);\n\t\t\tdelete _config.worker;\t// prevent infinite loop\n\n\t\t\tw.postMessage({\n\t\t\t\tinput: _input,\n\t\t\t\tconfig: _config,\n\t\t\t\tworkerId: w.id\n\t\t\t});\n\n\t\t\treturn;\n\t\t}\n\n\t\tvar streamer = null;\n\t\tif (typeof _input === 'string')\n\t\t{\n\t\t\tif (_config.download)\n\t\t\t\tstreamer = new NetworkStreamer(_config);\n\t\t\telse\n\t\t\t\tstreamer = new StringStreamer(_config);\n\t\t}\n\t\telse if (_input.readable === true && isFunction(_input.read) && isFunction(_input.on))\n\t\t{\n\t\t\tstreamer = new ReadableStreamStreamer(_config);\n\t\t}\n\t\telse if ((global.File && _input instanceof File) || _input instanceof Object)\t// ...Safari. (see issue #106)\n\t\t\tstreamer = new FileStreamer(_config);\n\n\t\treturn streamer.stream(_input);\n\t}\n\n\n\n\n\n\n\tfunction JsonToCsv(_input, _config)\n\t{\n\t\t// Default configuration\n\n\t\t/** whether to surround every datum with quotes */\n\t\tvar _quotes = false;\n\n\t\t/** whether to write headers */\n\t\tvar _writeHeader = true;\n\n\t\t/** delimiting character */\n\t\tvar _delimiter = ',';\n\n\t\t/** newline character(s) */\n\t\tvar _newline = '\\r\\n';\n\n\t\t/** quote character */\n\t\tvar _quoteChar = '\"';\n\n\t\tunpackConfig();\n\n\t\tvar quoteCharRegex = new RegExp(_quoteChar, 'g');\n\n\t\tif (typeof _input === 'string')\n\t\t\t_input = JSON.parse(_input);\n\n\t\tif (_input instanceof Array)\n\t\t{\n\t\t\tif (!_input.length || _input[0] instanceof Array)\n\t\t\t\treturn serialize(null, _input);\n\t\t\telse if (typeof _input[0] === 'object')\n\t\t\t\treturn serialize(objectKeys(_input[0]), _input);\n\t\t}\n\t\telse if (typeof _input === 'object')\n\t\t{\n\t\t\tif (typeof _input.data === 'string')\n\t\t\t\t_input.data = JSON.parse(_input.data);\n\n\t\t\tif (_input.data instanceof Array)\n\t\t\t{\n\t\t\t\tif (!_input.fields)\n\t\t\t\t\t_input.fields =  _input.meta && _input.meta.fields;\n\n\t\t\t\tif (!_input.fields)\n\t\t\t\t\t_input.fields =  _input.data[0] instanceof Array\n\t\t\t\t\t\t? _input.fields\n\t\t\t\t\t\t: objectKeys(_input.data[0]);\n\n\t\t\t\tif (!(_input.data[0] instanceof Array) && typeof _input.data[0] !== 'object')\n\t\t\t\t\t_input.data = [_input.data];\t// handles input like [1,2,3] or ['asdf']\n\t\t\t}\n\n\t\t\treturn serialize(_input.fields || [], _input.data || []);\n\t\t}\n\n\t\t// Default (any valid paths should return before this)\n\t\tthrow 'exception: Unable to serialize unrecognized input';\n\n\n\t\tfunction unpackConfig()\n\t\t{\n\t\t\tif (typeof _config !== 'object')\n\t\t\t\treturn;\n\n\t\t\tif (typeof _config.delimiter === 'string'\n\t\t\t\t&& _config.delimiter.length === 1\n\t\t\t\t&& Papa.BAD_DELIMITERS.indexOf(_config.delimiter) === -1)\n\t\t\t{\n\t\t\t\t_delimiter = _config.delimiter;\n\t\t\t}\n\n\t\t\tif (typeof _config.quotes === 'boolean'\n\t\t\t\t|| _config.quotes instanceof Array)\n\t\t\t\t_quotes = _config.quotes;\n\n\t\t\tif (typeof _config.newline === 'string')\n\t\t\t\t_newline = _config.newline;\n\n\t\t\tif (typeof _config.quoteChar === 'string')\n\t\t\t\t_quoteChar = _config.quoteChar;\n\n\t\t\tif (typeof _config.header === 'boolean')\n\t\t\t\t_writeHeader = _config.header;\n\t\t}\n\n\n\t\t/** Turns an object's keys into an array */\n\t\tfunction objectKeys(obj)\n\t\t{\n\t\t\tif (typeof obj !== 'object')\n\t\t\t\treturn [];\n\t\t\tvar keys = [];\n\t\t\tfor (var key in obj)\n\t\t\t\tkeys.push(key);\n\t\t\treturn keys;\n\t\t}\n\n\t\t/** The double for loop that iterates the data and writes out a CSV string including header row */\n\t\tfunction serialize(fields, data)\n\t\t{\n\t\t\tvar csv = '';\n\n\t\t\tif (typeof fields === 'string')\n\t\t\t\tfields = JSON.parse(fields);\n\t\t\tif (typeof data === 'string')\n\t\t\t\tdata = JSON.parse(data);\n\n\t\t\tvar hasHeader = fields instanceof Array && fields.length > 0;\n\t\t\tvar dataKeyedByField = !(data[0] instanceof Array);\n\n\t\t\t// If there a header row, write it first\n\t\t\tif (hasHeader && _writeHeader)\n\t\t\t{\n\t\t\t\tfor (var i = 0; i < fields.length; i++)\n\t\t\t\t{\n\t\t\t\t\tif (i > 0)\n\t\t\t\t\t\tcsv += _delimiter;\n\t\t\t\t\tcsv += safe(fields[i], i);\n\t\t\t\t}\n\t\t\t\tif (data.length > 0)\n\t\t\t\t\tcsv += _newline;\n\t\t\t}\n\n\t\t\t// Then write out the data\n\t\t\tfor (var row = 0; row < data.length; row++)\n\t\t\t{\n\t\t\t\tvar maxCol = hasHeader ? fields.length : data[row].length;\n\n\t\t\t\tfor (var col = 0; col < maxCol; col++)\n\t\t\t\t{\n\t\t\t\t\tif (col > 0)\n\t\t\t\t\t\tcsv += _delimiter;\n\t\t\t\t\tvar colIdx = hasHeader && dataKeyedByField ? fields[col] : col;\n\t\t\t\t\tcsv += safe(data[row][colIdx], col);\n\t\t\t\t}\n\n\t\t\t\tif (row < data.length - 1)\n\t\t\t\t\tcsv += _newline;\n\t\t\t}\n\n\t\t\treturn csv;\n\t\t}\n\n\t\t/** Encloses a value around quotes if needed (makes a value safe for CSV insertion) */\n\t\tfunction safe(str, col)\n\t\t{\n\t\t\tif (typeof str === 'undefined' || str === null)\n\t\t\t\treturn '';\n\n\t\t\tstr = str.toString().replace(quoteCharRegex, _quoteChar + _quoteChar);\n\n\t\t\tvar needsQuotes = (typeof _quotes === 'boolean' && _quotes)\n\t\t\t\t\t\t\t|| (_quotes instanceof Array && _quotes[col])\n\t\t\t\t\t\t\t|| hasAny(str, Papa.BAD_DELIMITERS)\n\t\t\t\t\t\t\t|| str.indexOf(_delimiter) > -1\n\t\t\t\t\t\t\t|| str.charAt(0) === ' '\n\t\t\t\t\t\t\t|| str.charAt(str.length - 1) === ' ';\n\n\t\t\treturn needsQuotes ? _quoteChar + str + _quoteChar : str;\n\t\t}\n\n\t\tfunction hasAny(str, substrings)\n\t\t{\n\t\t\tfor (var i = 0; i < substrings.length; i++)\n\t\t\t\tif (str.indexOf(substrings[i]) > -1)\n\t\t\t\t\treturn true;\n\t\t\treturn false;\n\t\t}\n\t}\n\n\t/** ChunkStreamer is the base prototype for various streamer implementations. */\n\tfunction ChunkStreamer(config)\n\t{\n\t\tthis._handle = null;\n\t\tthis._finished = false;\n\t\tthis._completed = false;\n\t\tthis._input = null;\n\t\tthis._baseIndex = 0;\n\t\tthis._partialLine = '';\n\t\tthis._rowCount = 0;\n\t\tthis._start = 0;\n\t\tthis._nextChunk = null;\n\t\tthis.isFirstChunk = true;\n\t\tthis._completeResults = {\n\t\t\tdata: [],\n\t\t\terrors: [],\n\t\t\tmeta: {}\n\t\t};\n\t\treplaceConfig.call(this, config);\n\n\t\tthis.parseChunk = function(chunk, isFakeChunk)\n\t\t{\n\t\t\t// First chunk pre-processing\n\t\t\tif (this.isFirstChunk && isFunction(this._config.beforeFirstChunk))\n\t\t\t{\n\t\t\t\tvar modifiedChunk = this._config.beforeFirstChunk(chunk);\n\t\t\t\tif (modifiedChunk !== undefined)\n\t\t\t\t\tchunk = modifiedChunk;\n\t\t\t}\n\t\t\tthis.isFirstChunk = false;\n\n\t\t\t// Rejoin the line we likely just split in two by chunking the file\n\t\t\tvar aggregate = this._partialLine + chunk;\n\t\t\tthis._partialLine = '';\n\n\t\t\tvar results = this._handle.parse(aggregate, this._baseIndex, !this._finished);\n\n\t\t\tif (this._handle.paused() || this._handle.aborted())\n\t\t\t\treturn;\n\n\t\t\tvar lastIndex = results.meta.cursor;\n\n\t\t\tif (!this._finished)\n\t\t\t{\n\t\t\t\tthis._partialLine = aggregate.substring(lastIndex - this._baseIndex);\n\t\t\t\tthis._baseIndex = lastIndex;\n\t\t\t}\n\n\t\t\tif (results && results.data)\n\t\t\t\tthis._rowCount += results.data.length;\n\n\t\t\tvar finishedIncludingPreview = this._finished || (this._config.preview && this._rowCount >= this._config.preview);\n\n\t\t\tif (IS_PAPA_WORKER)\n\t\t\t{\n\t\t\t\tglobal.postMessage({\n\t\t\t\t\tresults: results,\n\t\t\t\t\tworkerId: Papa.WORKER_ID,\n\t\t\t\t\tfinished: finishedIncludingPreview\n\t\t\t\t});\n\t\t\t}\n\t\t\telse if (isFunction(this._config.chunk) && !isFakeChunk)\n\t\t\t{\n\t\t\t\tthis._config.chunk(results, this._handle);\n\t\t\t\tif (this._handle.paused() || this._handle.aborted())\n\t\t\t\t\treturn;\n\t\t\t\tresults = undefined;\n\t\t\t\tthis._completeResults = undefined;\n\t\t\t}\n\n\t\t\tif (!this._config.step && !this._config.chunk) {\n\t\t\t\tthis._completeResults.data = this._completeResults.data.concat(results.data);\n\t\t\t\tthis._completeResults.errors = this._completeResults.errors.concat(results.errors);\n\t\t\t\tthis._completeResults.meta = results.meta;\n\t\t\t}\n\n\t\t\tif (!this._completed && finishedIncludingPreview && isFunction(this._config.complete) && (!results || !results.meta.aborted)) {\n\t\t\t\tthis._config.complete(this._completeResults, this._input);\n\t\t\t\tthis._completed = true;\n\t\t\t}\n\n\t\t\tif (!finishedIncludingPreview && (!results || !results.meta.paused))\n\t\t\t\tthis._nextChunk();\n\n\t\t\treturn results;\n\t\t};\n\n\t\tthis._sendError = function(error)\n\t\t{\n\t\t\tif (isFunction(this._config.error))\n\t\t\t\tthis._config.error(error);\n\t\t\telse if (IS_PAPA_WORKER && this._config.error)\n\t\t\t{\n\t\t\t\tglobal.postMessage({\n\t\t\t\t\tworkerId: Papa.WORKER_ID,\n\t\t\t\t\terror: error,\n\t\t\t\t\tfinished: false\n\t\t\t\t});\n\t\t\t}\n\t\t};\n\n\t\tfunction replaceConfig(config)\n\t\t{\n\t\t\t// Deep-copy the config so we can edit it\n\t\t\tvar configCopy = copy(config);\n\t\t\tconfigCopy.chunkSize = parseInt(configCopy.chunkSize);\t// parseInt VERY important so we don't concatenate strings!\n\t\t\tif (!config.step && !config.chunk)\n\t\t\t\tconfigCopy.chunkSize = null;  // disable Range header if not streaming; bad values break IIS - see issue #196\n\t\t\tthis._handle = new ParserHandle(configCopy);\n\t\t\tthis._handle.streamer = this;\n\t\t\tthis._config = configCopy;\t// persist the copy to the caller\n\t\t}\n\t}\n\n\n\tfunction NetworkStreamer(config)\n\t{\n\t\tconfig = config || {};\n\t\tif (!config.chunkSize)\n\t\t\tconfig.chunkSize = Papa.RemoteChunkSize;\n\t\tChunkStreamer.call(this, config);\n\n\t\tvar xhr;\n\n\t\tif (IS_WORKER)\n\t\t{\n\t\t\tthis._nextChunk = function()\n\t\t\t{\n\t\t\t\tthis._readChunk();\n\t\t\t\tthis._chunkLoaded();\n\t\t\t};\n\t\t}\n\t\telse\n\t\t{\n\t\t\tthis._nextChunk = function()\n\t\t\t{\n\t\t\t\tthis._readChunk();\n\t\t\t};\n\t\t}\n\n\t\tthis.stream = function(url)\n\t\t{\n\t\t\tthis._input = url;\n\t\t\tthis._nextChunk();\t// Starts streaming\n\t\t};\n\n\t\tthis._readChunk = function()\n\t\t{\n\t\t\tif (this._finished)\n\t\t\t{\n\t\t\t\tthis._chunkLoaded();\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\txhr = new XMLHttpRequest();\n\n\t\t\tif (this._config.withCredentials)\n\t\t\t{\n\t\t\t\txhr.withCredentials = this._config.withCredentials;\n\t\t\t}\n\n\t\t\tif (!IS_WORKER)\n\t\t\t{\n\t\t\t\txhr.onload = bindFunction(this._chunkLoaded, this);\n\t\t\t\txhr.onerror = bindFunction(this._chunkError, this);\n\t\t\t}\n\n\t\t\txhr.open('GET', this._input, !IS_WORKER);\n\t\t\t// Headers can only be set when once the request state is OPENED\n\t\t\tif (this._config.downloadRequestHeaders)\n\t\t\t{\n\t\t\t\tvar headers = this._config.downloadRequestHeaders;\n\n\t\t\t\tfor (var headerName in headers)\n\t\t\t\t{\n\t\t\t\t\txhr.setRequestHeader(headerName, headers[headerName]);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (this._config.chunkSize)\n\t\t\t{\n\t\t\t\tvar end = this._start + this._config.chunkSize - 1;\t// minus one because byte range is inclusive\n\t\t\t\txhr.setRequestHeader('Range', 'bytes=' + this._start + '-' + end);\n\t\t\t\txhr.setRequestHeader('If-None-Match', 'webkit-no-cache'); // https://bugs.webkit.org/show_bug.cgi?id=82672\n\t\t\t}\n\n\t\t\ttry {\n\t\t\t\txhr.send();\n\t\t\t}\n\t\t\tcatch (err) {\n\t\t\t\tthis._chunkError(err.message);\n\t\t\t}\n\n\t\t\tif (IS_WORKER && xhr.status === 0)\n\t\t\t\tthis._chunkError();\n\t\t\telse\n\t\t\t\tthis._start += this._config.chunkSize;\n\t\t};\n\n\t\tthis._chunkLoaded = function()\n\t\t{\n\t\t\tif (xhr.readyState !== 4)\n\t\t\t\treturn;\n\n\t\t\tif (xhr.status < 200 || xhr.status >= 400)\n\t\t\t{\n\t\t\t\tthis._chunkError();\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tthis._finished = !this._config.chunkSize || this._start > getFileSize(xhr);\n\t\t\tthis.parseChunk(xhr.responseText);\n\t\t};\n\n\t\tthis._chunkError = function(errorMessage)\n\t\t{\n\t\t\tvar errorText = xhr.statusText || errorMessage;\n\t\t\tthis._sendError(new Error(errorText));\n\t\t};\n\n\t\tfunction getFileSize(xhr)\n\t\t{\n\t\t\tvar contentRange = xhr.getResponseHeader('Content-Range');\n\t\t\tif (contentRange === null) { // no content range, then finish!\n\t\t\t\treturn -1;\n\t\t\t}\n\t\t\treturn parseInt(contentRange.substr(contentRange.lastIndexOf('/') + 1));\n\t\t}\n\t}\n\tNetworkStreamer.prototype = Object.create(ChunkStreamer.prototype);\n\tNetworkStreamer.prototype.constructor = NetworkStreamer;\n\n\n\tfunction FileStreamer(config)\n\t{\n\t\tconfig = config || {};\n\t\tif (!config.chunkSize)\n\t\t\tconfig.chunkSize = Papa.LocalChunkSize;\n\t\tChunkStreamer.call(this, config);\n\n\t\tvar reader, slice;\n\n\t\t// FileReader is better than FileReaderSync (even in worker) - see http://stackoverflow.com/q/24708649/1048862\n\t\t// But Firefox is a pill, too - see issue #76: https://github.com/mholt/PapaParse/issues/76\n\t\tvar usingAsyncReader = typeof FileReader !== 'undefined';\t// Safari doesn't consider it a function - see issue #105\n\n\t\tthis.stream = function(file)\n\t\t{\n\t\t\tthis._input = file;\n\t\t\tslice = file.slice || file.webkitSlice || file.mozSlice;\n\n\t\t\tif (usingAsyncReader)\n\t\t\t{\n\t\t\t\treader = new FileReader();\t\t// Preferred method of reading files, even in workers\n\t\t\t\treader.onload = bindFunction(this._chunkLoaded, this);\n\t\t\t\treader.onerror = bindFunction(this._chunkError, this);\n\t\t\t}\n\t\t\telse\n\t\t\t\treader = new FileReaderSync();\t// Hack for running in a web worker in Firefox\n\n\t\t\tthis._nextChunk();\t// Starts streaming\n\t\t};\n\n\t\tthis._nextChunk = function()\n\t\t{\n\t\t\tif (!this._finished && (!this._config.preview || this._rowCount < this._config.preview))\n\t\t\t\tthis._readChunk();\n\t\t};\n\n\t\tthis._readChunk = function()\n\t\t{\n\t\t\tvar input = this._input;\n\t\t\tif (this._config.chunkSize)\n\t\t\t{\n\t\t\t\tvar end = Math.min(this._start + this._config.chunkSize, this._input.size);\n\t\t\t\tinput = slice.call(input, this._start, end);\n\t\t\t}\n\t\t\tvar txt = reader.readAsText(input, this._config.encoding);\n\t\t\tif (!usingAsyncReader)\n\t\t\t\tthis._chunkLoaded({ target: { result: txt } });\t// mimic the async signature\n\t\t};\n\n\t\tthis._chunkLoaded = function(event)\n\t\t{\n\t\t\t// Very important to increment start each time before handling results\n\t\t\tthis._start += this._config.chunkSize;\n\t\t\tthis._finished = !this._config.chunkSize || this._start >= this._input.size;\n\t\t\tthis.parseChunk(event.target.result);\n\t\t};\n\n\t\tthis._chunkError = function()\n\t\t{\n\t\t\tthis._sendError(reader.error);\n\t\t};\n\n\t}\n\tFileStreamer.prototype = Object.create(ChunkStreamer.prototype);\n\tFileStreamer.prototype.constructor = FileStreamer;\n\n\n\tfunction StringStreamer(config)\n\t{\n\t\tconfig = config || {};\n\t\tChunkStreamer.call(this, config);\n\n\t\tvar remaining;\n\t\tthis.stream = function(s)\n\t\t{\n\t\t\tremaining = s;\n\t\t\treturn this._nextChunk();\n\t\t};\n\t\tthis._nextChunk = function()\n\t\t{\n\t\t\tif (this._finished) return;\n\t\t\tvar size = this._config.chunkSize;\n\t\t\tvar chunk = size ? remaining.substr(0, size) : remaining;\n\t\t\tremaining = size ? remaining.substr(size) : '';\n\t\t\tthis._finished = !remaining;\n\t\t\treturn this.parseChunk(chunk);\n\t\t};\n\t}\n\tStringStreamer.prototype = Object.create(StringStreamer.prototype);\n\tStringStreamer.prototype.constructor = StringStreamer;\n\n\n\tfunction ReadableStreamStreamer(config)\n\t{\n\t\tconfig = config || {};\n\n\t\tChunkStreamer.call(this, config);\n\n\t\tvar queue = [];\n\t\tvar parseOnData = true;\n\t\tvar streamHasEnded = false;\n\n\t\tthis.pause = function()\n\t\t{\n\t\t\tChunkStreamer.prototype.pause.apply(this, arguments);\n\t\t\tthis._input.pause();\n\t\t};\n\n\t\tthis.resume = function()\n\t\t{\n\t\t\tChunkStreamer.prototype.resume.apply(this, arguments);\n\t\t\tthis._input.resume();\n\t\t};\n\n\t\tthis.stream = function(stream)\n\t\t{\n\t\t\tthis._input = stream;\n\n\t\t\tthis._input.on('data', this._streamData);\n\t\t\tthis._input.on('end', this._streamEnd);\n\t\t\tthis._input.on('error', this._streamError);\n\t\t};\n\n\t\tthis._checkIsFinished = function()\n\t\t{\n\t\t\tif (streamHasEnded && queue.length === 1) {\n\t\t\t\tthis._finished = true;\n\t\t\t}\n\t\t};\n\n\t\tthis._nextChunk = function()\n\t\t{\n\t\t\tthis._checkIsFinished();\n\t\t\tif (queue.length)\n\t\t\t{\n\t\t\t\tthis.parseChunk(queue.shift());\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tparseOnData = true;\n\t\t\t}\n\t\t};\n\n\t\tthis._streamData = bindFunction(function(chunk)\n\t\t{\n\t\t\ttry\n\t\t\t{\n\t\t\t\tqueue.push(typeof chunk === 'string' ? chunk : chunk.toString(this._config.encoding));\n\n\t\t\t\tif (parseOnData)\n\t\t\t\t{\n\t\t\t\t\tparseOnData = false;\n\t\t\t\t\tthis._checkIsFinished();\n\t\t\t\t\tthis.parseChunk(queue.shift());\n\t\t\t\t}\n\t\t\t}\n\t\t\tcatch (error)\n\t\t\t{\n\t\t\t\tthis._streamError(error);\n\t\t\t}\n\t\t}, this);\n\n\t\tthis._streamError = bindFunction(function(error)\n\t\t{\n\t\t\tthis._streamCleanUp();\n\t\t\tthis._sendError(error);\n\t\t}, this);\n\n\t\tthis._streamEnd = bindFunction(function()\n\t\t{\n\t\t\tthis._streamCleanUp();\n\t\t\tstreamHasEnded = true;\n\t\t\tthis._streamData('');\n\t\t}, this);\n\n\t\tthis._streamCleanUp = bindFunction(function()\n\t\t{\n\t\t\tthis._input.removeListener('data', this._streamData);\n\t\t\tthis._input.removeListener('end', this._streamEnd);\n\t\t\tthis._input.removeListener('error', this._streamError);\n\t\t}, this);\n\t}\n\tReadableStreamStreamer.prototype = Object.create(ChunkStreamer.prototype);\n\tReadableStreamStreamer.prototype.constructor = ReadableStreamStreamer;\n\n\n\t// Use one ParserHandle per entire CSV file or string\n\tfunction ParserHandle(_config)\n\t{\n\t\t// One goal is to minimize the use of regular expressions...\n\t\tvar FLOAT = /^\\s*-?(\\d*\\.?\\d+|\\d+\\.?\\d*)(e[-+]?\\d+)?\\s*$/i;\n\n\t\tvar self = this;\n\t\tvar _stepCounter = 0;\t// Number of times step was called (number of rows parsed)\n\t\tvar _input;\t\t\t\t// The input being parsed\n\t\tvar _parser;\t\t\t// The core parser being used\n\t\tvar _paused = false;\t// Whether we are paused or not\n\t\tvar _aborted = false;\t// Whether the parser has aborted or not\n\t\tvar _delimiterError;\t// Temporary state between delimiter detection and processing results\n\t\tvar _fields = [];\t\t// Fields are from the header row of the input, if there is one\n\t\tvar _results = {\t\t// The last results returned from the parser\n\t\t\tdata: [],\n\t\t\terrors: [],\n\t\t\tmeta: {}\n\t\t};\n\n\t\tif (isFunction(_config.step))\n\t\t{\n\t\t\tvar userStep = _config.step;\n\t\t\t_config.step = function(results)\n\t\t\t{\n\t\t\t\t_results = results;\n\n\t\t\t\tif (needsHeaderRow())\n\t\t\t\t\tprocessResults();\n\t\t\t\telse\t// only call user's step function after header row\n\t\t\t\t{\n\t\t\t\t\tprocessResults();\n\n\t\t\t\t\t// It's possbile that this line was empty and there's no row here after all\n\t\t\t\t\tif (_results.data.length === 0)\n\t\t\t\t\t\treturn;\n\n\t\t\t\t\t_stepCounter += results.data.length;\n\t\t\t\t\tif (_config.preview && _stepCounter > _config.preview)\n\t\t\t\t\t\t_parser.abort();\n\t\t\t\t\telse\n\t\t\t\t\t\tuserStep(_results, self);\n\t\t\t\t}\n\t\t\t};\n\t\t}\n\n\t\t/**\n\t\t * Parses input. Most users won't need, and shouldn't mess with, the baseIndex\n\t\t * and ignoreLastRow parameters. They are used by streamers (wrapper functions)\n\t\t * when an input comes in multiple chunks, like from a file.\n\t\t */\n\t\tthis.parse = function(input, baseIndex, ignoreLastRow)\n\t\t{\n\t\t\tif (!_config.newline)\n\t\t\t\t_config.newline = guessLineEndings(input);\n\n\t\t\t_delimiterError = false;\n\t\t\tif (!_config.delimiter)\n\t\t\t{\n\t\t\t\tvar delimGuess = guessDelimiter(input, _config.newline, _config.skipEmptyLines);\n\t\t\t\tif (delimGuess.successful)\n\t\t\t\t\t_config.delimiter = delimGuess.bestDelimiter;\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\t_delimiterError = true;\t// add error after parsing (otherwise it would be overwritten)\n\t\t\t\t\t_config.delimiter = Papa.DefaultDelimiter;\n\t\t\t\t}\n\t\t\t\t_results.meta.delimiter = _config.delimiter;\n\t\t\t}\n\t\t\telse if(isFunction(_config.delimiter))\n\t\t\t{\n\t\t\t\t_config.delimiter = _config.delimiter(input);\n\t\t\t\t_results.meta.delimiter = _config.delimiter;\n\t\t\t}\n\n\t\t\tvar parserConfig = copy(_config);\n\t\t\tif (_config.preview && _config.header)\n\t\t\t\tparserConfig.preview++;\t// to compensate for header row\n\n\t\t\t_input = input;\n\t\t\t_parser = new Parser(parserConfig);\n\t\t\t_results = _parser.parse(_input, baseIndex, ignoreLastRow);\n\t\t\tprocessResults();\n\t\t\treturn _paused ? { meta: { paused: true } } : (_results || { meta: { paused: false } });\n\t\t};\n\n\t\tthis.paused = function()\n\t\t{\n\t\t\treturn _paused;\n\t\t};\n\n\t\tthis.pause = function()\n\t\t{\n\t\t\t_paused = true;\n\t\t\t_parser.abort();\n\t\t\t_input = _input.substr(_parser.getCharIndex());\n\t\t};\n\n\t\tthis.resume = function()\n\t\t{\n\t\t\t_paused = false;\n\t\t\tself.streamer.parseChunk(_input, true);\n\t\t};\n\n\t\tthis.aborted = function()\n\t\t{\n\t\t\treturn _aborted;\n\t\t};\n\n\t\tthis.abort = function()\n\t\t{\n\t\t\t_aborted = true;\n\t\t\t_parser.abort();\n\t\t\t_results.meta.aborted = true;\n\t\t\tif (isFunction(_config.complete))\n\t\t\t\t_config.complete(_results);\n\t\t\t_input = '';\n\t\t};\n\n\t\tfunction processResults()\n\t\t{\n\t\t\tif (_results && _delimiterError)\n\t\t\t{\n\t\t\t\taddError('Delimiter', 'UndetectableDelimiter', 'Unable to auto-detect delimiting character; defaulted to \\'' + Papa.DefaultDelimiter + '\\'');\n\t\t\t\t_delimiterError = false;\n\t\t\t}\n\n\t\t\tif (_config.skipEmptyLines)\n\t\t\t{\n\t\t\t\tfor (var i = 0; i < _results.data.length; i++)\n\t\t\t\t\tif (_results.data[i].length === 1 && _results.data[i][0] === '')\n\t\t\t\t\t\t_results.data.splice(i--, 1);\n\t\t\t}\n\n\t\t\tif (needsHeaderRow())\n\t\t\t\tfillHeaderFields();\n\n\t\t\treturn applyHeaderAndDynamicTyping();\n\t\t}\n\n\t\tfunction needsHeaderRow()\n\t\t{\n\t\t\treturn _config.header && _fields.length === 0;\n\t\t}\n\n\t\tfunction fillHeaderFields()\n\t\t{\n\t\t\tif (!_results)\n\t\t\t\treturn;\n\t\t\tfor (var i = 0; needsHeaderRow() && i < _results.data.length; i++)\n\t\t\t\tfor (var j = 0; j < _results.data[i].length; j++)\n\t\t\t\t{\n\t\t\t\t\tvar header = _results.data[i][j];\n\n\t\t\t\t\tif (_config.trimHeaders) {\n\t\t\t\t\t\theader = header.trim();\n\t\t\t\t\t}\n\n\t\t\t\t\t_fields.push(header);\n\t\t\t\t}\n\t\t\t_results.data.splice(0, 1);\n\t\t}\n\n\t\tfunction shouldApplyDynamicTyping(field) {\n\t\t\t// Cache function values to avoid calling it for each row\n\t\t\tif (_config.dynamicTypingFunction && _config.dynamicTyping[field] === undefined) {\n\t\t\t\t_config.dynamicTyping[field] = _config.dynamicTypingFunction(field);\n\t\t\t}\n\t\t\treturn (_config.dynamicTyping[field] || _config.dynamicTyping) === true;\n\t\t}\n\n\t\tfunction parseDynamic(field, value)\n\t\t{\n\t\t\tif (shouldApplyDynamicTyping(field))\n\t\t\t{\n\t\t\t\tif (value === 'true' || value === 'TRUE')\n\t\t\t\t\treturn true;\n\t\t\t\telse if (value === 'false' || value === 'FALSE')\n\t\t\t\t\treturn false;\n\t\t\t\telse if(FLOAT.test(value)) {\n\t\t\t\t\treturn parseFloat(value);\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\treturn (value === '' ? null : value);\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn value;\n\t\t}\n\n\t\tfunction applyHeaderAndDynamicTyping()\n\t\t{\n\t\t\tif (!_results || (!_config.header && !_config.dynamicTyping))\n\t\t\t\treturn _results;\n\n\t\t\tfor (var i = 0; i < _results.data.length; i++)\n\t\t\t{\n\t\t\t\tvar row = _config.header ? {} : [];\n\n\t\t\t\tvar j;\n\t\t\t\tfor (j = 0; j < _results.data[i].length; j++)\n\t\t\t\t{\n\t\t\t\t\tvar field = j;\n\t\t\t\t\tvar value = _results.data[i][j];\n\n\t\t\t\t\tif (_config.header)\n\t\t\t\t\t\tfield = j >= _fields.length ? '__parsed_extra' : _fields[j];\n\n\t\t\t\t\tvalue = parseDynamic(field, value);\n\n\t\t\t\t\tif (field === '__parsed_extra')\n\t\t\t\t\t{\n\t\t\t\t\t\trow[field] = row[field] || [];\n\t\t\t\t\t\trow[field].push(value);\n\t\t\t\t\t}\n\t\t\t\t\telse\n\t\t\t\t\t\trow[field] = value;\n\t\t\t\t}\n\n\t\t\t\t_results.data[i] = row;\n\n\t\t\t\tif (_config.header)\n\t\t\t\t{\n\t\t\t\t\tif (j > _fields.length)\n\t\t\t\t\t\taddError('FieldMismatch', 'TooManyFields', 'Too many fields: expected ' + _fields.length + ' fields but parsed ' + j, i);\n\t\t\t\t\telse if (j < _fields.length)\n\t\t\t\t\t\taddError('FieldMismatch', 'TooFewFields', 'Too few fields: expected ' + _fields.length + ' fields but parsed ' + j, i);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (_config.header && _results.meta)\n\t\t\t\t_results.meta.fields = _fields;\n\t\t\treturn _results;\n\t\t}\n\n\t\tfunction guessDelimiter(input, newline, skipEmptyLines)\n\t\t{\n\t\t\tvar delimChoices = [',', '\\t', '|', ';', Papa.RECORD_SEP, Papa.UNIT_SEP];\n\t\t\tvar bestDelim, bestDelta, fieldCountPrevRow;\n\n\t\t\tfor (var i = 0; i < delimChoices.length; i++)\n\t\t\t{\n\t\t\t\tvar delim = delimChoices[i];\n\t\t\t\tvar delta = 0, avgFieldCount = 0, emptyLinesCount = 0;\n\t\t\t\tfieldCountPrevRow = undefined;\n\n\t\t\t\tvar preview = new Parser({\n\t\t\t\t\tdelimiter: delim,\n\t\t\t\t\tnewline: newline,\n\t\t\t\t\tpreview: 10\n\t\t\t\t}).parse(input);\n\n\t\t\t\tfor (var j = 0; j < preview.data.length; j++)\n\t\t\t\t{\n\t\t\t\t\tif (skipEmptyLines && preview.data[j].length === 1 && preview.data[j][0].length === 0) {\n\t\t\t\t\t\temptyLinesCount++;\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\t\t\t\t\tvar fieldCount = preview.data[j].length;\n\t\t\t\t\tavgFieldCount += fieldCount;\n\n\t\t\t\t\tif (typeof fieldCountPrevRow === 'undefined')\n\t\t\t\t\t{\n\t\t\t\t\t\tfieldCountPrevRow = fieldCount;\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\t\t\t\t\telse if (fieldCount > 1)\n\t\t\t\t\t{\n\t\t\t\t\t\tdelta += Math.abs(fieldCount - fieldCountPrevRow);\n\t\t\t\t\t\tfieldCountPrevRow = fieldCount;\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tif (preview.data.length > 0)\n\t\t\t\t\tavgFieldCount /= (preview.data.length - emptyLinesCount);\n\n\t\t\t\tif ((typeof bestDelta === 'undefined' || delta < bestDelta)\n\t\t\t\t\t&& avgFieldCount > 1.99)\n\t\t\t\t{\n\t\t\t\t\tbestDelta = delta;\n\t\t\t\t\tbestDelim = delim;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t_config.delimiter = bestDelim;\n\n\t\t\treturn {\n\t\t\t\tsuccessful: !!bestDelim,\n\t\t\t\tbestDelimiter: bestDelim\n\t\t\t};\n\t\t}\n\n\t\tfunction guessLineEndings(input)\n\t\t{\n\t\t\tinput = input.substr(0, 1024 * 1024);\t// max length 1 MB\n\n\t\t\tvar r = input.split('\\r');\n\n\t\t\tvar n = input.split('\\n');\n\n\t\t\tvar nAppearsFirst = (n.length > 1 && n[0].length < r[0].length);\n\n\t\t\tif (r.length === 1 || nAppearsFirst)\n\t\t\t\treturn '\\n';\n\n\t\t\tvar numWithN = 0;\n\t\t\tfor (var i = 0; i < r.length; i++)\n\t\t\t{\n\t\t\t\tif (r[i][0] === '\\n')\n\t\t\t\t\tnumWithN++;\n\t\t\t}\n\n\t\t\treturn numWithN >= r.length / 2 ? '\\r\\n' : '\\r';\n\t\t}\n\n\t\tfunction addError(type, code, msg, row)\n\t\t{\n\t\t\t_results.errors.push({\n\t\t\t\ttype: type,\n\t\t\t\tcode: code,\n\t\t\t\tmessage: msg,\n\t\t\t\trow: row\n\t\t\t});\n\t\t}\n\t}\n\n\n\n\n\n\t/** The core parser implements speedy and correct CSV parsing */\n\tfunction Parser(config)\n\t{\n\t\t// Unpack the config object\n\t\tconfig = config || {};\n\t\tvar delim = config.delimiter;\n\t\tvar newline = config.newline;\n\t\tvar comments = config.comments;\n\t\tvar step = config.step;\n\t\tvar preview = config.preview;\n\t\tvar fastMode = config.fastMode;\n\t\tvar quoteChar;\n\t\t/** Allows for no quoteChar by setting quoteChar to undefined in config */\n\t\tif (config.quoteChar === undefined) {\n\t\t\tquoteChar = '\"';\n\t\t} else {\n\t\t\tquoteChar = config.quoteChar;\n\t\t}\n\t\tvar escapeChar = quoteChar;\n\t\tif (config.escapeChar !== undefined) {\n\t\t\tescapeChar = config.escapeChar;\n\t\t}\n\n\t\t// Delimiter must be valid\n\t\tif (typeof delim !== 'string'\n\t\t\t|| Papa.BAD_DELIMITERS.indexOf(delim) > -1)\n\t\t\tdelim = ',';\n\n\t\t// Comment character must be valid\n\t\tif (comments === delim)\n\t\t\tthrow 'Comment character same as delimiter';\n\t\telse if (comments === true)\n\t\t\tcomments = '#';\n\t\telse if (typeof comments !== 'string'\n\t\t\t|| Papa.BAD_DELIMITERS.indexOf(comments) > -1)\n\t\t\tcomments = false;\n\n\t\t// Newline must be valid: \\r, \\n, or \\r\\n\n\t\tif (newline !== '\\n' && newline !== '\\r' && newline !== '\\r\\n')\n\t\t\tnewline = '\\n';\n\n\t\t// We're gonna need these at the Parser scope\n\t\tvar cursor = 0;\n\t\tvar aborted = false;\n\n\t\tthis.parse = function(input, baseIndex, ignoreLastRow)\n\t\t{\n\t\t\t// For some reason, in Chrome, this speeds things up (!?)\n\t\t\tif (typeof input !== 'string')\n\t\t\t\tthrow 'Input must be a string';\n\n\t\t\t// We don't need to compute some of these every time parse() is called,\n\t\t\t// but having them in a more local scope seems to perform better\n\t\t\tvar inputLen = input.length,\n\t\t\t\tdelimLen = delim.length,\n\t\t\t\tnewlineLen = newline.length,\n\t\t\t\tcommentsLen = comments.length;\n\t\t\tvar stepIsFunction = isFunction(step);\n\n\t\t\t// Establish starting state\n\t\t\tcursor = 0;\n\t\t\tvar data = [], errors = [], row = [], lastCursor = 0;\n\n\t\t\tif (!input)\n\t\t\t\treturn returnable();\n\n\t\t\tif (fastMode || (fastMode !== false && input.indexOf(quoteChar) === -1))\n\t\t\t{\n\t\t\t\tvar rows = input.split(newline);\n\t\t\t\tfor (var i = 0; i < rows.length; i++)\n\t\t\t\t{\n\t\t\t\t\trow = rows[i];\n\t\t\t\t\tcursor += row.length;\n\t\t\t\t\tif (i !== rows.length - 1)\n\t\t\t\t\t\tcursor += newline.length;\n\t\t\t\t\telse if (ignoreLastRow)\n\t\t\t\t\t\treturn returnable();\n\t\t\t\t\tif (comments && row.substr(0, commentsLen) === comments)\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\tif (stepIsFunction)\n\t\t\t\t\t{\n\t\t\t\t\t\tdata = [];\n\t\t\t\t\t\tpushRow(row.split(delim));\n\t\t\t\t\t\tdoStep();\n\t\t\t\t\t\tif (aborted)\n\t\t\t\t\t\t\treturn returnable();\n\t\t\t\t\t}\n\t\t\t\t\telse\n\t\t\t\t\t\tpushRow(row.split(delim));\n\t\t\t\t\tif (preview && i >= preview)\n\t\t\t\t\t{\n\t\t\t\t\t\tdata = data.slice(0, preview);\n\t\t\t\t\t\treturn returnable(true);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\treturn returnable();\n\t\t\t}\n\n\t\t\tvar nextDelim = input.indexOf(delim, cursor);\n\t\t\tvar nextNewline = input.indexOf(newline, cursor);\n\t\t\tvar quoteCharRegex = new RegExp(escapeChar.replace(/[-[\\]/{}()*+?.\\\\^$|]/g, '\\\\$&') + quoteChar, 'g');\n\t\t\tvar quoteSearch;\n\n\t\t\t// Parser loop\n\t\t\tfor (;;)\n\t\t\t{\n\t\t\t\t// Field has opening quote\n\t\t\t\tif (input[cursor] === quoteChar)\n\t\t\t\t{\n\t\t\t\t\t// Start our search for the closing quote where the cursor is\n\t\t\t\t\tquoteSearch = cursor;\n\n\t\t\t\t\t// Skip the opening quote\n\t\t\t\t\tcursor++;\n\n\t\t\t\t\tfor (;;)\n\t\t\t\t\t{\n\t\t\t\t\t\t// Find closing quote\n\t\t\t\t\t\tquoteSearch = input.indexOf(quoteChar, quoteSearch + 1);\n\n\t\t\t\t\t\t//No other quotes are found - no other delimiters\n\t\t\t\t\t\tif (quoteSearch === -1)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tif (!ignoreLastRow) {\n\t\t\t\t\t\t\t\t// No closing quote... what a pity\n\t\t\t\t\t\t\t\terrors.push({\n\t\t\t\t\t\t\t\t\ttype: 'Quotes',\n\t\t\t\t\t\t\t\t\tcode: 'MissingQuotes',\n\t\t\t\t\t\t\t\t\tmessage: 'Quoted field unterminated',\n\t\t\t\t\t\t\t\t\trow: data.length,\t// row has yet to be inserted\n\t\t\t\t\t\t\t\t\tindex: cursor\n\t\t\t\t\t\t\t\t});\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\treturn finish();\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\t// Closing quote at EOF\n\t\t\t\t\t\tif (quoteSearch === inputLen - 1)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tvar value = input.substring(cursor, quoteSearch).replace(quoteCharRegex, quoteChar);\n\t\t\t\t\t\t\treturn finish(value);\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\t// If this quote is escaped, it's part of the data; skip it\n\t\t\t\t\t\t// If the quote character is the escape character, then check if the next character is the escape character\n\t\t\t\t\t\tif (quoteChar === escapeChar &&  input[quoteSearch + 1] === escapeChar)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tquoteSearch++;\n\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\t// If the quote character is not the escape character, then check if the previous character was the escape character\n\t\t\t\t\t\tif (quoteChar !== escapeChar && quoteSearch !== 0 && input[quoteSearch - 1] === escapeChar)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tvar spacesBetweenQuoteAndDelimiter = extraSpaces(nextDelim);\n\n\t\t\t\t\t\t// Closing quote followed by delimiter or 'unnecessary steps + delimiter'\n\t\t\t\t\t\tif (input[quoteSearch + 1 + spacesBetweenQuoteAndDelimiter] === delim)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\trow.push(input.substring(cursor, quoteSearch).replace(quoteCharRegex, quoteChar));\n\t\t\t\t\t\t\tcursor = quoteSearch + 1 + spacesBetweenQuoteAndDelimiter + delimLen;\n\t\t\t\t\t\t\tnextDelim = input.indexOf(delim, cursor);\n\t\t\t\t\t\t\tnextNewline = input.indexOf(newline, cursor);\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tvar spacesBetweenQuoteAndNewLine = extraSpaces(nextNewline);\n\n\t\t\t\t\t\t// Closing quote followed by newline or 'unnecessary spaces + newLine'\n\t\t\t\t\t\tif (input.substr(quoteSearch + 1 + spacesBetweenQuoteAndNewLine, newlineLen) === newline)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\trow.push(input.substring(cursor, quoteSearch).replace(quoteCharRegex, quoteChar));\n\t\t\t\t\t\t\tsaveRow(quoteSearch + 1 + spacesBetweenQuoteAndNewLine + newlineLen);\n\t\t\t\t\t\t\tnextDelim = input.indexOf(delim, cursor);\t// because we may have skipped the nextDelim in the quoted field\n\n\t\t\t\t\t\t\tif (stepIsFunction)\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\tdoStep();\n\t\t\t\t\t\t\t\tif (aborted)\n\t\t\t\t\t\t\t\t\treturn returnable();\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\tif (preview && data.length >= preview)\n\t\t\t\t\t\t\t\treturn returnable(true);\n\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\n\n\t\t\t\t\t\t// Checks for valid closing quotes are complete (escaped quotes or quote followed by EOF/delimiter/newline) -- assume these quotes are part of an invalid text string\n\t\t\t\t\t\terrors.push({\n\t\t\t\t\t\t\ttype: 'Quotes',\n\t\t\t\t\t\t\tcode: 'InvalidQuotes',\n\t\t\t\t\t\t\tmessage: 'Trailing quote on quoted field is malformed',\n\t\t\t\t\t\t\trow: data.length,\t// row has yet to be inserted\n\t\t\t\t\t\t\tindex: cursor\n\t\t\t\t\t\t});\n\n\t\t\t\t\t\tquoteSearch++;\n\t\t\t\t\t\tcontinue;\n\n\t\t\t\t\t}\n\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\n\t\t\t\t// Comment found at start of new line\n\t\t\t\tif (comments && row.length === 0 && input.substr(cursor, commentsLen) === comments)\n\t\t\t\t{\n\t\t\t\t\tif (nextNewline === -1)\t// Comment ends at EOF\n\t\t\t\t\t\treturn returnable();\n\t\t\t\t\tcursor = nextNewline + newlineLen;\n\t\t\t\t\tnextNewline = input.indexOf(newline, cursor);\n\t\t\t\t\tnextDelim = input.indexOf(delim, cursor);\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\n\t\t\t\t// Next delimiter comes before next newline, so we've reached end of field\n\t\t\t\tif (nextDelim !== -1 && (nextDelim < nextNewline || nextNewline === -1))\n\t\t\t\t{\n\t\t\t\t\trow.push(input.substring(cursor, nextDelim));\n\t\t\t\t\tcursor = nextDelim + delimLen;\n\t\t\t\t\tnextDelim = input.indexOf(delim, cursor);\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\n\t\t\t\t// End of row\n\t\t\t\tif (nextNewline !== -1)\n\t\t\t\t{\n\t\t\t\t\trow.push(input.substring(cursor, nextNewline));\n\t\t\t\t\tsaveRow(nextNewline + newlineLen);\n\n\t\t\t\t\tif (stepIsFunction)\n\t\t\t\t\t{\n\t\t\t\t\t\tdoStep();\n\t\t\t\t\t\tif (aborted)\n\t\t\t\t\t\t\treturn returnable();\n\t\t\t\t\t}\n\n\t\t\t\t\tif (preview && data.length >= preview)\n\t\t\t\t\t\treturn returnable(true);\n\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\n\t\t\t\tbreak;\n\t\t\t}\n\n\n\t\t\treturn finish();\n\n\n\t\t\tfunction pushRow(row)\n\t\t\t{\n\t\t\t\tdata.push(row);\n\t\t\t\tlastCursor = cursor;\n\t\t\t}\n\n\t\t\t/**\n             * checks if there are extra spaces after closing quote and given index without any text\n             * if Yes, returns the number of spaces\n             */\n\t\t\tfunction extraSpaces(index) {\n\t\t\t\tvar spaceLength = 0;\n\t\t\t\tif (index !== -1) {\n\t\t\t\t\tvar textBetweenClosingQuoteAndIndex = input.substring(quoteSearch + 1, index);\n\t\t\t\t\tif (textBetweenClosingQuoteAndIndex && textBetweenClosingQuoteAndIndex.trim() === '') {\n\t\t\t\t\t\tspaceLength = textBetweenClosingQuoteAndIndex.length;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\treturn spaceLength;\n\t\t\t}\n\n\t\t\t/**\n\t\t\t * Appends the remaining input from cursor to the end into\n\t\t\t * row, saves the row, calls step, and returns the results.\n\t\t\t */\n\t\t\tfunction finish(value)\n\t\t\t{\n\t\t\t\tif (ignoreLastRow)\n\t\t\t\t\treturn returnable();\n\t\t\t\tif (typeof value === 'undefined')\n\t\t\t\t\tvalue = input.substr(cursor);\n\t\t\t\trow.push(value);\n\t\t\t\tcursor = inputLen;\t// important in case parsing is paused\n\t\t\t\tpushRow(row);\n\t\t\t\tif (stepIsFunction)\n\t\t\t\t\tdoStep();\n\t\t\t\treturn returnable();\n\t\t\t}\n\n\t\t\t/**\n\t\t\t * Appends the current row to the results. It sets the cursor\n\t\t\t * to newCursor and finds the nextNewline. The caller should\n\t\t\t * take care to execute user's step function and check for\n\t\t\t * preview and end parsing if necessary.\n\t\t\t */\n\t\t\tfunction saveRow(newCursor)\n\t\t\t{\n\t\t\t\tcursor = newCursor;\n\t\t\t\tpushRow(row);\n\t\t\t\trow = [];\n\t\t\t\tnextNewline = input.indexOf(newline, cursor);\n\t\t\t}\n\n\t\t\t/** Returns an object with the results, errors, and meta. */\n\t\t\tfunction returnable(stopped)\n\t\t\t{\n\t\t\t\treturn {\n\t\t\t\t\tdata: data,\n\t\t\t\t\terrors: errors,\n\t\t\t\t\tmeta: {\n\t\t\t\t\t\tdelimiter: delim,\n\t\t\t\t\t\tlinebreak: newline,\n\t\t\t\t\t\taborted: aborted,\n\t\t\t\t\t\ttruncated: !!stopped,\n\t\t\t\t\t\tcursor: lastCursor + (baseIndex || 0)\n\t\t\t\t\t}\n\t\t\t\t};\n\t\t\t}\n\n\t\t\t/** Executes the user's step function and resets data & errors. */\n\t\t\tfunction doStep()\n\t\t\t{\n\t\t\t\tstep(returnable());\n\t\t\t\tdata = [];\n\t\t\t\terrors = [];\n\t\t\t}\n\t\t};\n\n\t\t/** Sets the abort flag */\n\t\tthis.abort = function()\n\t\t{\n\t\t\taborted = true;\n\t\t};\n\n\t\t/** Gets the cursor position */\n\t\tthis.getCharIndex = function()\n\t\t{\n\t\t\treturn cursor;\n\t\t};\n\t}\n\n\n\t// If you need to load Papa Parse asynchronously and you also need worker threads, hard-code\n\t// the script path here. See: https://github.com/mholt/PapaParse/issues/87#issuecomment-57885358\n\tfunction getScriptPath()\n\t{\n\t\tvar scripts = document.getElementsByTagName('script');\n\t\treturn scripts.length ? scripts[scripts.length - 1].src : '';\n\t}\n\n\tfunction newWorker()\n\t{\n\t\tif (!Papa.WORKERS_SUPPORTED)\n\t\t\treturn false;\n\t\tif (!LOADED_SYNC && Papa.SCRIPT_PATH === null)\n\t\t\tthrow new Error(\n\t\t\t\t'Script path cannot be determined automatically when Papa Parse is loaded asynchronously. ' +\n\t\t\t\t'You need to set Papa.SCRIPT_PATH manually.'\n\t\t\t);\n\t\tvar workerUrl = Papa.SCRIPT_PATH || AUTO_SCRIPT_PATH;\n\t\t// Append 'papaworker' to the search string to tell papaparse that this is our worker.\n\t\tworkerUrl += (workerUrl.indexOf('?') !== -1 ? '&' : '?') + 'papaworker';\n\t\tvar w = new global.Worker(workerUrl);\n\t\tw.onmessage = mainThreadReceivedMessage;\n\t\tw.id = workerIdCounter++;\n\t\tworkers[w.id] = w;\n\t\treturn w;\n\t}\n\n\t/** Callback when main thread receives a message */\n\tfunction mainThreadReceivedMessage(e)\n\t{\n\t\tvar msg = e.data;\n\t\tvar worker = workers[msg.workerId];\n\t\tvar aborted = false;\n\n\t\tif (msg.error)\n\t\t\tworker.userError(msg.error, msg.file);\n\t\telse if (msg.results && msg.results.data)\n\t\t{\n\t\t\tvar abort = function() {\n\t\t\t\taborted = true;\n\t\t\t\tcompleteWorker(msg.workerId, { data: [], errors: [], meta: { aborted: true } });\n\t\t\t};\n\n\t\t\tvar handle = {\n\t\t\t\tabort: abort,\n\t\t\t\tpause: notImplemented,\n\t\t\t\tresume: notImplemented\n\t\t\t};\n\n\t\t\tif (isFunction(worker.userStep))\n\t\t\t{\n\t\t\t\tfor (var i = 0; i < msg.results.data.length; i++)\n\t\t\t\t{\n\t\t\t\t\tworker.userStep({\n\t\t\t\t\t\tdata: [msg.results.data[i]],\n\t\t\t\t\t\terrors: msg.results.errors,\n\t\t\t\t\t\tmeta: msg.results.meta\n\t\t\t\t\t}, handle);\n\t\t\t\t\tif (aborted)\n\t\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tdelete msg.results;\t// free memory ASAP\n\t\t\t}\n\t\t\telse if (isFunction(worker.userChunk))\n\t\t\t{\n\t\t\t\tworker.userChunk(msg.results, handle, msg.file);\n\t\t\t\tdelete msg.results;\n\t\t\t}\n\t\t}\n\n\t\tif (msg.finished && !aborted)\n\t\t\tcompleteWorker(msg.workerId, msg.results);\n\t}\n\n\tfunction completeWorker(workerId, results) {\n\t\tvar worker = workers[workerId];\n\t\tif (isFunction(worker.userComplete))\n\t\t\tworker.userComplete(results);\n\t\tworker.terminate();\n\t\tdelete workers[workerId];\n\t}\n\n\tfunction notImplemented() {\n\t\tthrow 'Not implemented.';\n\t}\n\n\t/** Callback when worker thread receives a message */\n\tfunction workerThreadReceivedMessage(e)\n\t{\n\t\tvar msg = e.data;\n\n\t\tif (typeof Papa.WORKER_ID === 'undefined' && msg)\n\t\t\tPapa.WORKER_ID = msg.workerId;\n\n\t\tif (typeof msg.input === 'string')\n\t\t{\n\t\t\tglobal.postMessage({\n\t\t\t\tworkerId: Papa.WORKER_ID,\n\t\t\t\tresults: Papa.parse(msg.input, msg.config),\n\t\t\t\tfinished: true\n\t\t\t});\n\t\t}\n\t\telse if ((global.File && msg.input instanceof File) || msg.input instanceof Object)\t// thank you, Safari (see issue #106)\n\t\t{\n\t\t\tvar results = Papa.parse(msg.input, msg.config);\n\t\t\tif (results)\n\t\t\t\tglobal.postMessage({\n\t\t\t\t\tworkerId: Papa.WORKER_ID,\n\t\t\t\t\tresults: results,\n\t\t\t\t\tfinished: true\n\t\t\t\t});\n\t\t}\n\t}\n\n\t/** Makes a deep copy of an array or object (mostly) */\n\tfunction copy(obj)\n\t{\n\t\tif (typeof obj !== 'object')\n\t\t\treturn obj;\n\t\tvar cpy = obj instanceof Array ? [] : {};\n\t\tfor (var key in obj)\n\t\t\tcpy[key] = copy(obj[key]);\n\t\treturn cpy;\n\t}\n\n\tfunction bindFunction(f, self)\n\t{\n\t\treturn function() { f.apply(self, arguments); };\n\t}\n\n\tfunction isFunction(func)\n\t{\n\t\treturn typeof func === 'function';\n\t}\n\n\treturn Papa;\n}));\n","//\r\n// An iterator that returns no values.\r\n//\r\n\r\nexport class EmptyIterator implements Iterator<any> {\r\n\r\n    next(): IteratorResult<any> {\r\n        return {\r\n            done: true,\r\n            value: null\r\n        };\r\n    }\r\n}","//\r\n// An iterator that simply counts up from zero.\r\n// This creates the default index in Data-Forge.\r\n//\r\n\r\nexport class CountIterator implements Iterator<number> {\r\n\r\n    index: number = 0;\r\n\r\n    next(): IteratorResult<number> {\r\n        return {\r\n            done: false,\r\n            value: this.index++\r\n        };\r\n    }\r\n\r\n}","//\r\n// An iterator that can iterate multiple other iterators at once.\r\n// This allows iterators to be composed.\r\n// This is used in Data-Forge to combine iterators for index and values.\r\n//\r\n\r\nexport class MultiIterator implements Iterator<any[]> {\r\n\r\n    iterators: Iterator<any>[];\r\n\r\n    constructor(iterators: Iterator<any>[]) {\r\n        this.iterators = iterators;\r\n    }\r\n\r\n    next(): IteratorResult<any[]> {\r\n\r\n        if (this.iterators.length === 0) {\r\n            return {\r\n                done: true,\r\n                value: [],\r\n            };\r\n        }\r\n\r\n        var multiResult = [];\r\n\r\n        for (const iterator of this.iterators) {\r\n            var result = iterator.next();\r\n            if (result.done) {\r\n                return { \r\n                    done: true,\r\n                    value: [],\r\n                };\r\n            }\r\n\r\n            multiResult.push(result.value);\r\n        }\r\n\r\n        return {\r\n            done: false,\r\n            value: multiResult\r\n        };\r\n    }\r\n\r\n}","//\r\n// An iterator that applies a selector function to each item.\r\n//\r\n\r\nexport type SelectorFn<ValueT, ToT> = (value: ValueT, index: number) => ToT;\r\n\r\nexport class SelectIterator<ValueT, ToT> implements Iterator<ToT> {\r\n\r\n    iterator: Iterator<ValueT>;\r\n    selector: SelectorFn<ValueT, ToT>;\r\n    index: number = 0;\r\n\r\n    constructor(iterator: Iterator<ValueT>, selector: SelectorFn<ValueT, ToT>) {\r\n        this.iterator = iterator;\r\n        this.selector = selector;\r\n    }\r\n\r\n    next(): IteratorResult<ToT> {\r\n        var result = this.iterator.next();\r\n        if (result.done) {\r\n            // https://github.com/Microsoft/TypeScript/issues/8938\r\n            return ({ done: true } as IteratorResult<ToT>)  // <= explicit cast here!;\r\n        }\r\n\r\n        return {\r\n            done: false,\r\n            value: this.selector(result.value, this.index++)\r\n        };\r\n    }\r\n}","//\r\n// An iterator that applies a selector function to each item.\r\n//\r\n\r\nexport type SelectorFn<ValueT, ToT> = (value: ValueT, index: number) => Iterable<ToT>;\r\n\r\nexport class SelectManyIterator<ValueT, ToT> implements Iterator<ToT> {\r\n\r\n    iterator: Iterator<ValueT>;\r\n    outputIterator: Iterator<ToT> | null;\r\n    selector: SelectorFn<ValueT, ToT>;\r\n    index: number = 0;\r\n\r\n    constructor(iterator: Iterator<ValueT>, selector: SelectorFn<ValueT, ToT>) {\r\n        this.iterator = iterator;\r\n        this.selector = selector;\r\n        this.outputIterator = null;\r\n    }\r\n\r\n    next(): IteratorResult<ToT> {     \r\n        while (true) {\r\n            if (this.outputIterator === null) {\r\n                var result = this.iterator.next();\r\n                if (result.done) {\r\n                    // https://github.com/Microsoft/TypeScript/issues/8938\r\n                    return ({ done: true } as IteratorResult<ToT>)  // <= explicit cast here!;\r\n                }\r\n\r\n                let outputIterable = this.selector(result.value, this.index++);\r\n                this.outputIterator = outputIterable[Symbol.iterator]();\r\n            }\r\n\r\n            var outputResult = this.outputIterator!.next();\r\n            if (outputResult.done) {\r\n                this.outputIterator = null;\r\n                continue;\r\n            }\r\n            else {\r\n                return outputResult;\r\n            }\r\n        }   \r\n    }\r\n}","//\r\n// An iterator that a sequence of elements while a predicate function returns true.\r\n//\r\n\r\nexport class TakeIterator<T> implements Iterator<T> {\r\n\r\n    childIterator: Iterator<T>;\r\n    numElements: number;\r\n\r\n    constructor(childIterator: Iterator<T>, numElements: number) {\r\n        this.childIterator = childIterator;\r\n        this.numElements = numElements;\r\n    }\r\n\r\n    next(): IteratorResult<T> {\r\n        if (this.numElements <= 0) {\r\n            // https://github.com/Microsoft/TypeScript/issues/8938\r\n            return ({ done: true } as IteratorResult<T>)  // <= explicit cast here!;\r\n        }\r\n\r\n        --this.numElements;\r\n        return this.childIterator.next();\r\n    }\r\n}","//\r\n// An iterator that takes a sequence of elements while a predicate function returns true.\r\n//\r\n\r\n/**\r\n * A predicate function, returns true or false based on input.\r\n */\r\nexport type PredicateFn<InputT> = (value: InputT) => boolean;\r\n\r\nexport class TakeWhileIterator<T> implements Iterator<T> {\r\n\r\n    childIterator: Iterator<T>;\r\n    predicate: PredicateFn<T>;\r\n    done: boolean = false;\r\n\r\n    constructor(childIterator: Iterator<T>, predicate: PredicateFn<T>) {\r\n        this.childIterator = childIterator;\r\n        this.predicate = predicate;\r\n    }\r\n\r\n    next(): IteratorResult<T> {\r\n        if (!this.done) {\r\n            var result = this.childIterator.next();\r\n            if (result.done) {\r\n                this.done = true;\r\n            }\r\n            else if (this.predicate(result.value)) {\r\n                return result;\r\n            }\r\n            else {\r\n                this.done = true;\r\n            }\r\n        }\r\n\r\n        // https://github.com/Microsoft/TypeScript/issues/8938\r\n        return ({ done: true } as IteratorResult<T>)  // <= explicit cast here!;\r\n    }\r\n}","//\r\n// An iterator that takes elements from a child iterator based on a predicate function.\r\n//\r\n\r\n/**\r\n * A predicate function, returns true or false based on input.\r\n */\r\nexport type PredicateFn<InputT> = (value: InputT) => boolean;\r\n\r\nexport class WhereIterator<T> implements Iterator<T> {\r\n\r\n    childIterator: Iterator<T>;\r\n    predicate: PredicateFn<T>;\r\n\r\n    constructor(childIterator: Iterator<T>, predicate: PredicateFn<T>) {\r\n        this.childIterator = childIterator;\r\n        this.predicate = predicate;\r\n    }\r\n\r\n    next(): IteratorResult<T> {\r\n        while (true) {\r\n            var result = this.childIterator.next();\r\n            if (result.done) {\r\n                return result;\r\n            }\r\n\r\n            if (this.predicate(result.value)) {\r\n                // It matches the predicate.\r\n                return result;\r\n            }\r\n        }\r\n    }\r\n}","//\r\n// An iterator that concatenates multiple iterables.\r\n//\r\n\r\nexport class ConcatIterator<T> implements Iterator<T> {\r\n\r\n    iterables: Iterable<Iterable<T>>\r\n    iterator: Iterator<Iterable<T>>;\r\n    curIterator: Iterator<T> | null = null;\r\n\r\n    constructor(iterables: Iterable<Iterable<T>>) {\r\n        this.iterables = iterables;\r\n        this.iterator = iterables[Symbol.iterator]();\r\n        this.moveToNextIterable();\r\n    }\r\n\r\n    //\r\n    // Move onto the next iterable.\r\n    //\r\n    private moveToNextIterable () {\r\n        const nextIterable = this.iterator.next();\r\n        if (nextIterable.done) {\r\n            this.curIterator = null;\r\n        }\r\n        else {\r\n            this.curIterator = nextIterable.value[Symbol.iterator]();\r\n        }        \r\n    }\r\n\r\n    next(): IteratorResult<T> {\r\n\r\n        while (true) {\r\n            if (this.curIterator == null) {\r\n                // Finished iterating all sub-iterators.\r\n                // https://github.com/Microsoft/TypeScript/issues/8938\r\n                return ({ done: true } as IteratorResult<T>)  // <= explicit cast here!;\r\n            }\r\n\r\n            const result = this.curIterator.next();\r\n            if (!result.done) {\r\n                return result; // Found a valid result from the current iterable.    \r\n            }\r\n\r\n            // Find the next non empty iterable.\r\n            this.moveToNextIterable();\r\n        }\r\n    }\r\n\r\n}","//\r\n// Iterates an underlying iterable in the 'windows'.\r\n//\r\n\r\nimport { SeriesWindowIterator } from '../iterators/series-window-iterator';\r\nimport { ISeries } from '../series';\r\n\r\nexport class SeriesWindowIterable<IndexT, ValueT> implements Iterable<ISeries<IndexT, ValueT>> {\r\n\r\n    iterable: Iterable<[IndexT, ValueT]>;\r\n    period: number;\r\n\r\n    constructor(iterable: Iterable<[IndexT, ValueT]>, period: number) {\r\n        this.iterable = iterable;\r\n        this.period = period;\r\n    }\r\n\r\n    [Symbol.iterator](): Iterator<ISeries<IndexT, ValueT>> {\r\n        return new SeriesWindowIterator(this.iterable, this.period);\r\n    }\r\n}","//\r\n// Iterates an underlying iterable in the 'windows'.\r\n//\r\n\r\nimport { TakeIterable } from '../iterables/take-iterable';\r\nimport { SkipIterable } from '../iterables/skip-iterable';\r\nimport { Series, ISeries } from '../series';\r\n\r\nexport class SeriesWindowIterator<IndexT, ValueT> implements Iterator<ISeries<IndexT, ValueT>> {\r\n\r\n    iterable: Iterable<[IndexT, ValueT]>;\r\n    iterator: Iterator<[IndexT, ValueT]> | undefined;\r\n    period: number;\r\n    \r\n    constructor(iterable: Iterable<[IndexT, ValueT]>, period: number) {\r\n        this.iterable = iterable;\r\n        this.period = period;\r\n    }\r\n\r\n    next(): IteratorResult<ISeries<IndexT, ValueT>> {\r\n\r\n        if (!this.iterator) {\r\n            this.iterator = this.iterable[Symbol.iterator]();\r\n        }\r\n\r\n        const curWindow = [];\r\n\r\n        for (let i = 0; i < this.period; ++i) {\r\n            const curPos = this.iterator.next();\r\n            if (curPos.done) {\r\n                // Underlying iterator is finished.\r\n                break;\r\n            }\r\n            curWindow.push(curPos.value);\r\n        }\r\n\r\n        if (curWindow.length === 0) {\r\n            // Underlying iterator doesn't have required number of elements.\r\n            return ({ done: true } as IteratorResult<ISeries<IndexT, ValueT>>);\r\n        }\r\n    \r\n        const window = new Series<IndexT, ValueT>({\r\n            pairs: curWindow\r\n        });\r\n\r\n        return {\r\n            value: window,\r\n            done: false,\r\n        };\r\n    }\r\n}","//\r\n// An iterator that zips together each set of elements in child iterables.\r\n//\r\nimport { Series, ISeries } from '../series';\r\n\r\nexport type ZipFn<ValueT, ReturnT> = (input: ISeries<number, ValueT>) => ReturnT;\r\n\r\nexport class ZipIterator<ValueT, ReturnT> implements Iterator<ReturnT> {\r\n\r\n    iterators: Iterator<ValueT>[];\r\n    zipper: ZipFn<ValueT, ReturnT>;\r\n\r\n    constructor(iterables: Iterable<ValueT>[], zipper: ZipFn<ValueT, ReturnT>) {\r\n        this.iterators = iterables.map(iterable => iterable[Symbol.iterator]());\r\n        this.zipper = zipper;\r\n    }\r\n\r\n    next(): IteratorResult<ReturnT> {\r\n        const results = this.iterators.map(iterator => iterator.next());\r\n        for (const result of results) {\r\n            if (result.done) {\r\n                // If any are done we are all done.\r\n                // https://github.com/Microsoft/TypeScript/issues/8938\r\n                return ({ done: true } as IteratorResult<ReturnT>)  // <= explicit cast here!;                \r\n            }\r\n        }\r\n\r\n        const zippedValues = results.map(result => result.value);\r\n        const zipperInput = new Series<number, ValueT>(zippedValues);\r\n        return {\r\n            done: false,\r\n            value: this.zipper(zipperInput)\r\n        };\r\n    }\r\n}","//\r\n// An iterator that iterates the only distinct elements of another iterable.\r\n//\r\n\r\n/**\r\n * A selector function with no index. Transforms a value into another kind of value.\r\n */\r\nexport type SelectorFnNoIndex<FromT, ToT> = (value: FromT) => ToT;\r\n\r\nexport class DistinctIterator<FromT, ToT> implements Iterator<FromT> {\r\n\r\n    iterator: Iterator<FromT>;\r\n    selector?: SelectorFnNoIndex<FromT, ToT>;\r\n    valuesAlreadySeen: Set<any> = new Set<any>();\r\n\r\n    constructor(iterable: Iterable<FromT>, selector?: SelectorFnNoIndex<FromT, ToT>) {\r\n        this.iterator = iterable[Symbol.iterator]();\r\n        this.selector = selector;\r\n    }\r\n\r\n    next(): IteratorResult<FromT> {\r\n        \r\n        while (true) {\r\n            const result = this.iterator.next();\r\n            if (result.done) {\r\n                return ({ done: true } as IteratorResult<FromT>);\r\n            }\r\n\r\n            let potentialOutput: ToT;\r\n            if (this.selector) {\r\n                potentialOutput = this.selector(result.value);\r\n            }\r\n            else {\r\n                potentialOutput = <ToT> <any> result.value;\r\n            }\r\n\r\n           \r\n            if (this.valuesAlreadySeen.has(potentialOutput)) {\r\n                // Already seen this value.\r\n                // Skip it and continue to next item.\r\n                continue;\r\n            }\r\n            \r\n            this.valuesAlreadySeen.add(potentialOutput);\r\n            return {\r\n                done: false,\r\n                value: result.value,\r\n            };\r\n        }\r\n    }\r\n}","//\r\n// Iterates an underlying iterable in the 'windows'.\r\n//\r\n\r\nimport { SeriesRollingWindowIterator } from '../iterators/series-rolling-window-iterator';\r\nimport { ISeries } from '../series';\r\n\r\nexport class SeriesRollingWindowIterable<IndexT, ValueT> implements Iterable<ISeries<IndexT, ValueT>> {\r\n\r\n    iterable: Iterable<[IndexT, ValueT]>;\r\n    period: number;\r\n\r\n    constructor(iterable: Iterable<[IndexT, ValueT]>, period: number) {\r\n        this.iterable = iterable;\r\n        this.period = period;\r\n    }\r\n\r\n    [Symbol.iterator](): Iterator<ISeries<IndexT, ValueT>> {\r\n        return new SeriesRollingWindowIterator(this.iterable, this.period);\r\n    }\r\n}","//\r\n// Iterates an underlying iterable in the 'windows'.\r\n//\r\n\r\nimport { TakeIterable } from '../iterables/take-iterable';\r\nimport { SkipIterable } from '../iterables/skip-iterable';\r\nimport { Series, ISeries } from '../series';\r\n\r\nexport class SeriesRollingWindowIterator<IndexT, ValueT> implements Iterator<ISeries<IndexT, ValueT>> {\r\n\r\n    iterable: Iterable<[IndexT, ValueT]>;\r\n    iterator: Iterator<[IndexT, ValueT]> | undefined;\r\n    period: number;\r\n    curWindow: [IndexT, ValueT][] | undefined; \r\n    \r\n    constructor(iterable: Iterable<[IndexT, ValueT]>, period: number) {\r\n        this.iterable = iterable;\r\n        this.period = period;\r\n    }\r\n\r\n    next(): IteratorResult<ISeries<IndexT, ValueT>> {\r\n\r\n        if (!this.curWindow) {\r\n            this.curWindow = [];\r\n            this.iterator = this.iterable[Symbol.iterator]();\r\n            for (let i = 0; i < this.period; ++i) {\r\n                const curPos = this.iterator.next();\r\n                if (curPos.done) {\r\n                    // Underlying iterator doesn't have required number of elements.\r\n                    return ({ done: true } as IteratorResult<ISeries<IndexT, ValueT>>);\r\n                }\r\n                this.curWindow.push(curPos.value);\r\n            }\r\n        }\r\n        else {\r\n            this.curWindow.shift(); // Remove first item from window.\r\n            \r\n            const curPos = this.iterator!.next();\r\n            if (curPos.done) {\r\n                // Underlying iterator doesn't have enough elements left.\r\n                return ({ done: true } as IteratorResult<ISeries<IndexT, ValueT>>);\r\n            }\r\n\r\n            this.curWindow.push(curPos.value); // Add next item to window.\r\n        }\r\n\r\n        const window = new Series<IndexT, ValueT>({\r\n            pairs: this.curWindow\r\n        });\r\n\r\n        return {\r\n            value: window,\r\n            done: false,\r\n        };\r\n    }\r\n}","//\r\n// Iterates an underlying iterable in the 'windows'.\r\n//\r\n\r\nimport { SeriesVariableWindowIterator, ComparerFn } from '../iterators/series-variable-window-iterator';\r\nimport { ISeries } from '../series';\r\n\r\nexport class SeriesVariableWindowIterable<IndexT, ValueT> implements Iterable<ISeries<IndexT, ValueT>> {\r\n\r\n    iterable: Iterable<[IndexT, ValueT]>;\r\n    comparer: ComparerFn<ValueT>;\r\n\r\n    constructor(iterable: Iterable<[IndexT, ValueT]>, comparer: ComparerFn<ValueT>) {\r\n        this.iterable = iterable;\r\n        this.comparer = comparer;\r\n    }\r\n\r\n    [Symbol.iterator](): Iterator<ISeries<IndexT, ValueT>> {\r\n        return new SeriesVariableWindowIterator(this.iterable, this.comparer);\r\n    }\r\n}","//\r\n// Iterates an underlying iterable in the 'windows'.\r\n//\r\n\r\nimport { TakeIterable } from '../iterables/take-iterable';\r\nimport { SkipIterable } from '../iterables/skip-iterable';\r\nimport { Series, ISeries } from '../series';\r\n\r\n/**\r\n * Compares to values and returns true if they are equivalent.\r\n */\r\nexport type ComparerFn<ValueT> = (a: ValueT, b: ValueT) => boolean;\r\n\r\nexport class SeriesVariableWindowIterator<IndexT, ValueT> implements Iterator<ISeries<IndexT, ValueT>> {\r\n\r\n    iterator: Iterator<[IndexT, ValueT]>;\r\n    nextValue: IteratorResult<[IndexT, ValueT]>;\r\n    comparer: ComparerFn<ValueT>\r\n    \r\n    constructor(iterable: Iterable<[IndexT, ValueT]>, comparer: ComparerFn<ValueT>) {\r\n        this.iterator = iterable[Symbol.iterator]();\r\n        this.nextValue = this.iterator.next();\r\n        this.comparer = comparer;\r\n    }\r\n\r\n    next(): IteratorResult<ISeries<IndexT, ValueT>> {\r\n\r\n        if (this.nextValue.done) {\r\n            // Nothing more to read.\r\n            // https://github.com/Microsoft/TypeScript/issues/8938\r\n            return ({ done: true } as IteratorResult<ISeries<IndexT, ValueT>>)  // <= explicit cast here!;\r\n        }\r\n\r\n        const pairs = [\r\n            this.nextValue.value,\r\n        ];\r\n\r\n        let prevValue = this.nextValue.value;\r\n\r\n        // Pull values until there is one that doesn't compare.\r\n        while (true) {\r\n            this.nextValue = this.iterator.next();\r\n            if (this.nextValue.done) {\r\n                break; // No more values.\r\n            }\r\n\r\n            if (!this.comparer(prevValue[1], this.nextValue.value[1])) {\r\n                prevValue = this.nextValue.value;\r\n                break; // Doesn't compare. Start a new window.\r\n            }      \r\n            \r\n            pairs.push(this.nextValue.value);\r\n            prevValue = this.nextValue.value;\r\n        }\r\n\r\n        const window = new Series<IndexT, ValueT>({\r\n            pairs: pairs,\r\n        });\r\n\r\n        return {\r\n            value: window,\r\n            done: false,\r\n        };\r\n    }\r\n}","//\r\n// An iterator to extact an element from an array.\r\n//\r\n\r\nexport class ExtractElementIterator implements Iterator<any> {\r\n\r\n    iterator: Iterator<any[]>;\r\n    extractIndex: number;\r\n\r\n    constructor(iterator: Iterator<any[]>, extractIndex: number) {\r\n        this.iterator = iterator;\r\n        this.extractIndex = extractIndex;\r\n    }\r\n\r\n    next(): IteratorResult<any> {\r\n        \r\n        var result = this.iterator.next();\r\n        if (result.done) {\r\n            return result;\r\n        }\r\n        else {\r\n            return {\r\n                done: false,\r\n                value: result.value[this.extractIndex]\r\n            };\r\n        };\r\n    }\r\n}","//\r\n// An iterator that skips a number of values.\r\n//\r\n\r\nexport class SkipIterator implements Iterator<any> {\r\n\r\n    iterator: Iterator<any>;\r\n    numValues: number;\r\n\r\n    constructor(iterator: Iterator<any>, numValues: number) {\r\n        this.iterator = iterator;\r\n        this.numValues = numValues;\r\n    }\r\n\r\n    next(): IteratorResult<any> {\r\n        while (--this.numValues >= 0) {\r\n            var result = this.iterator.next();\r\n            if (result.done) {\r\n                return result;\r\n            }\r\n        }\r\n\r\n        return this.iterator.next();\r\n    }\r\n}","//\r\n// An iterator that skips a sequence of elements while a predicate function returns true.\r\n//\r\n\r\n/**\r\n * A predicate function, returns true or false based on input.\r\n */\r\nexport type PredicateFn<InputT> = (value: InputT) => boolean;\r\n\r\nexport class SkipWhileIterator<T> implements Iterator<T> {\r\n\r\n    childIterator: Iterator<T>;\r\n    predicate: PredicateFn<T>;\r\n    doneSkipping: boolean = false;\r\n\r\n    constructor(childIterator: Iterator<T>, predicate: PredicateFn<T>) {\r\n        this.childIterator = childIterator;\r\n        this.predicate = predicate;\r\n    }\r\n\r\n    next(): IteratorResult<T> {\r\n        while (true) {\r\n            var result = this.childIterator.next();\r\n            if (result.done) {\r\n                return result; // Done.\r\n            }\r\n\r\n            if (!this.doneSkipping && this.predicate(result.value)) {\r\n                continue; // Skip it.\r\n            }\r\n\r\n            // It matches, stop skipping.\r\n            this.doneSkipping = true;\r\n            return result;\r\n        }\r\n    }\r\n}","\"use strict\"\n\nvar defaults = require('defaults')\nvar combining = require('./combining')\n\nvar DEFAULTS = {\n  nul: 0,\n  control: 0\n}\n\nmodule.exports = function wcwidth(str) {\n  return wcswidth(str, DEFAULTS)\n}\n\nmodule.exports.config = function(opts) {\n  opts = defaults(opts || {}, DEFAULTS)\n  return function wcwidth(str) {\n    return wcswidth(str, opts)\n  }\n}\n\n/*\n *  The following functions define the column width of an ISO 10646\n *  character as follows:\n *  - The null character (U+0000) has a column width of 0.\n *  - Other C0/C1 control characters and DEL will lead to a return value\n *    of -1.\n *  - Non-spacing and enclosing combining characters (general category\n *    code Mn or Me in the\n *    Unicode database) have a column width of 0.\n *  - SOFT HYPHEN (U+00AD) has a column width of 1.\n *  - Other format characters (general category code Cf in the Unicode\n *    database) and ZERO WIDTH\n *    SPACE (U+200B) have a column width of 0.\n *  - Hangul Jamo medial vowels and final consonants (U+1160-U+11FF)\n *    have a column width of 0.\n *  - Spacing characters in the East Asian Wide (W) or East Asian\n *    Full-width (F) category as\n *    defined in Unicode Technical Report #11 have a column width of 2.\n *  - All remaining characters (including all printable ISO 8859-1 and\n *    WGL4 characters, Unicode control characters, etc.) have a column\n *    width of 1.\n *  This implementation assumes that characters are encoded in ISO 10646.\n*/\n\nfunction wcswidth(str, opts) {\n  if (typeof str !== 'string') return wcwidth(str, opts)\n\n  var s = 0\n  for (var i = 0; i < str.length; i++) {\n    var n = wcwidth(str.charCodeAt(i), opts)\n    if (n < 0) return -1\n    s += n\n  }\n\n  return s\n}\n\nfunction wcwidth(ucs, opts) {\n  // test for 8-bit control characters\n  if (ucs === 0) return opts.nul\n  if (ucs < 32 || (ucs >= 0x7f && ucs < 0xa0)) return opts.control\n\n  // binary search in table of non-spacing characters\n  if (bisearch(ucs)) return 0\n\n  // if we arrive here, ucs is not a combining or C0/C1 control character\n  return 1 +\n      (ucs >= 0x1100 &&\n       (ucs <= 0x115f ||                       // Hangul Jamo init. consonants\n        ucs == 0x2329 || ucs == 0x232a ||\n        (ucs >= 0x2e80 && ucs <= 0xa4cf &&\n         ucs != 0x303f) ||                     // CJK ... Yi\n        (ucs >= 0xac00 && ucs <= 0xd7a3) ||    // Hangul Syllables\n        (ucs >= 0xf900 && ucs <= 0xfaff) ||    // CJK Compatibility Ideographs\n        (ucs >= 0xfe10 && ucs <= 0xfe19) ||    // Vertical forms\n        (ucs >= 0xfe30 && ucs <= 0xfe6f) ||    // CJK Compatibility Forms\n        (ucs >= 0xff00 && ucs <= 0xff60) ||    // Fullwidth Forms\n        (ucs >= 0xffe0 && ucs <= 0xffe6) ||\n        (ucs >= 0x20000 && ucs <= 0x2fffd) ||\n        (ucs >= 0x30000 && ucs <= 0x3fffd)));\n}\n\nfunction bisearch(ucs) {\n  var min = 0\n  var max = combining.length - 1\n  var mid\n\n  if (ucs < combining[0][0] || ucs > combining[max][1]) return false\n\n  while (max >= min) {\n    mid = Math.floor((min + max) / 2)\n    if (ucs > combining[mid][1]) min = mid + 1\n    else if (ucs < combining[mid][0]) max = mid - 1\n    else return true\n  }\n\n  return false\n}\n","var clone = require('clone');\n\nmodule.exports = function(options, defaults) {\n  options = options || {};\n\n  Object.keys(defaults).forEach(function(key) {\n    if (typeof options[key] === 'undefined') {\n      options[key] = clone(defaults[key]);\n    }\n  });\n\n  return options;\n};","var clone = (function() {\n'use strict';\n\n/**\n * Clones (copies) an Object using deep copying.\n *\n * This function supports circular references by default, but if you are certain\n * there are no circular references in your object, you can save some CPU time\n * by calling clone(obj, false).\n *\n * Caution: if `circular` is false and `parent` contains circular references,\n * your program may enter an infinite loop and crash.\n *\n * @param `parent` - the object to be cloned\n * @param `circular` - set to true if the object to be cloned may contain\n *    circular references. (optional - true by default)\n * @param `depth` - set to a number if the object is only to be cloned to\n *    a particular depth. (optional - defaults to Infinity)\n * @param `prototype` - sets the prototype to be used when cloning an object.\n *    (optional - defaults to parent prototype).\n*/\nfunction clone(parent, circular, depth, prototype) {\n  var filter;\n  if (typeof circular === 'object') {\n    depth = circular.depth;\n    prototype = circular.prototype;\n    filter = circular.filter;\n    circular = circular.circular\n  }\n  // maintain two arrays for circular references, where corresponding parents\n  // and children have the same index\n  var allParents = [];\n  var allChildren = [];\n\n  var useBuffer = typeof Buffer != 'undefined';\n\n  if (typeof circular == 'undefined')\n    circular = true;\n\n  if (typeof depth == 'undefined')\n    depth = Infinity;\n\n  // recurse this function so we don't reset allParents and allChildren\n  function _clone(parent, depth) {\n    // cloning null always returns null\n    if (parent === null)\n      return null;\n\n    if (depth == 0)\n      return parent;\n\n    var child;\n    var proto;\n    if (typeof parent != 'object') {\n      return parent;\n    }\n\n    if (clone.__isArray(parent)) {\n      child = [];\n    } else if (clone.__isRegExp(parent)) {\n      child = new RegExp(parent.source, __getRegExpFlags(parent));\n      if (parent.lastIndex) child.lastIndex = parent.lastIndex;\n    } else if (clone.__isDate(parent)) {\n      child = new Date(parent.getTime());\n    } else if (useBuffer && Buffer.isBuffer(parent)) {\n      if (Buffer.allocUnsafe) {\n        // Node.js >= 4.5.0\n        child = Buffer.allocUnsafe(parent.length);\n      } else {\n        // Older Node.js versions\n        child = new Buffer(parent.length);\n      }\n      parent.copy(child);\n      return child;\n    } else {\n      if (typeof prototype == 'undefined') {\n        proto = Object.getPrototypeOf(parent);\n        child = Object.create(proto);\n      }\n      else {\n        child = Object.create(prototype);\n        proto = prototype;\n      }\n    }\n\n    if (circular) {\n      var index = allParents.indexOf(parent);\n\n      if (index != -1) {\n        return allChildren[index];\n      }\n      allParents.push(parent);\n      allChildren.push(child);\n    }\n\n    for (var i in parent) {\n      var attrs;\n      if (proto) {\n        attrs = Object.getOwnPropertyDescriptor(proto, i);\n      }\n\n      if (attrs && attrs.set == null) {\n        continue;\n      }\n      child[i] = _clone(parent[i], depth - 1);\n    }\n\n    return child;\n  }\n\n  return _clone(parent, depth);\n}\n\n/**\n * Simple flat clone using prototype, accepts only objects, usefull for property\n * override on FLAT configuration object (no nested props).\n *\n * USE WITH CAUTION! This may not behave as you wish if you do not know how this\n * works.\n */\nclone.clonePrototype = function clonePrototype(parent) {\n  if (parent === null)\n    return null;\n\n  var c = function () {};\n  c.prototype = parent;\n  return new c();\n};\n\n// private utility functions\n\nfunction __objToStr(o) {\n  return Object.prototype.toString.call(o);\n};\nclone.__objToStr = __objToStr;\n\nfunction __isDate(o) {\n  return typeof o === 'object' && __objToStr(o) === '[object Date]';\n};\nclone.__isDate = __isDate;\n\nfunction __isArray(o) {\n  return typeof o === 'object' && __objToStr(o) === '[object Array]';\n};\nclone.__isArray = __isArray;\n\nfunction __isRegExp(o) {\n  return typeof o === 'object' && __objToStr(o) === '[object RegExp]';\n};\nclone.__isRegExp = __isRegExp;\n\nfunction __getRegExpFlags(re) {\n  var flags = '';\n  if (re.global) flags += 'g';\n  if (re.ignoreCase) flags += 'i';\n  if (re.multiline) flags += 'm';\n  return flags;\n};\nclone.__getRegExpFlags = __getRegExpFlags;\n\nreturn clone;\n})();\n\nif (typeof module === 'object' && module.exports) {\n  module.exports = clone;\n}\n","/*!\n * The buffer module from node.js, for the browser.\n *\n * @author   Feross Aboukhadijeh <feross@feross.org> <http://feross.org>\n * @license  MIT\n */\n/* eslint-disable no-proto */\n\n'use strict'\n\nvar base64 = require('base64-js')\nvar ieee754 = require('ieee754')\nvar isArray = require('isarray')\n\nexports.Buffer = Buffer\nexports.SlowBuffer = SlowBuffer\nexports.INSPECT_MAX_BYTES = 50\n\n/**\n * If `Buffer.TYPED_ARRAY_SUPPORT`:\n *   === true    Use Uint8Array implementation (fastest)\n *   === false   Use Object implementation (most compatible, even IE6)\n *\n * Browsers that support typed arrays are IE 10+, Firefox 4+, Chrome 7+, Safari 5.1+,\n * Opera 11.6+, iOS 4.2+.\n *\n * Due to various browser bugs, sometimes the Object implementation will be used even\n * when the browser supports typed arrays.\n *\n * Note:\n *\n *   - Firefox 4-29 lacks support for adding new properties to `Uint8Array` instances,\n *     See: https://bugzilla.mozilla.org/show_bug.cgi?id=695438.\n *\n *   - Chrome 9-10 is missing the `TypedArray.prototype.subarray` function.\n *\n *   - IE10 has a broken `TypedArray.prototype.subarray` function which returns arrays of\n *     incorrect length in some situations.\n\n * We detect these buggy browsers and set `Buffer.TYPED_ARRAY_SUPPORT` to `false` so they\n * get the Object implementation, which is slower but behaves correctly.\n */\nBuffer.TYPED_ARRAY_SUPPORT = global.TYPED_ARRAY_SUPPORT !== undefined\n  ? global.TYPED_ARRAY_SUPPORT\n  : typedArraySupport()\n\n/*\n * Export kMaxLength after typed array support is determined.\n */\nexports.kMaxLength = kMaxLength()\n\nfunction typedArraySupport () {\n  try {\n    var arr = new Uint8Array(1)\n    arr.__proto__ = {__proto__: Uint8Array.prototype, foo: function () { return 42 }}\n    return arr.foo() === 42 && // typed array instances can be augmented\n        typeof arr.subarray === 'function' && // chrome 9-10 lack `subarray`\n        arr.subarray(1, 1).byteLength === 0 // ie10 has broken `subarray`\n  } catch (e) {\n    return false\n  }\n}\n\nfunction kMaxLength () {\n  return Buffer.TYPED_ARRAY_SUPPORT\n    ? 0x7fffffff\n    : 0x3fffffff\n}\n\nfunction createBuffer (that, length) {\n  if (kMaxLength() < length) {\n    throw new RangeError('Invalid typed array length')\n  }\n  if (Buffer.TYPED_ARRAY_SUPPORT) {\n    // Return an augmented `Uint8Array` instance, for best performance\n    that = new Uint8Array(length)\n    that.__proto__ = Buffer.prototype\n  } else {\n    // Fallback: Return an object instance of the Buffer class\n    if (that === null) {\n      that = new Buffer(length)\n    }\n    that.length = length\n  }\n\n  return that\n}\n\n/**\n * The Buffer constructor returns instances of `Uint8Array` that have their\n * prototype changed to `Buffer.prototype`. Furthermore, `Buffer` is a subclass of\n * `Uint8Array`, so the returned instances will have all the node `Buffer` methods\n * and the `Uint8Array` methods. Square bracket notation works as expected -- it\n * returns a single octet.\n *\n * The `Uint8Array` prototype remains unmodified.\n */\n\nfunction Buffer (arg, encodingOrOffset, length) {\n  if (!Buffer.TYPED_ARRAY_SUPPORT && !(this instanceof Buffer)) {\n    return new Buffer(arg, encodingOrOffset, length)\n  }\n\n  // Common case.\n  if (typeof arg === 'number') {\n    if (typeof encodingOrOffset === 'string') {\n      throw new Error(\n        'If encoding is specified then the first argument must be a string'\n      )\n    }\n    return allocUnsafe(this, arg)\n  }\n  return from(this, arg, encodingOrOffset, length)\n}\n\nBuffer.poolSize = 8192 // not used by this implementation\n\n// TODO: Legacy, not needed anymore. Remove in next major version.\nBuffer._augment = function (arr) {\n  arr.__proto__ = Buffer.prototype\n  return arr\n}\n\nfunction from (that, value, encodingOrOffset, length) {\n  if (typeof value === 'number') {\n    throw new TypeError('\"value\" argument must not be a number')\n  }\n\n  if (typeof ArrayBuffer !== 'undefined' && value instanceof ArrayBuffer) {\n    return fromArrayBuffer(that, value, encodingOrOffset, length)\n  }\n\n  if (typeof value === 'string') {\n    return fromString(that, value, encodingOrOffset)\n  }\n\n  return fromObject(that, value)\n}\n\n/**\n * Functionally equivalent to Buffer(arg, encoding) but throws a TypeError\n * if value is a number.\n * Buffer.from(str[, encoding])\n * Buffer.from(array)\n * Buffer.from(buffer)\n * Buffer.from(arrayBuffer[, byteOffset[, length]])\n **/\nBuffer.from = function (value, encodingOrOffset, length) {\n  return from(null, value, encodingOrOffset, length)\n}\n\nif (Buffer.TYPED_ARRAY_SUPPORT) {\n  Buffer.prototype.__proto__ = Uint8Array.prototype\n  Buffer.__proto__ = Uint8Array\n  if (typeof Symbol !== 'undefined' && Symbol.species &&\n      Buffer[Symbol.species] === Buffer) {\n    // Fix subarray() in ES2016. See: https://github.com/feross/buffer/pull/97\n    Object.defineProperty(Buffer, Symbol.species, {\n      value: null,\n      configurable: true\n    })\n  }\n}\n\nfunction assertSize (size) {\n  if (typeof size !== 'number') {\n    throw new TypeError('\"size\" argument must be a number')\n  } else if (size < 0) {\n    throw new RangeError('\"size\" argument must not be negative')\n  }\n}\n\nfunction alloc (that, size, fill, encoding) {\n  assertSize(size)\n  if (size <= 0) {\n    return createBuffer(that, size)\n  }\n  if (fill !== undefined) {\n    // Only pay attention to encoding if it's a string. This\n    // prevents accidentally sending in a number that would\n    // be interpretted as a start offset.\n    return typeof encoding === 'string'\n      ? createBuffer(that, size).fill(fill, encoding)\n      : createBuffer(that, size).fill(fill)\n  }\n  return createBuffer(that, size)\n}\n\n/**\n * Creates a new filled Buffer instance.\n * alloc(size[, fill[, encoding]])\n **/\nBuffer.alloc = function (size, fill, encoding) {\n  return alloc(null, size, fill, encoding)\n}\n\nfunction allocUnsafe (that, size) {\n  assertSize(size)\n  that = createBuffer(that, size < 0 ? 0 : checked(size) | 0)\n  if (!Buffer.TYPED_ARRAY_SUPPORT) {\n    for (var i = 0; i < size; ++i) {\n      that[i] = 0\n    }\n  }\n  return that\n}\n\n/**\n * Equivalent to Buffer(num), by default creates a non-zero-filled Buffer instance.\n * */\nBuffer.allocUnsafe = function (size) {\n  return allocUnsafe(null, size)\n}\n/**\n * Equivalent to SlowBuffer(num), by default creates a non-zero-filled Buffer instance.\n */\nBuffer.allocUnsafeSlow = function (size) {\n  return allocUnsafe(null, size)\n}\n\nfunction fromString (that, string, encoding) {\n  if (typeof encoding !== 'string' || encoding === '') {\n    encoding = 'utf8'\n  }\n\n  if (!Buffer.isEncoding(encoding)) {\n    throw new TypeError('\"encoding\" must be a valid string encoding')\n  }\n\n  var length = byteLength(string, encoding) | 0\n  that = createBuffer(that, length)\n\n  var actual = that.write(string, encoding)\n\n  if (actual !== length) {\n    // Writing a hex string, for example, that contains invalid characters will\n    // cause everything after the first invalid character to be ignored. (e.g.\n    // 'abxxcd' will be treated as 'ab')\n    that = that.slice(0, actual)\n  }\n\n  return that\n}\n\nfunction fromArrayLike (that, array) {\n  var length = array.length < 0 ? 0 : checked(array.length) | 0\n  that = createBuffer(that, length)\n  for (var i = 0; i < length; i += 1) {\n    that[i] = array[i] & 255\n  }\n  return that\n}\n\nfunction fromArrayBuffer (that, array, byteOffset, length) {\n  array.byteLength // this throws if `array` is not a valid ArrayBuffer\n\n  if (byteOffset < 0 || array.byteLength < byteOffset) {\n    throw new RangeError('\\'offset\\' is out of bounds')\n  }\n\n  if (array.byteLength < byteOffset + (length || 0)) {\n    throw new RangeError('\\'length\\' is out of bounds')\n  }\n\n  if (byteOffset === undefined && length === undefined) {\n    array = new Uint8Array(array)\n  } else if (length === undefined) {\n    array = new Uint8Array(array, byteOffset)\n  } else {\n    array = new Uint8Array(array, byteOffset, length)\n  }\n\n  if (Buffer.TYPED_ARRAY_SUPPORT) {\n    // Return an augmented `Uint8Array` instance, for best performance\n    that = array\n    that.__proto__ = Buffer.prototype\n  } else {\n    // Fallback: Return an object instance of the Buffer class\n    that = fromArrayLike(that, array)\n  }\n  return that\n}\n\nfunction fromObject (that, obj) {\n  if (Buffer.isBuffer(obj)) {\n    var len = checked(obj.length) | 0\n    that = createBuffer(that, len)\n\n    if (that.length === 0) {\n      return that\n    }\n\n    obj.copy(that, 0, 0, len)\n    return that\n  }\n\n  if (obj) {\n    if ((typeof ArrayBuffer !== 'undefined' &&\n        obj.buffer instanceof ArrayBuffer) || 'length' in obj) {\n      if (typeof obj.length !== 'number' || isnan(obj.length)) {\n        return createBuffer(that, 0)\n      }\n      return fromArrayLike(that, obj)\n    }\n\n    if (obj.type === 'Buffer' && isArray(obj.data)) {\n      return fromArrayLike(that, obj.data)\n    }\n  }\n\n  throw new TypeError('First argument must be a string, Buffer, ArrayBuffer, Array, or array-like object.')\n}\n\nfunction checked (length) {\n  // Note: cannot use `length < kMaxLength()` here because that fails when\n  // length is NaN (which is otherwise coerced to zero.)\n  if (length >= kMaxLength()) {\n    throw new RangeError('Attempt to allocate Buffer larger than maximum ' +\n                         'size: 0x' + kMaxLength().toString(16) + ' bytes')\n  }\n  return length | 0\n}\n\nfunction SlowBuffer (length) {\n  if (+length != length) { // eslint-disable-line eqeqeq\n    length = 0\n  }\n  return Buffer.alloc(+length)\n}\n\nBuffer.isBuffer = function isBuffer (b) {\n  return !!(b != null && b._isBuffer)\n}\n\nBuffer.compare = function compare (a, b) {\n  if (!Buffer.isBuffer(a) || !Buffer.isBuffer(b)) {\n    throw new TypeError('Arguments must be Buffers')\n  }\n\n  if (a === b) return 0\n\n  var x = a.length\n  var y = b.length\n\n  for (var i = 0, len = Math.min(x, y); i < len; ++i) {\n    if (a[i] !== b[i]) {\n      x = a[i]\n      y = b[i]\n      break\n    }\n  }\n\n  if (x < y) return -1\n  if (y < x) return 1\n  return 0\n}\n\nBuffer.isEncoding = function isEncoding (encoding) {\n  switch (String(encoding).toLowerCase()) {\n    case 'hex':\n    case 'utf8':\n    case 'utf-8':\n    case 'ascii':\n    case 'latin1':\n    case 'binary':\n    case 'base64':\n    case 'ucs2':\n    case 'ucs-2':\n    case 'utf16le':\n    case 'utf-16le':\n      return true\n    default:\n      return false\n  }\n}\n\nBuffer.concat = function concat (list, length) {\n  if (!isArray(list)) {\n    throw new TypeError('\"list\" argument must be an Array of Buffers')\n  }\n\n  if (list.length === 0) {\n    return Buffer.alloc(0)\n  }\n\n  var i\n  if (length === undefined) {\n    length = 0\n    for (i = 0; i < list.length; ++i) {\n      length += list[i].length\n    }\n  }\n\n  var buffer = Buffer.allocUnsafe(length)\n  var pos = 0\n  for (i = 0; i < list.length; ++i) {\n    var buf = list[i]\n    if (!Buffer.isBuffer(buf)) {\n      throw new TypeError('\"list\" argument must be an Array of Buffers')\n    }\n    buf.copy(buffer, pos)\n    pos += buf.length\n  }\n  return buffer\n}\n\nfunction byteLength (string, encoding) {\n  if (Buffer.isBuffer(string)) {\n    return string.length\n  }\n  if (typeof ArrayBuffer !== 'undefined' && typeof ArrayBuffer.isView === 'function' &&\n      (ArrayBuffer.isView(string) || string instanceof ArrayBuffer)) {\n    return string.byteLength\n  }\n  if (typeof string !== 'string') {\n    string = '' + string\n  }\n\n  var len = string.length\n  if (len === 0) return 0\n\n  // Use a for loop to avoid recursion\n  var loweredCase = false\n  for (;;) {\n    switch (encoding) {\n      case 'ascii':\n      case 'latin1':\n      case 'binary':\n        return len\n      case 'utf8':\n      case 'utf-8':\n      case undefined:\n        return utf8ToBytes(string).length\n      case 'ucs2':\n      case 'ucs-2':\n      case 'utf16le':\n      case 'utf-16le':\n        return len * 2\n      case 'hex':\n        return len >>> 1\n      case 'base64':\n        return base64ToBytes(string).length\n      default:\n        if (loweredCase) return utf8ToBytes(string).length // assume utf8\n        encoding = ('' + encoding).toLowerCase()\n        loweredCase = true\n    }\n  }\n}\nBuffer.byteLength = byteLength\n\nfunction slowToString (encoding, start, end) {\n  var loweredCase = false\n\n  // No need to verify that \"this.length <= MAX_UINT32\" since it's a read-only\n  // property of a typed array.\n\n  // This behaves neither like String nor Uint8Array in that we set start/end\n  // to their upper/lower bounds if the value passed is out of range.\n  // undefined is handled specially as per ECMA-262 6th Edition,\n  // Section 13.3.3.7 Runtime Semantics: KeyedBindingInitialization.\n  if (start === undefined || start < 0) {\n    start = 0\n  }\n  // Return early if start > this.length. Done here to prevent potential uint32\n  // coercion fail below.\n  if (start > this.length) {\n    return ''\n  }\n\n  if (end === undefined || end > this.length) {\n    end = this.length\n  }\n\n  if (end <= 0) {\n    return ''\n  }\n\n  // Force coersion to uint32. This will also coerce falsey/NaN values to 0.\n  end >>>= 0\n  start >>>= 0\n\n  if (end <= start) {\n    return ''\n  }\n\n  if (!encoding) encoding = 'utf8'\n\n  while (true) {\n    switch (encoding) {\n      case 'hex':\n        return hexSlice(this, start, end)\n\n      case 'utf8':\n      case 'utf-8':\n        return utf8Slice(this, start, end)\n\n      case 'ascii':\n        return asciiSlice(this, start, end)\n\n      case 'latin1':\n      case 'binary':\n        return latin1Slice(this, start, end)\n\n      case 'base64':\n        return base64Slice(this, start, end)\n\n      case 'ucs2':\n      case 'ucs-2':\n      case 'utf16le':\n      case 'utf-16le':\n        return utf16leSlice(this, start, end)\n\n      default:\n        if (loweredCase) throw new TypeError('Unknown encoding: ' + encoding)\n        encoding = (encoding + '').toLowerCase()\n        loweredCase = true\n    }\n  }\n}\n\n// The property is used by `Buffer.isBuffer` and `is-buffer` (in Safari 5-7) to detect\n// Buffer instances.\nBuffer.prototype._isBuffer = true\n\nfunction swap (b, n, m) {\n  var i = b[n]\n  b[n] = b[m]\n  b[m] = i\n}\n\nBuffer.prototype.swap16 = function swap16 () {\n  var len = this.length\n  if (len % 2 !== 0) {\n    throw new RangeError('Buffer size must be a multiple of 16-bits')\n  }\n  for (var i = 0; i < len; i += 2) {\n    swap(this, i, i + 1)\n  }\n  return this\n}\n\nBuffer.prototype.swap32 = function swap32 () {\n  var len = this.length\n  if (len % 4 !== 0) {\n    throw new RangeError('Buffer size must be a multiple of 32-bits')\n  }\n  for (var i = 0; i < len; i += 4) {\n    swap(this, i, i + 3)\n    swap(this, i + 1, i + 2)\n  }\n  return this\n}\n\nBuffer.prototype.swap64 = function swap64 () {\n  var len = this.length\n  if (len % 8 !== 0) {\n    throw new RangeError('Buffer size must be a multiple of 64-bits')\n  }\n  for (var i = 0; i < len; i += 8) {\n    swap(this, i, i + 7)\n    swap(this, i + 1, i + 6)\n    swap(this, i + 2, i + 5)\n    swap(this, i + 3, i + 4)\n  }\n  return this\n}\n\nBuffer.prototype.toString = function toString () {\n  var length = this.length | 0\n  if (length === 0) return ''\n  if (arguments.length === 0) return utf8Slice(this, 0, length)\n  return slowToString.apply(this, arguments)\n}\n\nBuffer.prototype.equals = function equals (b) {\n  if (!Buffer.isBuffer(b)) throw new TypeError('Argument must be a Buffer')\n  if (this === b) return true\n  return Buffer.compare(this, b) === 0\n}\n\nBuffer.prototype.inspect = function inspect () {\n  var str = ''\n  var max = exports.INSPECT_MAX_BYTES\n  if (this.length > 0) {\n    str = this.toString('hex', 0, max).match(/.{2}/g).join(' ')\n    if (this.length > max) str += ' ... '\n  }\n  return '<Buffer ' + str + '>'\n}\n\nBuffer.prototype.compare = function compare (target, start, end, thisStart, thisEnd) {\n  if (!Buffer.isBuffer(target)) {\n    throw new TypeError('Argument must be a Buffer')\n  }\n\n  if (start === undefined) {\n    start = 0\n  }\n  if (end === undefined) {\n    end = target ? target.length : 0\n  }\n  if (thisStart === undefined) {\n    thisStart = 0\n  }\n  if (thisEnd === undefined) {\n    thisEnd = this.length\n  }\n\n  if (start < 0 || end > target.length || thisStart < 0 || thisEnd > this.length) {\n    throw new RangeError('out of range index')\n  }\n\n  if (thisStart >= thisEnd && start >= end) {\n    return 0\n  }\n  if (thisStart >= thisEnd) {\n    return -1\n  }\n  if (start >= end) {\n    return 1\n  }\n\n  start >>>= 0\n  end >>>= 0\n  thisStart >>>= 0\n  thisEnd >>>= 0\n\n  if (this === target) return 0\n\n  var x = thisEnd - thisStart\n  var y = end - start\n  var len = Math.min(x, y)\n\n  var thisCopy = this.slice(thisStart, thisEnd)\n  var targetCopy = target.slice(start, end)\n\n  for (var i = 0; i < len; ++i) {\n    if (thisCopy[i] !== targetCopy[i]) {\n      x = thisCopy[i]\n      y = targetCopy[i]\n      break\n    }\n  }\n\n  if (x < y) return -1\n  if (y < x) return 1\n  return 0\n}\n\n// Finds either the first index of `val` in `buffer` at offset >= `byteOffset`,\n// OR the last index of `val` in `buffer` at offset <= `byteOffset`.\n//\n// Arguments:\n// - buffer - a Buffer to search\n// - val - a string, Buffer, or number\n// - byteOffset - an index into `buffer`; will be clamped to an int32\n// - encoding - an optional encoding, relevant is val is a string\n// - dir - true for indexOf, false for lastIndexOf\nfunction bidirectionalIndexOf (buffer, val, byteOffset, encoding, dir) {\n  // Empty buffer means no match\n  if (buffer.length === 0) return -1\n\n  // Normalize byteOffset\n  if (typeof byteOffset === 'string') {\n    encoding = byteOffset\n    byteOffset = 0\n  } else if (byteOffset > 0x7fffffff) {\n    byteOffset = 0x7fffffff\n  } else if (byteOffset < -0x80000000) {\n    byteOffset = -0x80000000\n  }\n  byteOffset = +byteOffset  // Coerce to Number.\n  if (isNaN(byteOffset)) {\n    // byteOffset: it it's undefined, null, NaN, \"foo\", etc, search whole buffer\n    byteOffset = dir ? 0 : (buffer.length - 1)\n  }\n\n  // Normalize byteOffset: negative offsets start from the end of the buffer\n  if (byteOffset < 0) byteOffset = buffer.length + byteOffset\n  if (byteOffset >= buffer.length) {\n    if (dir) return -1\n    else byteOffset = buffer.length - 1\n  } else if (byteOffset < 0) {\n    if (dir) byteOffset = 0\n    else return -1\n  }\n\n  // Normalize val\n  if (typeof val === 'string') {\n    val = Buffer.from(val, encoding)\n  }\n\n  // Finally, search either indexOf (if dir is true) or lastIndexOf\n  if (Buffer.isBuffer(val)) {\n    // Special case: looking for empty string/buffer always fails\n    if (val.length === 0) {\n      return -1\n    }\n    return arrayIndexOf(buffer, val, byteOffset, encoding, dir)\n  } else if (typeof val === 'number') {\n    val = val & 0xFF // Search for a byte value [0-255]\n    if (Buffer.TYPED_ARRAY_SUPPORT &&\n        typeof Uint8Array.prototype.indexOf === 'function') {\n      if (dir) {\n        return Uint8Array.prototype.indexOf.call(buffer, val, byteOffset)\n      } else {\n        return Uint8Array.prototype.lastIndexOf.call(buffer, val, byteOffset)\n      }\n    }\n    return arrayIndexOf(buffer, [ val ], byteOffset, encoding, dir)\n  }\n\n  throw new TypeError('val must be string, number or Buffer')\n}\n\nfunction arrayIndexOf (arr, val, byteOffset, encoding, dir) {\n  var indexSize = 1\n  var arrLength = arr.length\n  var valLength = val.length\n\n  if (encoding !== undefined) {\n    encoding = String(encoding).toLowerCase()\n    if (encoding === 'ucs2' || encoding === 'ucs-2' ||\n        encoding === 'utf16le' || encoding === 'utf-16le') {\n      if (arr.length < 2 || val.length < 2) {\n        return -1\n      }\n      indexSize = 2\n      arrLength /= 2\n      valLength /= 2\n      byteOffset /= 2\n    }\n  }\n\n  function read (buf, i) {\n    if (indexSize === 1) {\n      return buf[i]\n    } else {\n      return buf.readUInt16BE(i * indexSize)\n    }\n  }\n\n  var i\n  if (dir) {\n    var foundIndex = -1\n    for (i = byteOffset; i < arrLength; i++) {\n      if (read(arr, i) === read(val, foundIndex === -1 ? 0 : i - foundIndex)) {\n        if (foundIndex === -1) foundIndex = i\n        if (i - foundIndex + 1 === valLength) return foundIndex * indexSize\n      } else {\n        if (foundIndex !== -1) i -= i - foundIndex\n        foundIndex = -1\n      }\n    }\n  } else {\n    if (byteOffset + valLength > arrLength) byteOffset = arrLength - valLength\n    for (i = byteOffset; i >= 0; i--) {\n      var found = true\n      for (var j = 0; j < valLength; j++) {\n        if (read(arr, i + j) !== read(val, j)) {\n          found = false\n          break\n        }\n      }\n      if (found) return i\n    }\n  }\n\n  return -1\n}\n\nBuffer.prototype.includes = function includes (val, byteOffset, encoding) {\n  return this.indexOf(val, byteOffset, encoding) !== -1\n}\n\nBuffer.prototype.indexOf = function indexOf (val, byteOffset, encoding) {\n  return bidirectionalIndexOf(this, val, byteOffset, encoding, true)\n}\n\nBuffer.prototype.lastIndexOf = function lastIndexOf (val, byteOffset, encoding) {\n  return bidirectionalIndexOf(this, val, byteOffset, encoding, false)\n}\n\nfunction hexWrite (buf, string, offset, length) {\n  offset = Number(offset) || 0\n  var remaining = buf.length - offset\n  if (!length) {\n    length = remaining\n  } else {\n    length = Number(length)\n    if (length > remaining) {\n      length = remaining\n    }\n  }\n\n  // must be an even number of digits\n  var strLen = string.length\n  if (strLen % 2 !== 0) throw new TypeError('Invalid hex string')\n\n  if (length > strLen / 2) {\n    length = strLen / 2\n  }\n  for (var i = 0; i < length; ++i) {\n    var parsed = parseInt(string.substr(i * 2, 2), 16)\n    if (isNaN(parsed)) return i\n    buf[offset + i] = parsed\n  }\n  return i\n}\n\nfunction utf8Write (buf, string, offset, length) {\n  return blitBuffer(utf8ToBytes(string, buf.length - offset), buf, offset, length)\n}\n\nfunction asciiWrite (buf, string, offset, length) {\n  return blitBuffer(asciiToBytes(string), buf, offset, length)\n}\n\nfunction latin1Write (buf, string, offset, length) {\n  return asciiWrite(buf, string, offset, length)\n}\n\nfunction base64Write (buf, string, offset, length) {\n  return blitBuffer(base64ToBytes(string), buf, offset, length)\n}\n\nfunction ucs2Write (buf, string, offset, length) {\n  return blitBuffer(utf16leToBytes(string, buf.length - offset), buf, offset, length)\n}\n\nBuffer.prototype.write = function write (string, offset, length, encoding) {\n  // Buffer#write(string)\n  if (offset === undefined) {\n    encoding = 'utf8'\n    length = this.length\n    offset = 0\n  // Buffer#write(string, encoding)\n  } else if (length === undefined && typeof offset === 'string') {\n    encoding = offset\n    length = this.length\n    offset = 0\n  // Buffer#write(string, offset[, length][, encoding])\n  } else if (isFinite(offset)) {\n    offset = offset | 0\n    if (isFinite(length)) {\n      length = length | 0\n      if (encoding === undefined) encoding = 'utf8'\n    } else {\n      encoding = length\n      length = undefined\n    }\n  // legacy write(string, encoding, offset, length) - remove in v0.13\n  } else {\n    throw new Error(\n      'Buffer.write(string, encoding, offset[, length]) is no longer supported'\n    )\n  }\n\n  var remaining = this.length - offset\n  if (length === undefined || length > remaining) length = remaining\n\n  if ((string.length > 0 && (length < 0 || offset < 0)) || offset > this.length) {\n    throw new RangeError('Attempt to write outside buffer bounds')\n  }\n\n  if (!encoding) encoding = 'utf8'\n\n  var loweredCase = false\n  for (;;) {\n    switch (encoding) {\n      case 'hex':\n        return hexWrite(this, string, offset, length)\n\n      case 'utf8':\n      case 'utf-8':\n        return utf8Write(this, string, offset, length)\n\n      case 'ascii':\n        return asciiWrite(this, string, offset, length)\n\n      case 'latin1':\n      case 'binary':\n        return latin1Write(this, string, offset, length)\n\n      case 'base64':\n        // Warning: maxLength not taken into account in base64Write\n        return base64Write(this, string, offset, length)\n\n      case 'ucs2':\n      case 'ucs-2':\n      case 'utf16le':\n      case 'utf-16le':\n        return ucs2Write(this, string, offset, length)\n\n      default:\n        if (loweredCase) throw new TypeError('Unknown encoding: ' + encoding)\n        encoding = ('' + encoding).toLowerCase()\n        loweredCase = true\n    }\n  }\n}\n\nBuffer.prototype.toJSON = function toJSON () {\n  return {\n    type: 'Buffer',\n    data: Array.prototype.slice.call(this._arr || this, 0)\n  }\n}\n\nfunction base64Slice (buf, start, end) {\n  if (start === 0 && end === buf.length) {\n    return base64.fromByteArray(buf)\n  } else {\n    return base64.fromByteArray(buf.slice(start, end))\n  }\n}\n\nfunction utf8Slice (buf, start, end) {\n  end = Math.min(buf.length, end)\n  var res = []\n\n  var i = start\n  while (i < end) {\n    var firstByte = buf[i]\n    var codePoint = null\n    var bytesPerSequence = (firstByte > 0xEF) ? 4\n      : (firstByte > 0xDF) ? 3\n      : (firstByte > 0xBF) ? 2\n      : 1\n\n    if (i + bytesPerSequence <= end) {\n      var secondByte, thirdByte, fourthByte, tempCodePoint\n\n      switch (bytesPerSequence) {\n        case 1:\n          if (firstByte < 0x80) {\n            codePoint = firstByte\n          }\n          break\n        case 2:\n          secondByte = buf[i + 1]\n          if ((secondByte & 0xC0) === 0x80) {\n            tempCodePoint = (firstByte & 0x1F) << 0x6 | (secondByte & 0x3F)\n            if (tempCodePoint > 0x7F) {\n              codePoint = tempCodePoint\n            }\n          }\n          break\n        case 3:\n          secondByte = buf[i + 1]\n          thirdByte = buf[i + 2]\n          if ((secondByte & 0xC0) === 0x80 && (thirdByte & 0xC0) === 0x80) {\n            tempCodePoint = (firstByte & 0xF) << 0xC | (secondByte & 0x3F) << 0x6 | (thirdByte & 0x3F)\n            if (tempCodePoint > 0x7FF && (tempCodePoint < 0xD800 || tempCodePoint > 0xDFFF)) {\n              codePoint = tempCodePoint\n            }\n          }\n          break\n        case 4:\n          secondByte = buf[i + 1]\n          thirdByte = buf[i + 2]\n          fourthByte = buf[i + 3]\n          if ((secondByte & 0xC0) === 0x80 && (thirdByte & 0xC0) === 0x80 && (fourthByte & 0xC0) === 0x80) {\n            tempCodePoint = (firstByte & 0xF) << 0x12 | (secondByte & 0x3F) << 0xC | (thirdByte & 0x3F) << 0x6 | (fourthByte & 0x3F)\n            if (tempCodePoint > 0xFFFF && tempCodePoint < 0x110000) {\n              codePoint = tempCodePoint\n            }\n          }\n      }\n    }\n\n    if (codePoint === null) {\n      // we did not generate a valid codePoint so insert a\n      // replacement char (U+FFFD) and advance only 1 byte\n      codePoint = 0xFFFD\n      bytesPerSequence = 1\n    } else if (codePoint > 0xFFFF) {\n      // encode to utf16 (surrogate pair dance)\n      codePoint -= 0x10000\n      res.push(codePoint >>> 10 & 0x3FF | 0xD800)\n      codePoint = 0xDC00 | codePoint & 0x3FF\n    }\n\n    res.push(codePoint)\n    i += bytesPerSequence\n  }\n\n  return decodeCodePointsArray(res)\n}\n\n// Based on http://stackoverflow.com/a/22747272/680742, the browser with\n// the lowest limit is Chrome, with 0x10000 args.\n// We go 1 magnitude less, for safety\nvar MAX_ARGUMENTS_LENGTH = 0x1000\n\nfunction decodeCodePointsArray (codePoints) {\n  var len = codePoints.length\n  if (len <= MAX_ARGUMENTS_LENGTH) {\n    return String.fromCharCode.apply(String, codePoints) // avoid extra slice()\n  }\n\n  // Decode in chunks to avoid \"call stack size exceeded\".\n  var res = ''\n  var i = 0\n  while (i < len) {\n    res += String.fromCharCode.apply(\n      String,\n      codePoints.slice(i, i += MAX_ARGUMENTS_LENGTH)\n    )\n  }\n  return res\n}\n\nfunction asciiSlice (buf, start, end) {\n  var ret = ''\n  end = Math.min(buf.length, end)\n\n  for (var i = start; i < end; ++i) {\n    ret += String.fromCharCode(buf[i] & 0x7F)\n  }\n  return ret\n}\n\nfunction latin1Slice (buf, start, end) {\n  var ret = ''\n  end = Math.min(buf.length, end)\n\n  for (var i = start; i < end; ++i) {\n    ret += String.fromCharCode(buf[i])\n  }\n  return ret\n}\n\nfunction hexSlice (buf, start, end) {\n  var len = buf.length\n\n  if (!start || start < 0) start = 0\n  if (!end || end < 0 || end > len) end = len\n\n  var out = ''\n  for (var i = start; i < end; ++i) {\n    out += toHex(buf[i])\n  }\n  return out\n}\n\nfunction utf16leSlice (buf, start, end) {\n  var bytes = buf.slice(start, end)\n  var res = ''\n  for (var i = 0; i < bytes.length; i += 2) {\n    res += String.fromCharCode(bytes[i] + bytes[i + 1] * 256)\n  }\n  return res\n}\n\nBuffer.prototype.slice = function slice (start, end) {\n  var len = this.length\n  start = ~~start\n  end = end === undefined ? len : ~~end\n\n  if (start < 0) {\n    start += len\n    if (start < 0) start = 0\n  } else if (start > len) {\n    start = len\n  }\n\n  if (end < 0) {\n    end += len\n    if (end < 0) end = 0\n  } else if (end > len) {\n    end = len\n  }\n\n  if (end < start) end = start\n\n  var newBuf\n  if (Buffer.TYPED_ARRAY_SUPPORT) {\n    newBuf = this.subarray(start, end)\n    newBuf.__proto__ = Buffer.prototype\n  } else {\n    var sliceLen = end - start\n    newBuf = new Buffer(sliceLen, undefined)\n    for (var i = 0; i < sliceLen; ++i) {\n      newBuf[i] = this[i + start]\n    }\n  }\n\n  return newBuf\n}\n\n/*\n * Need to make sure that buffer isn't trying to write out of bounds.\n */\nfunction checkOffset (offset, ext, length) {\n  if ((offset % 1) !== 0 || offset < 0) throw new RangeError('offset is not uint')\n  if (offset + ext > length) throw new RangeError('Trying to access beyond buffer length')\n}\n\nBuffer.prototype.readUIntLE = function readUIntLE (offset, byteLength, noAssert) {\n  offset = offset | 0\n  byteLength = byteLength | 0\n  if (!noAssert) checkOffset(offset, byteLength, this.length)\n\n  var val = this[offset]\n  var mul = 1\n  var i = 0\n  while (++i < byteLength && (mul *= 0x100)) {\n    val += this[offset + i] * mul\n  }\n\n  return val\n}\n\nBuffer.prototype.readUIntBE = function readUIntBE (offset, byteLength, noAssert) {\n  offset = offset | 0\n  byteLength = byteLength | 0\n  if (!noAssert) {\n    checkOffset(offset, byteLength, this.length)\n  }\n\n  var val = this[offset + --byteLength]\n  var mul = 1\n  while (byteLength > 0 && (mul *= 0x100)) {\n    val += this[offset + --byteLength] * mul\n  }\n\n  return val\n}\n\nBuffer.prototype.readUInt8 = function readUInt8 (offset, noAssert) {\n  if (!noAssert) checkOffset(offset, 1, this.length)\n  return this[offset]\n}\n\nBuffer.prototype.readUInt16LE = function readUInt16LE (offset, noAssert) {\n  if (!noAssert) checkOffset(offset, 2, this.length)\n  return this[offset] | (this[offset + 1] << 8)\n}\n\nBuffer.prototype.readUInt16BE = function readUInt16BE (offset, noAssert) {\n  if (!noAssert) checkOffset(offset, 2, this.length)\n  return (this[offset] << 8) | this[offset + 1]\n}\n\nBuffer.prototype.readUInt32LE = function readUInt32LE (offset, noAssert) {\n  if (!noAssert) checkOffset(offset, 4, this.length)\n\n  return ((this[offset]) |\n      (this[offset + 1] << 8) |\n      (this[offset + 2] << 16)) +\n      (this[offset + 3] * 0x1000000)\n}\n\nBuffer.prototype.readUInt32BE = function readUInt32BE (offset, noAssert) {\n  if (!noAssert) checkOffset(offset, 4, this.length)\n\n  return (this[offset] * 0x1000000) +\n    ((this[offset + 1] << 16) |\n    (this[offset + 2] << 8) |\n    this[offset + 3])\n}\n\nBuffer.prototype.readIntLE = function readIntLE (offset, byteLength, noAssert) {\n  offset = offset | 0\n  byteLength = byteLength | 0\n  if (!noAssert) checkOffset(offset, byteLength, this.length)\n\n  var val = this[offset]\n  var mul = 1\n  var i = 0\n  while (++i < byteLength && (mul *= 0x100)) {\n    val += this[offset + i] * mul\n  }\n  mul *= 0x80\n\n  if (val >= mul) val -= Math.pow(2, 8 * byteLength)\n\n  return val\n}\n\nBuffer.prototype.readIntBE = function readIntBE (offset, byteLength, noAssert) {\n  offset = offset | 0\n  byteLength = byteLength | 0\n  if (!noAssert) checkOffset(offset, byteLength, this.length)\n\n  var i = byteLength\n  var mul = 1\n  var val = this[offset + --i]\n  while (i > 0 && (mul *= 0x100)) {\n    val += this[offset + --i] * mul\n  }\n  mul *= 0x80\n\n  if (val >= mul) val -= Math.pow(2, 8 * byteLength)\n\n  return val\n}\n\nBuffer.prototype.readInt8 = function readInt8 (offset, noAssert) {\n  if (!noAssert) checkOffset(offset, 1, this.length)\n  if (!(this[offset] & 0x80)) return (this[offset])\n  return ((0xff - this[offset] + 1) * -1)\n}\n\nBuffer.prototype.readInt16LE = function readInt16LE (offset, noAssert) {\n  if (!noAssert) checkOffset(offset, 2, this.length)\n  var val = this[offset] | (this[offset + 1] << 8)\n  return (val & 0x8000) ? val | 0xFFFF0000 : val\n}\n\nBuffer.prototype.readInt16BE = function readInt16BE (offset, noAssert) {\n  if (!noAssert) checkOffset(offset, 2, this.length)\n  var val = this[offset + 1] | (this[offset] << 8)\n  return (val & 0x8000) ? val | 0xFFFF0000 : val\n}\n\nBuffer.prototype.readInt32LE = function readInt32LE (offset, noAssert) {\n  if (!noAssert) checkOffset(offset, 4, this.length)\n\n  return (this[offset]) |\n    (this[offset + 1] << 8) |\n    (this[offset + 2] << 16) |\n    (this[offset + 3] << 24)\n}\n\nBuffer.prototype.readInt32BE = function readInt32BE (offset, noAssert) {\n  if (!noAssert) checkOffset(offset, 4, this.length)\n\n  return (this[offset] << 24) |\n    (this[offset + 1] << 16) |\n    (this[offset + 2] << 8) |\n    (this[offset + 3])\n}\n\nBuffer.prototype.readFloatLE = function readFloatLE (offset, noAssert) {\n  if (!noAssert) checkOffset(offset, 4, this.length)\n  return ieee754.read(this, offset, true, 23, 4)\n}\n\nBuffer.prototype.readFloatBE = function readFloatBE (offset, noAssert) {\n  if (!noAssert) checkOffset(offset, 4, this.length)\n  return ieee754.read(this, offset, false, 23, 4)\n}\n\nBuffer.prototype.readDoubleLE = function readDoubleLE (offset, noAssert) {\n  if (!noAssert) checkOffset(offset, 8, this.length)\n  return ieee754.read(this, offset, true, 52, 8)\n}\n\nBuffer.prototype.readDoubleBE = function readDoubleBE (offset, noAssert) {\n  if (!noAssert) checkOffset(offset, 8, this.length)\n  return ieee754.read(this, offset, false, 52, 8)\n}\n\nfunction checkInt (buf, value, offset, ext, max, min) {\n  if (!Buffer.isBuffer(buf)) throw new TypeError('\"buffer\" argument must be a Buffer instance')\n  if (value > max || value < min) throw new RangeError('\"value\" argument is out of bounds')\n  if (offset + ext > buf.length) throw new RangeError('Index out of range')\n}\n\nBuffer.prototype.writeUIntLE = function writeUIntLE (value, offset, byteLength, noAssert) {\n  value = +value\n  offset = offset | 0\n  byteLength = byteLength | 0\n  if (!noAssert) {\n    var maxBytes = Math.pow(2, 8 * byteLength) - 1\n    checkInt(this, value, offset, byteLength, maxBytes, 0)\n  }\n\n  var mul = 1\n  var i = 0\n  this[offset] = value & 0xFF\n  while (++i < byteLength && (mul *= 0x100)) {\n    this[offset + i] = (value / mul) & 0xFF\n  }\n\n  return offset + byteLength\n}\n\nBuffer.prototype.writeUIntBE = function writeUIntBE (value, offset, byteLength, noAssert) {\n  value = +value\n  offset = offset | 0\n  byteLength = byteLength | 0\n  if (!noAssert) {\n    var maxBytes = Math.pow(2, 8 * byteLength) - 1\n    checkInt(this, value, offset, byteLength, maxBytes, 0)\n  }\n\n  var i = byteLength - 1\n  var mul = 1\n  this[offset + i] = value & 0xFF\n  while (--i >= 0 && (mul *= 0x100)) {\n    this[offset + i] = (value / mul) & 0xFF\n  }\n\n  return offset + byteLength\n}\n\nBuffer.prototype.writeUInt8 = function writeUInt8 (value, offset, noAssert) {\n  value = +value\n  offset = offset | 0\n  if (!noAssert) checkInt(this, value, offset, 1, 0xff, 0)\n  if (!Buffer.TYPED_ARRAY_SUPPORT) value = Math.floor(value)\n  this[offset] = (value & 0xff)\n  return offset + 1\n}\n\nfunction objectWriteUInt16 (buf, value, offset, littleEndian) {\n  if (value < 0) value = 0xffff + value + 1\n  for (var i = 0, j = Math.min(buf.length - offset, 2); i < j; ++i) {\n    buf[offset + i] = (value & (0xff << (8 * (littleEndian ? i : 1 - i)))) >>>\n      (littleEndian ? i : 1 - i) * 8\n  }\n}\n\nBuffer.prototype.writeUInt16LE = function writeUInt16LE (value, offset, noAssert) {\n  value = +value\n  offset = offset | 0\n  if (!noAssert) checkInt(this, value, offset, 2, 0xffff, 0)\n  if (Buffer.TYPED_ARRAY_SUPPORT) {\n    this[offset] = (value & 0xff)\n    this[offset + 1] = (value >>> 8)\n  } else {\n    objectWriteUInt16(this, value, offset, true)\n  }\n  return offset + 2\n}\n\nBuffer.prototype.writeUInt16BE = function writeUInt16BE (value, offset, noAssert) {\n  value = +value\n  offset = offset | 0\n  if (!noAssert) checkInt(this, value, offset, 2, 0xffff, 0)\n  if (Buffer.TYPED_ARRAY_SUPPORT) {\n    this[offset] = (value >>> 8)\n    this[offset + 1] = (value & 0xff)\n  } else {\n    objectWriteUInt16(this, value, offset, false)\n  }\n  return offset + 2\n}\n\nfunction objectWriteUInt32 (buf, value, offset, littleEndian) {\n  if (value < 0) value = 0xffffffff + value + 1\n  for (var i = 0, j = Math.min(buf.length - offset, 4); i < j; ++i) {\n    buf[offset + i] = (value >>> (littleEndian ? i : 3 - i) * 8) & 0xff\n  }\n}\n\nBuffer.prototype.writeUInt32LE = function writeUInt32LE (value, offset, noAssert) {\n  value = +value\n  offset = offset | 0\n  if (!noAssert) checkInt(this, value, offset, 4, 0xffffffff, 0)\n  if (Buffer.TYPED_ARRAY_SUPPORT) {\n    this[offset + 3] = (value >>> 24)\n    this[offset + 2] = (value >>> 16)\n    this[offset + 1] = (value >>> 8)\n    this[offset] = (value & 0xff)\n  } else {\n    objectWriteUInt32(this, value, offset, true)\n  }\n  return offset + 4\n}\n\nBuffer.prototype.writeUInt32BE = function writeUInt32BE (value, offset, noAssert) {\n  value = +value\n  offset = offset | 0\n  if (!noAssert) checkInt(this, value, offset, 4, 0xffffffff, 0)\n  if (Buffer.TYPED_ARRAY_SUPPORT) {\n    this[offset] = (value >>> 24)\n    this[offset + 1] = (value >>> 16)\n    this[offset + 2] = (value >>> 8)\n    this[offset + 3] = (value & 0xff)\n  } else {\n    objectWriteUInt32(this, value, offset, false)\n  }\n  return offset + 4\n}\n\nBuffer.prototype.writeIntLE = function writeIntLE (value, offset, byteLength, noAssert) {\n  value = +value\n  offset = offset | 0\n  if (!noAssert) {\n    var limit = Math.pow(2, 8 * byteLength - 1)\n\n    checkInt(this, value, offset, byteLength, limit - 1, -limit)\n  }\n\n  var i = 0\n  var mul = 1\n  var sub = 0\n  this[offset] = value & 0xFF\n  while (++i < byteLength && (mul *= 0x100)) {\n    if (value < 0 && sub === 0 && this[offset + i - 1] !== 0) {\n      sub = 1\n    }\n    this[offset + i] = ((value / mul) >> 0) - sub & 0xFF\n  }\n\n  return offset + byteLength\n}\n\nBuffer.prototype.writeIntBE = function writeIntBE (value, offset, byteLength, noAssert) {\n  value = +value\n  offset = offset | 0\n  if (!noAssert) {\n    var limit = Math.pow(2, 8 * byteLength - 1)\n\n    checkInt(this, value, offset, byteLength, limit - 1, -limit)\n  }\n\n  var i = byteLength - 1\n  var mul = 1\n  var sub = 0\n  this[offset + i] = value & 0xFF\n  while (--i >= 0 && (mul *= 0x100)) {\n    if (value < 0 && sub === 0 && this[offset + i + 1] !== 0) {\n      sub = 1\n    }\n    this[offset + i] = ((value / mul) >> 0) - sub & 0xFF\n  }\n\n  return offset + byteLength\n}\n\nBuffer.prototype.writeInt8 = function writeInt8 (value, offset, noAssert) {\n  value = +value\n  offset = offset | 0\n  if (!noAssert) checkInt(this, value, offset, 1, 0x7f, -0x80)\n  if (!Buffer.TYPED_ARRAY_SUPPORT) value = Math.floor(value)\n  if (value < 0) value = 0xff + value + 1\n  this[offset] = (value & 0xff)\n  return offset + 1\n}\n\nBuffer.prototype.writeInt16LE = function writeInt16LE (value, offset, noAssert) {\n  value = +value\n  offset = offset | 0\n  if (!noAssert) checkInt(this, value, offset, 2, 0x7fff, -0x8000)\n  if (Buffer.TYPED_ARRAY_SUPPORT) {\n    this[offset] = (value & 0xff)\n    this[offset + 1] = (value >>> 8)\n  } else {\n    objectWriteUInt16(this, value, offset, true)\n  }\n  return offset + 2\n}\n\nBuffer.prototype.writeInt16BE = function writeInt16BE (value, offset, noAssert) {\n  value = +value\n  offset = offset | 0\n  if (!noAssert) checkInt(this, value, offset, 2, 0x7fff, -0x8000)\n  if (Buffer.TYPED_ARRAY_SUPPORT) {\n    this[offset] = (value >>> 8)\n    this[offset + 1] = (value & 0xff)\n  } else {\n    objectWriteUInt16(this, value, offset, false)\n  }\n  return offset + 2\n}\n\nBuffer.prototype.writeInt32LE = function writeInt32LE (value, offset, noAssert) {\n  value = +value\n  offset = offset | 0\n  if (!noAssert) checkInt(this, value, offset, 4, 0x7fffffff, -0x80000000)\n  if (Buffer.TYPED_ARRAY_SUPPORT) {\n    this[offset] = (value & 0xff)\n    this[offset + 1] = (value >>> 8)\n    this[offset + 2] = (value >>> 16)\n    this[offset + 3] = (value >>> 24)\n  } else {\n    objectWriteUInt32(this, value, offset, true)\n  }\n  return offset + 4\n}\n\nBuffer.prototype.writeInt32BE = function writeInt32BE (value, offset, noAssert) {\n  value = +value\n  offset = offset | 0\n  if (!noAssert) checkInt(this, value, offset, 4, 0x7fffffff, -0x80000000)\n  if (value < 0) value = 0xffffffff + value + 1\n  if (Buffer.TYPED_ARRAY_SUPPORT) {\n    this[offset] = (value >>> 24)\n    this[offset + 1] = (value >>> 16)\n    this[offset + 2] = (value >>> 8)\n    this[offset + 3] = (value & 0xff)\n  } else {\n    objectWriteUInt32(this, value, offset, false)\n  }\n  return offset + 4\n}\n\nfunction checkIEEE754 (buf, value, offset, ext, max, min) {\n  if (offset + ext > buf.length) throw new RangeError('Index out of range')\n  if (offset < 0) throw new RangeError('Index out of range')\n}\n\nfunction writeFloat (buf, value, offset, littleEndian, noAssert) {\n  if (!noAssert) {\n    checkIEEE754(buf, value, offset, 4, 3.4028234663852886e+38, -3.4028234663852886e+38)\n  }\n  ieee754.write(buf, value, offset, littleEndian, 23, 4)\n  return offset + 4\n}\n\nBuffer.prototype.writeFloatLE = function writeFloatLE (value, offset, noAssert) {\n  return writeFloat(this, value, offset, true, noAssert)\n}\n\nBuffer.prototype.writeFloatBE = function writeFloatBE (value, offset, noAssert) {\n  return writeFloat(this, value, offset, false, noAssert)\n}\n\nfunction writeDouble (buf, value, offset, littleEndian, noAssert) {\n  if (!noAssert) {\n    checkIEEE754(buf, value, offset, 8, 1.7976931348623157E+308, -1.7976931348623157E+308)\n  }\n  ieee754.write(buf, value, offset, littleEndian, 52, 8)\n  return offset + 8\n}\n\nBuffer.prototype.writeDoubleLE = function writeDoubleLE (value, offset, noAssert) {\n  return writeDouble(this, value, offset, true, noAssert)\n}\n\nBuffer.prototype.writeDoubleBE = function writeDoubleBE (value, offset, noAssert) {\n  return writeDouble(this, value, offset, false, noAssert)\n}\n\n// copy(targetBuffer, targetStart=0, sourceStart=0, sourceEnd=buffer.length)\nBuffer.prototype.copy = function copy (target, targetStart, start, end) {\n  if (!start) start = 0\n  if (!end && end !== 0) end = this.length\n  if (targetStart >= target.length) targetStart = target.length\n  if (!targetStart) targetStart = 0\n  if (end > 0 && end < start) end = start\n\n  // Copy 0 bytes; we're done\n  if (end === start) return 0\n  if (target.length === 0 || this.length === 0) return 0\n\n  // Fatal error conditions\n  if (targetStart < 0) {\n    throw new RangeError('targetStart out of bounds')\n  }\n  if (start < 0 || start >= this.length) throw new RangeError('sourceStart out of bounds')\n  if (end < 0) throw new RangeError('sourceEnd out of bounds')\n\n  // Are we oob?\n  if (end > this.length) end = this.length\n  if (target.length - targetStart < end - start) {\n    end = target.length - targetStart + start\n  }\n\n  var len = end - start\n  var i\n\n  if (this === target && start < targetStart && targetStart < end) {\n    // descending copy from end\n    for (i = len - 1; i >= 0; --i) {\n      target[i + targetStart] = this[i + start]\n    }\n  } else if (len < 1000 || !Buffer.TYPED_ARRAY_SUPPORT) {\n    // ascending copy from start\n    for (i = 0; i < len; ++i) {\n      target[i + targetStart] = this[i + start]\n    }\n  } else {\n    Uint8Array.prototype.set.call(\n      target,\n      this.subarray(start, start + len),\n      targetStart\n    )\n  }\n\n  return len\n}\n\n// Usage:\n//    buffer.fill(number[, offset[, end]])\n//    buffer.fill(buffer[, offset[, end]])\n//    buffer.fill(string[, offset[, end]][, encoding])\nBuffer.prototype.fill = function fill (val, start, end, encoding) {\n  // Handle string cases:\n  if (typeof val === 'string') {\n    if (typeof start === 'string') {\n      encoding = start\n      start = 0\n      end = this.length\n    } else if (typeof end === 'string') {\n      encoding = end\n      end = this.length\n    }\n    if (val.length === 1) {\n      var code = val.charCodeAt(0)\n      if (code < 256) {\n        val = code\n      }\n    }\n    if (encoding !== undefined && typeof encoding !== 'string') {\n      throw new TypeError('encoding must be a string')\n    }\n    if (typeof encoding === 'string' && !Buffer.isEncoding(encoding)) {\n      throw new TypeError('Unknown encoding: ' + encoding)\n    }\n  } else if (typeof val === 'number') {\n    val = val & 255\n  }\n\n  // Invalid ranges are not set to a default, so can range check early.\n  if (start < 0 || this.length < start || this.length < end) {\n    throw new RangeError('Out of range index')\n  }\n\n  if (end <= start) {\n    return this\n  }\n\n  start = start >>> 0\n  end = end === undefined ? this.length : end >>> 0\n\n  if (!val) val = 0\n\n  var i\n  if (typeof val === 'number') {\n    for (i = start; i < end; ++i) {\n      this[i] = val\n    }\n  } else {\n    var bytes = Buffer.isBuffer(val)\n      ? val\n      : utf8ToBytes(new Buffer(val, encoding).toString())\n    var len = bytes.length\n    for (i = 0; i < end - start; ++i) {\n      this[i + start] = bytes[i % len]\n    }\n  }\n\n  return this\n}\n\n// HELPER FUNCTIONS\n// ================\n\nvar INVALID_BASE64_RE = /[^+\\/0-9A-Za-z-_]/g\n\nfunction base64clean (str) {\n  // Node strips out invalid characters like \\n and \\t from the string, base64-js does not\n  str = stringtrim(str).replace(INVALID_BASE64_RE, '')\n  // Node converts strings with length < 2 to ''\n  if (str.length < 2) return ''\n  // Node allows for non-padded base64 strings (missing trailing ===), base64-js does not\n  while (str.length % 4 !== 0) {\n    str = str + '='\n  }\n  return str\n}\n\nfunction stringtrim (str) {\n  if (str.trim) return str.trim()\n  return str.replace(/^\\s+|\\s+$/g, '')\n}\n\nfunction toHex (n) {\n  if (n < 16) return '0' + n.toString(16)\n  return n.toString(16)\n}\n\nfunction utf8ToBytes (string, units) {\n  units = units || Infinity\n  var codePoint\n  var length = string.length\n  var leadSurrogate = null\n  var bytes = []\n\n  for (var i = 0; i < length; ++i) {\n    codePoint = string.charCodeAt(i)\n\n    // is surrogate component\n    if (codePoint > 0xD7FF && codePoint < 0xE000) {\n      // last char was a lead\n      if (!leadSurrogate) {\n        // no lead yet\n        if (codePoint > 0xDBFF) {\n          // unexpected trail\n          if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)\n          continue\n        } else if (i + 1 === length) {\n          // unpaired lead\n          if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)\n          continue\n        }\n\n        // valid lead\n        leadSurrogate = codePoint\n\n        continue\n      }\n\n      // 2 leads in a row\n      if (codePoint < 0xDC00) {\n        if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)\n        leadSurrogate = codePoint\n        continue\n      }\n\n      // valid surrogate pair\n      codePoint = (leadSurrogate - 0xD800 << 10 | codePoint - 0xDC00) + 0x10000\n    } else if (leadSurrogate) {\n      // valid bmp char, but last char was a lead\n      if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)\n    }\n\n    leadSurrogate = null\n\n    // encode utf8\n    if (codePoint < 0x80) {\n      if ((units -= 1) < 0) break\n      bytes.push(codePoint)\n    } else if (codePoint < 0x800) {\n      if ((units -= 2) < 0) break\n      bytes.push(\n        codePoint >> 0x6 | 0xC0,\n        codePoint & 0x3F | 0x80\n      )\n    } else if (codePoint < 0x10000) {\n      if ((units -= 3) < 0) break\n      bytes.push(\n        codePoint >> 0xC | 0xE0,\n        codePoint >> 0x6 & 0x3F | 0x80,\n        codePoint & 0x3F | 0x80\n      )\n    } else if (codePoint < 0x110000) {\n      if ((units -= 4) < 0) break\n      bytes.push(\n        codePoint >> 0x12 | 0xF0,\n        codePoint >> 0xC & 0x3F | 0x80,\n        codePoint >> 0x6 & 0x3F | 0x80,\n        codePoint & 0x3F | 0x80\n      )\n    } else {\n      throw new Error('Invalid code point')\n    }\n  }\n\n  return bytes\n}\n\nfunction asciiToBytes (str) {\n  var byteArray = []\n  for (var i = 0; i < str.length; ++i) {\n    // Node's code seems to be doing this and not & 0x7F..\n    byteArray.push(str.charCodeAt(i) & 0xFF)\n  }\n  return byteArray\n}\n\nfunction utf16leToBytes (str, units) {\n  var c, hi, lo\n  var byteArray = []\n  for (var i = 0; i < str.length; ++i) {\n    if ((units -= 2) < 0) break\n\n    c = str.charCodeAt(i)\n    hi = c >> 8\n    lo = c % 256\n    byteArray.push(lo)\n    byteArray.push(hi)\n  }\n\n  return byteArray\n}\n\nfunction base64ToBytes (str) {\n  return base64.toByteArray(base64clean(str))\n}\n\nfunction blitBuffer (src, dst, offset, length) {\n  for (var i = 0; i < length; ++i) {\n    if ((i + offset >= dst.length) || (i >= src.length)) break\n    dst[i + offset] = src[i]\n  }\n  return i\n}\n\nfunction isnan (val) {\n  return val !== val // eslint-disable-line no-self-compare\n}\n","var g;\n\n// This works in non-strict mode\ng = (function() {\n\treturn this;\n})();\n\ntry {\n\t// This works if eval is allowed (see CSP)\n\tg = g || new Function(\"return this\")();\n} catch (e) {\n\t// This works if the window reference is available\n\tif (typeof window === \"object\") g = window;\n}\n\n// g can still be undefined, but nothing to do about it...\n// We return undefined, instead of nothing here, so it's\n// easier to handle this case. if(!global) { ...}\n\nmodule.exports = g;\n","'use strict'\n\nexports.byteLength = byteLength\nexports.toByteArray = toByteArray\nexports.fromByteArray = fromByteArray\n\nvar lookup = []\nvar revLookup = []\nvar Arr = typeof Uint8Array !== 'undefined' ? Uint8Array : Array\n\nvar code = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/'\nfor (var i = 0, len = code.length; i < len; ++i) {\n  lookup[i] = code[i]\n  revLookup[code.charCodeAt(i)] = i\n}\n\n// Support decoding URL-safe base64 strings, as Node.js does.\n// See: https://en.wikipedia.org/wiki/Base64#URL_applications\nrevLookup['-'.charCodeAt(0)] = 62\nrevLookup['_'.charCodeAt(0)] = 63\n\nfunction getLens (b64) {\n  var len = b64.length\n\n  if (len % 4 > 0) {\n    throw new Error('Invalid string. Length must be a multiple of 4')\n  }\n\n  // Trim off extra bytes after placeholder bytes are found\n  // See: https://github.com/beatgammit/base64-js/issues/42\n  var validLen = b64.indexOf('=')\n  if (validLen === -1) validLen = len\n\n  var placeHoldersLen = validLen === len\n    ? 0\n    : 4 - (validLen % 4)\n\n  return [validLen, placeHoldersLen]\n}\n\n// base64 is 4/3 + up to two characters of the original data\nfunction byteLength (b64) {\n  var lens = getLens(b64)\n  var validLen = lens[0]\n  var placeHoldersLen = lens[1]\n  return ((validLen + placeHoldersLen) * 3 / 4) - placeHoldersLen\n}\n\nfunction _byteLength (b64, validLen, placeHoldersLen) {\n  return ((validLen + placeHoldersLen) * 3 / 4) - placeHoldersLen\n}\n\nfunction toByteArray (b64) {\n  var tmp\n  var lens = getLens(b64)\n  var validLen = lens[0]\n  var placeHoldersLen = lens[1]\n\n  var arr = new Arr(_byteLength(b64, validLen, placeHoldersLen))\n\n  var curByte = 0\n\n  // if there are placeholders, only get up to the last complete 4 chars\n  var len = placeHoldersLen > 0\n    ? validLen - 4\n    : validLen\n\n  for (var i = 0; i < len; i += 4) {\n    tmp =\n      (revLookup[b64.charCodeAt(i)] << 18) |\n      (revLookup[b64.charCodeAt(i + 1)] << 12) |\n      (revLookup[b64.charCodeAt(i + 2)] << 6) |\n      revLookup[b64.charCodeAt(i + 3)]\n    arr[curByte++] = (tmp >> 16) & 0xFF\n    arr[curByte++] = (tmp >> 8) & 0xFF\n    arr[curByte++] = tmp & 0xFF\n  }\n\n  if (placeHoldersLen === 2) {\n    tmp =\n      (revLookup[b64.charCodeAt(i)] << 2) |\n      (revLookup[b64.charCodeAt(i + 1)] >> 4)\n    arr[curByte++] = tmp & 0xFF\n  }\n\n  if (placeHoldersLen === 1) {\n    tmp =\n      (revLookup[b64.charCodeAt(i)] << 10) |\n      (revLookup[b64.charCodeAt(i + 1)] << 4) |\n      (revLookup[b64.charCodeAt(i + 2)] >> 2)\n    arr[curByte++] = (tmp >> 8) & 0xFF\n    arr[curByte++] = tmp & 0xFF\n  }\n\n  return arr\n}\n\nfunction tripletToBase64 (num) {\n  return lookup[num >> 18 & 0x3F] +\n    lookup[num >> 12 & 0x3F] +\n    lookup[num >> 6 & 0x3F] +\n    lookup[num & 0x3F]\n}\n\nfunction encodeChunk (uint8, start, end) {\n  var tmp\n  var output = []\n  for (var i = start; i < end; i += 3) {\n    tmp =\n      ((uint8[i] << 16) & 0xFF0000) +\n      ((uint8[i + 1] << 8) & 0xFF00) +\n      (uint8[i + 2] & 0xFF)\n    output.push(tripletToBase64(tmp))\n  }\n  return output.join('')\n}\n\nfunction fromByteArray (uint8) {\n  var tmp\n  var len = uint8.length\n  var extraBytes = len % 3 // if we have 1 byte left, pad 2 bytes\n  var parts = []\n  var maxChunkLength = 16383 // must be multiple of 3\n\n  // go through the array every three bytes, we'll deal with trailing stuff later\n  for (var i = 0, len2 = len - extraBytes; i < len2; i += maxChunkLength) {\n    parts.push(encodeChunk(\n      uint8, i, (i + maxChunkLength) > len2 ? len2 : (i + maxChunkLength)\n    ))\n  }\n\n  // pad the end with zeros, but make sure to not forget the extra bytes\n  if (extraBytes === 1) {\n    tmp = uint8[len - 1]\n    parts.push(\n      lookup[tmp >> 2] +\n      lookup[(tmp << 4) & 0x3F] +\n      '=='\n    )\n  } else if (extraBytes === 2) {\n    tmp = (uint8[len - 2] << 8) + uint8[len - 1]\n    parts.push(\n      lookup[tmp >> 10] +\n      lookup[(tmp >> 4) & 0x3F] +\n      lookup[(tmp << 2) & 0x3F] +\n      '='\n    )\n  }\n\n  return parts.join('')\n}\n","exports.read = function (buffer, offset, isLE, mLen, nBytes) {\n  var e, m\n  var eLen = (nBytes * 8) - mLen - 1\n  var eMax = (1 << eLen) - 1\n  var eBias = eMax >> 1\n  var nBits = -7\n  var i = isLE ? (nBytes - 1) : 0\n  var d = isLE ? -1 : 1\n  var s = buffer[offset + i]\n\n  i += d\n\n  e = s & ((1 << (-nBits)) - 1)\n  s >>= (-nBits)\n  nBits += eLen\n  for (; nBits > 0; e = (e * 256) + buffer[offset + i], i += d, nBits -= 8) {}\n\n  m = e & ((1 << (-nBits)) - 1)\n  e >>= (-nBits)\n  nBits += mLen\n  for (; nBits > 0; m = (m * 256) + buffer[offset + i], i += d, nBits -= 8) {}\n\n  if (e === 0) {\n    e = 1 - eBias\n  } else if (e === eMax) {\n    return m ? NaN : ((s ? -1 : 1) * Infinity)\n  } else {\n    m = m + Math.pow(2, mLen)\n    e = e - eBias\n  }\n  return (s ? -1 : 1) * m * Math.pow(2, e - mLen)\n}\n\nexports.write = function (buffer, value, offset, isLE, mLen, nBytes) {\n  var e, m, c\n  var eLen = (nBytes * 8) - mLen - 1\n  var eMax = (1 << eLen) - 1\n  var eBias = eMax >> 1\n  var rt = (mLen === 23 ? Math.pow(2, -24) - Math.pow(2, -77) : 0)\n  var i = isLE ? 0 : (nBytes - 1)\n  var d = isLE ? 1 : -1\n  var s = value < 0 || (value === 0 && 1 / value < 0) ? 1 : 0\n\n  value = Math.abs(value)\n\n  if (isNaN(value) || value === Infinity) {\n    m = isNaN(value) ? 1 : 0\n    e = eMax\n  } else {\n    e = Math.floor(Math.log(value) / Math.LN2)\n    if (value * (c = Math.pow(2, -e)) < 1) {\n      e--\n      c *= 2\n    }\n    if (e + eBias >= 1) {\n      value += rt / c\n    } else {\n      value += rt * Math.pow(2, 1 - eBias)\n    }\n    if (value * c >= 2) {\n      e++\n      c /= 2\n    }\n\n    if (e + eBias >= eMax) {\n      m = 0\n      e = eMax\n    } else if (e + eBias >= 1) {\n      m = ((value * c) - 1) * Math.pow(2, mLen)\n      e = e + eBias\n    } else {\n      m = value * Math.pow(2, eBias - 1) * Math.pow(2, mLen)\n      e = 0\n    }\n  }\n\n  for (; mLen >= 8; buffer[offset + i] = m & 0xff, i += d, m /= 256, mLen -= 8) {}\n\n  e = (e << mLen) | m\n  eLen += mLen\n  for (; eLen > 0; buffer[offset + i] = e & 0xff, i += d, e /= 256, eLen -= 8) {}\n\n  buffer[offset + i - d] |= s * 128\n}\n","var toString = {}.toString;\n\nmodule.exports = Array.isArray || function (arr) {\n  return toString.call(arr) == '[object Array]';\n};\n","module.exports = [\n    [ 0x0300, 0x036F ], [ 0x0483, 0x0486 ], [ 0x0488, 0x0489 ],\n    [ 0x0591, 0x05BD ], [ 0x05BF, 0x05BF ], [ 0x05C1, 0x05C2 ],\n    [ 0x05C4, 0x05C5 ], [ 0x05C7, 0x05C7 ], [ 0x0600, 0x0603 ],\n    [ 0x0610, 0x0615 ], [ 0x064B, 0x065E ], [ 0x0670, 0x0670 ],\n    [ 0x06D6, 0x06E4 ], [ 0x06E7, 0x06E8 ], [ 0x06EA, 0x06ED ],\n    [ 0x070F, 0x070F ], [ 0x0711, 0x0711 ], [ 0x0730, 0x074A ],\n    [ 0x07A6, 0x07B0 ], [ 0x07EB, 0x07F3 ], [ 0x0901, 0x0902 ],\n    [ 0x093C, 0x093C ], [ 0x0941, 0x0948 ], [ 0x094D, 0x094D ],\n    [ 0x0951, 0x0954 ], [ 0x0962, 0x0963 ], [ 0x0981, 0x0981 ],\n    [ 0x09BC, 0x09BC ], [ 0x09C1, 0x09C4 ], [ 0x09CD, 0x09CD ],\n    [ 0x09E2, 0x09E3 ], [ 0x0A01, 0x0A02 ], [ 0x0A3C, 0x0A3C ],\n    [ 0x0A41, 0x0A42 ], [ 0x0A47, 0x0A48 ], [ 0x0A4B, 0x0A4D ],\n    [ 0x0A70, 0x0A71 ], [ 0x0A81, 0x0A82 ], [ 0x0ABC, 0x0ABC ],\n    [ 0x0AC1, 0x0AC5 ], [ 0x0AC7, 0x0AC8 ], [ 0x0ACD, 0x0ACD ],\n    [ 0x0AE2, 0x0AE3 ], [ 0x0B01, 0x0B01 ], [ 0x0B3C, 0x0B3C ],\n    [ 0x0B3F, 0x0B3F ], [ 0x0B41, 0x0B43 ], [ 0x0B4D, 0x0B4D ],\n    [ 0x0B56, 0x0B56 ], [ 0x0B82, 0x0B82 ], [ 0x0BC0, 0x0BC0 ],\n    [ 0x0BCD, 0x0BCD ], [ 0x0C3E, 0x0C40 ], [ 0x0C46, 0x0C48 ],\n    [ 0x0C4A, 0x0C4D ], [ 0x0C55, 0x0C56 ], [ 0x0CBC, 0x0CBC ],\n    [ 0x0CBF, 0x0CBF ], [ 0x0CC6, 0x0CC6 ], [ 0x0CCC, 0x0CCD ],\n    [ 0x0CE2, 0x0CE3 ], [ 0x0D41, 0x0D43 ], [ 0x0D4D, 0x0D4D ],\n    [ 0x0DCA, 0x0DCA ], [ 0x0DD2, 0x0DD4 ], [ 0x0DD6, 0x0DD6 ],\n    [ 0x0E31, 0x0E31 ], [ 0x0E34, 0x0E3A ], [ 0x0E47, 0x0E4E ],\n    [ 0x0EB1, 0x0EB1 ], [ 0x0EB4, 0x0EB9 ], [ 0x0EBB, 0x0EBC ],\n    [ 0x0EC8, 0x0ECD ], [ 0x0F18, 0x0F19 ], [ 0x0F35, 0x0F35 ],\n    [ 0x0F37, 0x0F37 ], [ 0x0F39, 0x0F39 ], [ 0x0F71, 0x0F7E ],\n    [ 0x0F80, 0x0F84 ], [ 0x0F86, 0x0F87 ], [ 0x0F90, 0x0F97 ],\n    [ 0x0F99, 0x0FBC ], [ 0x0FC6, 0x0FC6 ], [ 0x102D, 0x1030 ],\n    [ 0x1032, 0x1032 ], [ 0x1036, 0x1037 ], [ 0x1039, 0x1039 ],\n    [ 0x1058, 0x1059 ], [ 0x1160, 0x11FF ], [ 0x135F, 0x135F ],\n    [ 0x1712, 0x1714 ], [ 0x1732, 0x1734 ], [ 0x1752, 0x1753 ],\n    [ 0x1772, 0x1773 ], [ 0x17B4, 0x17B5 ], [ 0x17B7, 0x17BD ],\n    [ 0x17C6, 0x17C6 ], [ 0x17C9, 0x17D3 ], [ 0x17DD, 0x17DD ],\n    [ 0x180B, 0x180D ], [ 0x18A9, 0x18A9 ], [ 0x1920, 0x1922 ],\n    [ 0x1927, 0x1928 ], [ 0x1932, 0x1932 ], [ 0x1939, 0x193B ],\n    [ 0x1A17, 0x1A18 ], [ 0x1B00, 0x1B03 ], [ 0x1B34, 0x1B34 ],\n    [ 0x1B36, 0x1B3A ], [ 0x1B3C, 0x1B3C ], [ 0x1B42, 0x1B42 ],\n    [ 0x1B6B, 0x1B73 ], [ 0x1DC0, 0x1DCA ], [ 0x1DFE, 0x1DFF ],\n    [ 0x200B, 0x200F ], [ 0x202A, 0x202E ], [ 0x2060, 0x2063 ],\n    [ 0x206A, 0x206F ], [ 0x20D0, 0x20EF ], [ 0x302A, 0x302F ],\n    [ 0x3099, 0x309A ], [ 0xA806, 0xA806 ], [ 0xA80B, 0xA80B ],\n    [ 0xA825, 0xA826 ], [ 0xFB1E, 0xFB1E ], [ 0xFE00, 0xFE0F ],\n    [ 0xFE20, 0xFE23 ], [ 0xFEFF, 0xFEFF ], [ 0xFFF9, 0xFFFB ],\n    [ 0x10A01, 0x10A03 ], [ 0x10A05, 0x10A06 ], [ 0x10A0C, 0x10A0F ],\n    [ 0x10A38, 0x10A3A ], [ 0x10A3F, 0x10A3F ], [ 0x1D167, 0x1D169 ],\n    [ 0x1D173, 0x1D182 ], [ 0x1D185, 0x1D18B ], [ 0x1D1AA, 0x1D1AD ],\n    [ 0x1D242, 0x1D244 ], [ 0xE0001, 0xE0001 ], [ 0xE0020, 0xE007F ],\n    [ 0xE0100, 0xE01EF ]\n]\n","//\r\n// Iterates an underlying iterable in the 'windows'.\r\n//\r\n\r\nimport { DataFrameWindowIterator } from '../iterators/dataframe-window-iterator';\r\nimport { IDataFrame } from '../dataframe';\r\n\r\nexport class DataFrameWindowIterable<IndexT, ValueT> implements Iterable<IDataFrame<IndexT, ValueT>> {\r\n\r\n    columnNames: Iterable<string>;\r\n    iterable: Iterable<[IndexT, ValueT]>;\r\n    period: number;\r\n\r\n    constructor(columnNames: Iterable<string>, iterable: Iterable<[IndexT, ValueT]>, period: number) {\r\n        this.columnNames = columnNames;\r\n        this.iterable = iterable;\r\n        this.period = period;\r\n    }\r\n\r\n    [Symbol.iterator](): Iterator<IDataFrame<IndexT, ValueT>> {\r\n        return new DataFrameWindowIterator(this.columnNames, this.iterable, this.period);\r\n    }\r\n}","//\r\n// Iterates an underlying iterable in the 'windows'.\r\n//\r\n\r\nimport { TakeIterable } from '../iterables/take-iterable';\r\nimport { SkipIterable } from '../iterables/skip-iterable';\r\nimport { DataFrame, IDataFrame } from '../dataframe';\r\n\r\nexport class DataFrameWindowIterator<IndexT, ValueT> implements Iterator<IDataFrame<IndexT, ValueT>> {\r\n\r\n    columnNames: Iterable<string>;\r\n    iterable: Iterable<[IndexT, ValueT]>;\r\n    iterator: Iterator<[IndexT, ValueT]> | undefined;\r\n    period: number;\r\n    \r\n    constructor(columnNames: Iterable<string>, iterable: Iterable<[IndexT, ValueT]>, period: number) {\r\n        this.columnNames = columnNames;\r\n        this.iterable = iterable;\r\n        this.period = period;\r\n    }\r\n\r\n    next(): IteratorResult<IDataFrame<IndexT, ValueT>> {\r\n\r\n        if (!this.iterator) {\r\n            this.iterator = this.iterable[Symbol.iterator]();\r\n        }\r\n        \r\n        const curWindow = [];\r\n\r\n        for (let i = 0; i < this.period; ++i) {\r\n            const curPos = this.iterator.next();\r\n            if (curPos.done) {\r\n                // Underlying iterator is finished.\r\n                break;\r\n            }\r\n            curWindow.push(curPos.value);\r\n        }\r\n\r\n        if (curWindow.length === 0) {\r\n            // Underlying iterator doesn't have required number of elements.\r\n            return ({ done: true } as IteratorResult<IDataFrame<IndexT, ValueT>>);\r\n        }\r\n    \r\n        const window = new DataFrame<IndexT, ValueT>({\r\n            columnNames: this.columnNames,\r\n            pairs: curWindow\r\n        });\r\n\r\n        return {\r\n            value: window,\r\n            done: false,\r\n        };\r\n    }\r\n}","//\r\n// An iterable that iterates the rows of a CSV file.\r\n//\r\n\r\nimport { CsvRowsIterator } from '../iterators/csv-rows-iterator';\r\n\r\nexport class CsvRowsIterable implements Iterable<any> {\r\n\r\n    columnNames: Iterable<string>;\r\n    rows: Iterable<any>;\r\n\r\n    constructor(columnNames: Iterable<string>, rows: Iterable<any>) {\r\n        this.columnNames = columnNames;\r\n        this.rows = rows;\r\n    }\r\n\r\n    [Symbol.iterator](): Iterator<any> {\r\n        return new CsvRowsIterator(this.columnNames, this.rows);\r\n    }\r\n}","//\r\n// An iterator that iterates the rows of a CSV file.\r\n//\r\n\r\nexport class CsvRowsIterator implements Iterator<any> {\r\n\r\n    columnNames: string[];\r\n    rowsIterator: Iterator<any>;\r\n    index: number = 0;\r\n\r\n    constructor(columnNames: Iterable<string>, rowsIterable: Iterable<any>) {\r\n        this.columnNames = Array.from(columnNames);\r\n        this.rowsIterator = rowsIterable[Symbol.iterator]();\r\n    }\r\n\r\n    next(): IteratorResult<any> {\r\n\r\n        var result = this.rowsIterator.next();\r\n        if (result.done) {\r\n            // https://github.com/Microsoft/TypeScript/issues/8938\r\n            return ({ done: true } as IteratorResult<any>)  // <= explicit cast here!;\r\n        }\r\n\r\n        var row = result.value;\r\n        var value: any = {};\r\n        for (var cellIndex = 0; cellIndex < this.columnNames.length; ++cellIndex) {\r\n            var columnName = this.columnNames[cellIndex];\r\n            value[columnName] = row[cellIndex];\r\n        }\r\n\r\n        return {\r\n            done: false, \r\n            value: value,\r\n        };\r\n   }\r\n}","//\r\n// Iterates an underlying iterable in the 'windows'.\r\n//\r\n\r\nimport { DataFrameRollingWindowIterator } from '../iterators/dataframe-rolling-window-iterator';\r\nimport { IDataFrame } from '../dataframe';\r\n\r\nexport class DataFrameRollingWindowIterable<IndexT, ValueT> implements Iterable<IDataFrame<IndexT, ValueT>> {\r\n\r\n    columnNames: Iterable<string>;\r\n    iterable: Iterable<[IndexT, ValueT]>;\r\n    period: number;\r\n\r\n    constructor(columnNames: Iterable<string>, iterable: Iterable<[IndexT, ValueT]>, period: number) {\r\n        this.columnNames = columnNames;\r\n        this.iterable = iterable;\r\n        this.period = period;\r\n    }\r\n\r\n    [Symbol.iterator](): Iterator<IDataFrame<IndexT, ValueT>> {\r\n        return new DataFrameRollingWindowIterator(this.columnNames, this.iterable, this.period);\r\n    }\r\n}","//\n// Iterates an underlying iterable in the 'windows'.\n//\n\nimport { TakeIterable } from '../iterables/take-iterable';\nimport { SkipIterable } from '../iterables/skip-iterable';\nimport { DataFrame, IDataFrame } from '../dataframe';\n\nexport class DataFrameRollingWindowIterator<IndexT, ValueT> implements Iterator<IDataFrame<IndexT, ValueT>> {\n\n    columnNames: Iterable<string>;\n    iterable: Iterable<[IndexT, ValueT]>;\n    iterator: Iterator<[IndexT, ValueT]> | undefined;\n    period: number;\n    curWindow: [IndexT, ValueT][] | undefined; \n    \n    constructor(columnNames: Iterable<string>, iterable: Iterable<[IndexT, ValueT]>, period: number) {\n        this.columnNames = columnNames;\n        this.iterable = iterable;\n        this.period = period;\n    }\n\n    next(): IteratorResult<IDataFrame<IndexT, ValueT>> {\n\n        if (!this.curWindow) {\n            this.curWindow = [];\n            this.iterator = this.iterable[Symbol.iterator]();\n            for (let i = 0; i < this.period; ++i) {\n                const curPos = this.iterator.next();\n                if (curPos.done) {\n                    // Underlying iterator doesn't have required number of elements.\n                    return ({ done: true } as IteratorResult<IDataFrame<IndexT, ValueT>>);\n                }\n                this.curWindow.push(curPos.value);\n            }\n        }\n        else {\n            this.curWindow.shift(); // Remove first item from window.\n            \n            const curPos = this.iterator!.next();\n            if (curPos.done) {\n                // Underlying iterator doesn't have enough elements left.\n                return ({ done: true } as IteratorResult<IDataFrame<IndexT, ValueT>>);\n            }\n\n            this.curWindow.push(curPos.value); // Add next item to window.\n        }\n\n        const window = new DataFrame<IndexT, ValueT>({\n            columnNames: this.columnNames,\n            pairs: this.curWindow\n        });\n\n        return {\n            value: window,\n            done: false,\n        };\n    }\n}","//\r\n// Iterates an underlying iterable in the 'windows'.\r\n//\r\n\r\nimport { DataFrameVariableWindowIterator, ComparerFn } from '../iterators/dataframe-variable-window-iterator';\r\nimport { IDataFrame } from '../dataframe';\r\n\r\nexport class DataFrameVariableWindowIterable<IndexT, ValueT> implements Iterable<IDataFrame<IndexT, ValueT>> {\r\n\r\n    columnNames: Iterable<string>;\r\n    iterable: Iterable<[IndexT, ValueT]>;\r\n    comparer: ComparerFn<ValueT>;\r\n\r\n    constructor(columnNames: Iterable<string>, iterable: Iterable<[IndexT, ValueT]>, comparer: ComparerFn<ValueT>) {\r\n        this.columnNames = columnNames;\r\n        this.iterable = iterable;\r\n        this.comparer = comparer;\r\n    }\r\n\r\n    [Symbol.iterator](): Iterator<IDataFrame<IndexT, ValueT>> {\r\n        return new DataFrameVariableWindowIterator(this.columnNames, this.iterable, this.comparer);\r\n    }\r\n}","//\r\n// Iterates an underlying iterable in the 'windows'.\r\n//\r\n\r\nimport { TakeIterable } from '../iterables/take-iterable';\r\nimport { SkipIterable } from '../iterables/skip-iterable';\r\nimport { DataFrame, IDataFrame } from '../dataframe';\r\n\r\n/**\r\n * Compares to values and returns true if they are equivalent.\r\n */\r\nexport type ComparerFn<ValueT> = (a: ValueT, b: ValueT) => boolean;\r\n\r\nexport class DataFrameVariableWindowIterator<IndexT, ValueT> implements Iterator<IDataFrame<IndexT, ValueT>> {\r\n\r\n    columnNames: Iterable<string>;\r\n    iterator: Iterator<[IndexT, ValueT]>;\r\n    nextValue: IteratorResult<[IndexT, ValueT]>;\r\n    comparer: ComparerFn<ValueT>\r\n    \r\n    constructor(columnNames: Iterable<string>, iterable: Iterable<[IndexT, ValueT]>, comparer: ComparerFn<ValueT>) {\r\n        this.columnNames = columnNames;\r\n        this.iterator = iterable[Symbol.iterator]();\r\n        this.nextValue = this.iterator.next();\r\n        this.comparer = comparer;\r\n    }\r\n\r\n    next(): IteratorResult<IDataFrame<IndexT, ValueT>> {\r\n\r\n        if (this.nextValue.done) {\r\n            // Nothing more to read.\r\n            // https://github.com/Microsoft/TypeScript/issues/8938\r\n            return ({ done: true } as IteratorResult<IDataFrame<IndexT, ValueT>>)  // <= explicit cast here!;\r\n        }\r\n\r\n        const pairs = [\r\n            this.nextValue.value,\r\n        ];\r\n\r\n        let prevValue = this.nextValue.value;\r\n\r\n        // Pull values until there is one that doesn't compare.\r\n        while (true) {\r\n            this.nextValue = this.iterator.next();\r\n            if (this.nextValue.done) {\r\n                break; // No more values.\r\n            }\r\n\r\n            if (!this.comparer(prevValue[1], this.nextValue.value[1])) {\r\n                prevValue = this.nextValue.value;   \r\n                break; // Doesn't compare. Start a new window.\r\n            }      \r\n            \r\n            pairs.push(this.nextValue.value);\r\n            prevValue = this.nextValue.value;\r\n        }\r\n\r\n        const window = new DataFrame<IndexT, ValueT>({\r\n            columnNames: this.columnNames,\r\n            pairs: pairs,\r\n        });\r\n\r\n        return {\r\n            value: window,\r\n            done: false,\r\n        };\r\n    }\r\n}","//\r\n// An iterable that iterates the column names of lazy dataframe.\r\n//\r\n\r\nimport { ColumnNamesIterator } from '../iterators/column-names-iterator';\r\n\r\nexport class ColumnNamesIterable implements Iterable<string> {\r\n\r\n    values: Iterable<any>;\r\n    considerAllRows: boolean;\r\n\r\n    constructor(values: Iterable<any>, considerAllRows: boolean) {\r\n        this.values = values;\r\n        this.considerAllRows = considerAllRows\r\n    }\r\n\r\n    [Symbol.iterator](): Iterator<string> {\r\n        return new ColumnNamesIterator(this.values, this.considerAllRows);\r\n    }\r\n}","//\r\n// An iterator for the column names of lazy dataframe.\r\n//\r\n\r\nimport { ArrayIterator } from './array-iterator';\r\n\r\nexport class ColumnNamesIterator implements Iterator<string> {\r\n\r\n    columnNamesIterator: Iterator<string> | null = null;\r\n    values: Iterable<any>;\r\n    considerAllRows: boolean;\r\n\r\n    constructor(values: Iterable<any>, considerAllRows: boolean) {\r\n        this.values = values;\r\n        this.considerAllRows = considerAllRows;\r\n    }\r\n\r\n    next(): IteratorResult<string> {\r\n        if (this.columnNamesIterator === null)  {\r\n            if (this.considerAllRows) {\r\n                var combinedFields: any = {};\r\n                \r\n                // Check all items.\r\n                for (let value of this.values) {\r\n                    for (let fieldName of Object.keys(value)) {\r\n                        combinedFields[fieldName] = true;\r\n                    }\r\n                }\r\n\r\n                this.columnNamesIterator = new ArrayIterator(Object.keys(combinedFields));\r\n            }\r\n            else {\r\n                // Just check the first item.\r\n                var valuesIterator = this.values[Symbol.iterator]();\r\n                var firstResult = valuesIterator.next();\r\n                if (firstResult.done) {\r\n                    return {\r\n                        done: true,\r\n                        value: \"\",\r\n                    };\r\n                }\r\n\r\n                this.columnNamesIterator = new ArrayIterator(Object.keys(firstResult.value));\r\n            }\r\n        }\r\n\r\n        return this.columnNamesIterator.next();\r\n    }\r\n\r\n}","'use strict';Object.defineProperty(exports,'__esModule',{value:!0}),exports.addCustomTypes=exports.Schema=exports.t=void 0;var _typy=require('./typy'),_typy2=_interopRequireDefault(_typy);function _interopRequireDefault(a){return a&&a.__esModule?a:{default:a}}var t=function(a,b){return new _typy2.default().t(a,b)},Schema=_typy2.default.Schema,addCustomTypes=function(a){if(t(a).isObject)Object.keys(a).forEach(function(b){if(t(a[b]).isFunction)_typy2.default.prototype.__defineGetter__(b,function(){return a[b](this.input)});else throw new Error('validator '+b+' is not a function')});else throw new Error('validators must be key value pairs')};exports.default=t,exports.t=t,exports.Schema=Schema,exports.addCustomTypes=addCustomTypes;","'use strict';Object.defineProperty(exports,'__esModule',{value:!0});var _typeof='function'==typeof Symbol&&'symbol'==typeof Symbol.iterator?function(a){return typeof a}:function(a){return a&&'function'==typeof Symbol&&a.constructor===Symbol&&a!==Symbol.prototype?'symbol':typeof a},_createClass=function(){function a(a,b){for(var c,d=0;d<b.length;d++)c=b[d],c.enumerable=c.enumerable||!1,c.configurable=!0,'value'in c&&(c.writable=!0),Object.defineProperty(a,c.key,c)}return function(b,c,d){return c&&a(b.prototype,c),d&&a(b,d),b}}(),_util=require('./util');function _classCallCheck(a,b){if(!(a instanceof b))throw new TypeError('Cannot call a class as a function')}var Typy=function(){function a(){var b=this;_classCallCheck(this,a),this.t=function(a,c){if(b.input=a,b.schemaCheck=null,c)if('string'==typeof c)b.input=(0,_util.getNestedObject)(b.input,c);else{var d=(0,_util.convertSchemaAndGetMatch)(b.input,c);-1===d?(b.schemaCheck=!1,b.input=a):(b.schemaCheck=!0,b.input=d)}return b}}return _createClass(a,[{key:'isValid',get:function get(){return null!==this.schemaCheck&&!0===this.schemaCheck&&null!==this.input&&void 0!==this.input}},{key:'isDefined',get:function get(){return'undefined'!=typeof this.input}},{key:'isUndefined',get:function get(){return'undefined'==typeof this.input}},{key:'isNull',get:function get(){return null===this.input&&'object'===_typeof(this.input)}},{key:'isNullOrUndefined',get:function get(){return!!(this.isNull||this.isUndefined)}},{key:'isBoolean',get:function get(){return _typeof(this.input)===_typeof(!0)}},{key:'isTrue',get:function get(){return!0===this.input}},{key:'isFalse',get:function get(){return!1===this.input}},{key:'isTruthy',get:function get(){return!!this.input}},{key:'isFalsy',get:function get(){return!this.input}},{key:'isObject',get:function get(){return'object'===_typeof(this.input)&&this.input===Object(this.input)&&'[object Array]'!==Object.prototype.toString.call(this.input)}},{key:'isEmptyObject',get:function get(){return!!(this.isObject&&0===Object.keys(this.input).length)}},{key:'isString',get:function get(){return'string'==typeof this.input}},{key:'isEmptyString',get:function get(){return!!(this.isString&&0===this.input.length)}},{key:'isNumber',get:function get(){return!!Number.isFinite(this.input)}},{key:'isArray',get:function get(){return!!Array.isArray(this.input)}},{key:'isEmptyArray',get:function get(){return!!(this.isArray&&0===this.input.length)}},{key:'isFunction',get:function get(){return'function'==typeof this.input}},{key:'safeObject',get:function get(){return this.input}},{key:'safeString',get:function get(){return this.isString?this.input:''}},{key:'safeNumber',get:function get(){return this.isNumber?this.input:0}},{key:'safeBoolean',get:function get(){return!!this.isBoolean&&this.input}},{key:'safeFunction',get:function get(){return this.isFunction?this.input:function(){}}}]),a}();Typy.Schema={Number:1,String:'typy',Boolean:!0,Null:null,Undefined:void 0,Array:[],Function:function Function(){}},exports.default=Typy,module.exports=exports['default'];","'use strict';var _typeof='function'==typeof Symbol&&'symbol'==typeof Symbol.iterator?function(a){return typeof a}:function(a){return a&&'function'==typeof Symbol&&a.constructor===Symbol&&a!==Symbol.prototype?'symbol':typeof a},_arguments=arguments,getNestedObject=function(a,b){if(!(1<_arguments.length&&'string'!=typeof b)){if('undefined'!=typeof a&&'string'==typeof b){var c=/[.\\[\\]'\"]/g,d=b.split(c).filter(function(a){return''!==a});a=d.reduce(function(a,b){return a&&'undefined'!==a[b]?a[b]:void 0},a)}return a}},buildSchema=function(a){if('[object Array]'===Object.prototype.toString.call(a))a.forEach(function(a){return buildSchema(a)});else if('[object Object]'===Object.prototype.toString.call(a))Object.keys(a).forEach(function(b){return buildSchema(a[b])});else return'undefined'==typeof a?'undefined':_typeof(a);return a},getSchemaMatch=function(a,b){var c=!1;if('[object Array]'===Object.prototype.toString.call(a)){if(b.length)for(var d=0;d<a.length;d+=1){if(!getSchemaMatch(a[d],b[d])){c=!1;break}c=!0}else return!0;}else if('[object Object]'===Object.prototype.toString.call(a))for(var e in a){if(!getSchemaMatch(a[e],b[e])){c=!1;break}c=!0}else return('undefined'==typeof b?'undefined':_typeof(b))===('undefined'==typeof a?'undefined':_typeof(a));return c},convertSchemaAndGetMatch=function(a,b){var c=buildSchema(b);return getSchemaMatch(a,c)?a:-1};module.exports={getNestedObject:getNestedObject,buildSchema:buildSchema,getSchemaMatch:getSchemaMatch,convertSchemaAndGetMatch:convertSchemaAndGetMatch};","!function(t,n){\"object\"==typeof exports&&\"undefined\"!=typeof module?module.exports=n():\"function\"==typeof define&&define.amd?define(n):t.dayjs_plugin_customParseFormat=n()}(this,function(){\"use strict\";var t,n=/(\\[[^[]*\\])|([-:/.()\\s]+)|(A|a|YYYY|YY?|MM?M?M?|Do|DD?|hh?|HH?|mm?|ss?|S{1,3}|z|ZZ?)/g,e=/\\d\\d/,r=/\\d\\d?/,o=/\\d*[^\\s\\d-:/.()]+/;var s=function(t){return function(n){this[t]=+n}},i=[/[+-]\\d\\d:?\\d\\d/,function(t){var n,e;(this.zone||(this.zone={})).offset=(n=t.match(/([+-]|\\d\\d)/g),0===(e=60*n[1]+ +n[2])?0:\"+\"===n[0]?-e:e)}],a={A:[/[AP]M/,function(t){this.afternoon=\"PM\"===t}],a:[/[ap]m/,function(t){this.afternoon=\"pm\"===t}],S:[/\\d/,function(t){this.milliseconds=100*+t}],SS:[e,function(t){this.milliseconds=10*+t}],SSS:[/\\d{3}/,function(t){this.milliseconds=+t}],s:[r,s(\"seconds\")],ss:[r,s(\"seconds\")],m:[r,s(\"minutes\")],mm:[r,s(\"minutes\")],H:[r,s(\"hours\")],h:[r,s(\"hours\")],HH:[r,s(\"hours\")],hh:[r,s(\"hours\")],D:[r,s(\"day\")],DD:[e,s(\"day\")],Do:[o,function(n){var e=t.ordinal,r=n.match(/\\d+/);if(this.day=r[0],e)for(var o=1;o<=31;o+=1)e(o).replace(/\\[|\\]/g,\"\")===n&&(this.day=o)}],M:[r,s(\"month\")],MM:[e,s(\"month\")],MMM:[o,function(n){var e=t,r=e.months,o=e.monthsShort,s=o?o.findIndex(function(t){return t===n}):r.findIndex(function(t){return t.substr(0,3)===n});if(s<0)throw new Error;this.month=s+1}],MMMM:[o,function(n){var e=t.months.indexOf(n);if(e<0)throw new Error;this.month=e+1}],Y:[/[+-]?\\d+/,s(\"year\")],YY:[e,function(t){t=+t,this.year=t+(t>68?1900:2e3)}],YYYY:[/\\d{4}/,s(\"year\")],Z:i,ZZ:i};var u=function(t,e,r){try{var o=function(t){for(var e=t.match(n),r=e.length,o=0;o<r;o+=1){var s=e[o],i=a[s],u=i&&i[0],f=i&&i[1];e[o]=f?{regex:u,parser:f}:s.replace(/^\\[|\\]$/g,\"\")}return function(t){for(var n={},o=0,s=0;o<r;o+=1){var i=e[o];if(\"string\"==typeof i)s+=i.length;else{var a=i.regex,u=i.parser,f=t.substr(s),h=a.exec(f)[0];u.call(n,h),s+=h.length}}return function(t){var n=t.afternoon;if(void 0!==n){var e=t.hours;n?e<12&&(t.hours+=12):12===e&&(t.hours=0),delete t.afternoon}}(n),n}}(e)(t),s=o.year,i=o.month,u=o.day,f=o.hours,h=o.minutes,d=o.seconds,c=o.milliseconds,m=o.zone;if(m)return new Date(Date.UTC(s,i-1,u,f||0,h||0,d||0,c||0)+60*m.offset*1e3);var l=new Date,v=s||l.getFullYear(),p=i>0?i-1:l.getMonth(),M=u||l.getDate(),y=f||0,D=h||0,g=d||0,Y=c||0;return r?new Date(Date.UTC(v,p,M,y,D,g,Y)):new Date(v,p,M,y,D,g,Y)}catch(t){return new Date(\"\")}};return function(n,e,r){var o=e.prototype,s=o.parse;o.parse=function(n){var e=n.date,o=n.format,i=n.pl,a=n.utc;this.$u=a,o?(t=i?r.Ls[i]:this.$locale(),this.$d=u(e,o,a),this.init(n)):s.call(this,n)}}});\n","/*! @preserve\n * numeral.js\n * version : 2.0.6\n * author : Adam Draper\n * license : MIT\n * http://adamwdraper.github.com/Numeral-js/\n */\n\n(function (global, factory) {\n    if (typeof define === 'function' && define.amd) {\n        define(factory);\n    } else if (typeof module === 'object' && module.exports) {\n        module.exports = factory();\n    } else {\n        global.numeral = factory();\n    }\n}(this, function () {\n    /************************************\n        Variables\n    ************************************/\n\n    var numeral,\n        _,\n        VERSION = '2.0.6',\n        formats = {},\n        locales = {},\n        defaults = {\n            currentLocale: 'en',\n            zeroFormat: null,\n            nullFormat: null,\n            defaultFormat: '0,0',\n            scalePercentBy100: true\n        },\n        options = {\n            currentLocale: defaults.currentLocale,\n            zeroFormat: defaults.zeroFormat,\n            nullFormat: defaults.nullFormat,\n            defaultFormat: defaults.defaultFormat,\n            scalePercentBy100: defaults.scalePercentBy100\n        };\n\n\n    /************************************\n        Constructors\n    ************************************/\n\n    // Numeral prototype object\n    function Numeral(input, number) {\n        this._input = input;\n\n        this._value = number;\n    }\n\n    numeral = function(input) {\n        var value,\n            kind,\n            unformatFunction,\n            regexp;\n\n        if (numeral.isNumeral(input)) {\n            value = input.value();\n        } else if (input === 0 || typeof input === 'undefined') {\n            value = 0;\n        } else if (input === null || _.isNaN(input)) {\n            value = null;\n        } else if (typeof input === 'string') {\n            if (options.zeroFormat && input === options.zeroFormat) {\n                value = 0;\n            } else if (options.nullFormat && input === options.nullFormat || !input.replace(/[^0-9]+/g, '').length) {\n                value = null;\n            } else {\n                for (kind in formats) {\n                    regexp = typeof formats[kind].regexps.unformat === 'function' ? formats[kind].regexps.unformat() : formats[kind].regexps.unformat;\n\n                    if (regexp && input.match(regexp)) {\n                        unformatFunction = formats[kind].unformat;\n\n                        break;\n                    }\n                }\n\n                unformatFunction = unformatFunction || numeral._.stringToNumber;\n\n                value = unformatFunction(input);\n            }\n        } else {\n            value = Number(input)|| null;\n        }\n\n        return new Numeral(input, value);\n    };\n\n    // version number\n    numeral.version = VERSION;\n\n    // compare numeral object\n    numeral.isNumeral = function(obj) {\n        return obj instanceof Numeral;\n    };\n\n    // helper functions\n    numeral._ = _ = {\n        // formats numbers separators, decimals places, signs, abbreviations\n        numberToFormat: function(value, format, roundingFunction) {\n            var locale = locales[numeral.options.currentLocale],\n                negP = false,\n                optDec = false,\n                leadingCount = 0,\n                abbr = '',\n                trillion = 1000000000000,\n                billion = 1000000000,\n                million = 1000000,\n                thousand = 1000,\n                decimal = '',\n                neg = false,\n                abbrForce, // force abbreviation\n                abs,\n                min,\n                max,\n                power,\n                int,\n                precision,\n                signed,\n                thousands,\n                output;\n\n            // make sure we never format a null value\n            value = value || 0;\n\n            abs = Math.abs(value);\n\n            // see if we should use parentheses for negative number or if we should prefix with a sign\n            // if both are present we default to parentheses\n            if (numeral._.includes(format, '(')) {\n                negP = true;\n                format = format.replace(/[\\(|\\)]/g, '');\n            } else if (numeral._.includes(format, '+') || numeral._.includes(format, '-')) {\n                signed = numeral._.includes(format, '+') ? format.indexOf('+') : value < 0 ? format.indexOf('-') : -1;\n                format = format.replace(/[\\+|\\-]/g, '');\n            }\n\n            // see if abbreviation is wanted\n            if (numeral._.includes(format, 'a')) {\n                abbrForce = format.match(/a(k|m|b|t)?/);\n\n                abbrForce = abbrForce ? abbrForce[1] : false;\n\n                // check for space before abbreviation\n                if (numeral._.includes(format, ' a')) {\n                    abbr = ' ';\n                }\n\n                format = format.replace(new RegExp(abbr + 'a[kmbt]?'), '');\n\n                if (abs >= trillion && !abbrForce || abbrForce === 't') {\n                    // trillion\n                    abbr += locale.abbreviations.trillion;\n                    value = value / trillion;\n                } else if (abs < trillion && abs >= billion && !abbrForce || abbrForce === 'b') {\n                    // billion\n                    abbr += locale.abbreviations.billion;\n                    value = value / billion;\n                } else if (abs < billion && abs >= million && !abbrForce || abbrForce === 'm') {\n                    // million\n                    abbr += locale.abbreviations.million;\n                    value = value / million;\n                } else if (abs < million && abs >= thousand && !abbrForce || abbrForce === 'k') {\n                    // thousand\n                    abbr += locale.abbreviations.thousand;\n                    value = value / thousand;\n                }\n            }\n\n            // check for optional decimals\n            if (numeral._.includes(format, '[.]')) {\n                optDec = true;\n                format = format.replace('[.]', '.');\n            }\n\n            // break number and format\n            int = value.toString().split('.')[0];\n            precision = format.split('.')[1];\n            thousands = format.indexOf(',');\n            leadingCount = (format.split('.')[0].split(',')[0].match(/0/g) || []).length;\n\n            if (precision) {\n                if (numeral._.includes(precision, '[')) {\n                    precision = precision.replace(']', '');\n                    precision = precision.split('[');\n                    decimal = numeral._.toFixed(value, (precision[0].length + precision[1].length), roundingFunction, precision[1].length);\n                } else {\n                    decimal = numeral._.toFixed(value, precision.length, roundingFunction);\n                }\n\n                int = decimal.split('.')[0];\n\n                if (numeral._.includes(decimal, '.')) {\n                    decimal = locale.delimiters.decimal + decimal.split('.')[1];\n                } else {\n                    decimal = '';\n                }\n\n                if (optDec && Number(decimal.slice(1)) === 0) {\n                    decimal = '';\n                }\n            } else {\n                int = numeral._.toFixed(value, 0, roundingFunction);\n            }\n\n            // check abbreviation again after rounding\n            if (abbr && !abbrForce && Number(int) >= 1000 && abbr !== locale.abbreviations.trillion) {\n                int = String(Number(int) / 1000);\n\n                switch (abbr) {\n                    case locale.abbreviations.thousand:\n                        abbr = locale.abbreviations.million;\n                        break;\n                    case locale.abbreviations.million:\n                        abbr = locale.abbreviations.billion;\n                        break;\n                    case locale.abbreviations.billion:\n                        abbr = locale.abbreviations.trillion;\n                        break;\n                }\n            }\n\n\n            // format number\n            if (numeral._.includes(int, '-')) {\n                int = int.slice(1);\n                neg = true;\n            }\n\n            if (int.length < leadingCount) {\n                for (var i = leadingCount - int.length; i > 0; i--) {\n                    int = '0' + int;\n                }\n            }\n\n            if (thousands > -1) {\n                int = int.toString().replace(/(\\d)(?=(\\d{3})+(?!\\d))/g, '$1' + locale.delimiters.thousands);\n            }\n\n            if (format.indexOf('.') === 0) {\n                int = '';\n            }\n\n            output = int + decimal + (abbr ? abbr : '');\n\n            if (negP) {\n                output = (negP && neg ? '(' : '') + output + (negP && neg ? ')' : '');\n            } else {\n                if (signed >= 0) {\n                    output = signed === 0 ? (neg ? '-' : '+') + output : output + (neg ? '-' : '+');\n                } else if (neg) {\n                    output = '-' + output;\n                }\n            }\n\n            return output;\n        },\n        // unformats numbers separators, decimals places, signs, abbreviations\n        stringToNumber: function(string) {\n            var locale = locales[options.currentLocale],\n                stringOriginal = string,\n                abbreviations = {\n                    thousand: 3,\n                    million: 6,\n                    billion: 9,\n                    trillion: 12\n                },\n                abbreviation,\n                value,\n                i,\n                regexp;\n\n            if (options.zeroFormat && string === options.zeroFormat) {\n                value = 0;\n            } else if (options.nullFormat && string === options.nullFormat || !string.replace(/[^0-9]+/g, '').length) {\n                value = null;\n            } else {\n                value = 1;\n\n                if (locale.delimiters.decimal !== '.') {\n                    string = string.replace(/\\./g, '').replace(locale.delimiters.decimal, '.');\n                }\n\n                for (abbreviation in abbreviations) {\n                    regexp = new RegExp('[^a-zA-Z]' + locale.abbreviations[abbreviation] + '(?:\\\\)|(\\\\' + locale.currency.symbol + ')?(?:\\\\))?)?$');\n\n                    if (stringOriginal.match(regexp)) {\n                        value *= Math.pow(10, abbreviations[abbreviation]);\n                        break;\n                    }\n                }\n\n                // check for negative number\n                value *= (string.split('-').length + Math.min(string.split('(').length - 1, string.split(')').length - 1)) % 2 ? 1 : -1;\n\n                // remove non numbers\n                string = string.replace(/[^0-9\\.]+/g, '');\n\n                value *= Number(string);\n            }\n\n            return value;\n        },\n        isNaN: function(value) {\n            return typeof value === 'number' && isNaN(value);\n        },\n        includes: function(string, search) {\n            return string.indexOf(search) !== -1;\n        },\n        insert: function(string, subString, start) {\n            return string.slice(0, start) + subString + string.slice(start);\n        },\n        reduce: function(array, callback /*, initialValue*/) {\n            if (this === null) {\n                throw new TypeError('Array.prototype.reduce called on null or undefined');\n            }\n\n            if (typeof callback !== 'function') {\n                throw new TypeError(callback + ' is not a function');\n            }\n\n            var t = Object(array),\n                len = t.length >>> 0,\n                k = 0,\n                value;\n\n            if (arguments.length === 3) {\n                value = arguments[2];\n            } else {\n                while (k < len && !(k in t)) {\n                    k++;\n                }\n\n                if (k >= len) {\n                    throw new TypeError('Reduce of empty array with no initial value');\n                }\n\n                value = t[k++];\n            }\n            for (; k < len; k++) {\n                if (k in t) {\n                    value = callback(value, t[k], k, t);\n                }\n            }\n            return value;\n        },\n        /**\n         * Computes the multiplier necessary to make x >= 1,\n         * effectively eliminating miscalculations caused by\n         * finite precision.\n         */\n        multiplier: function (x) {\n            var parts = x.toString().split('.');\n\n            return parts.length < 2 ? 1 : Math.pow(10, parts[1].length);\n        },\n        /**\n         * Given a variable number of arguments, returns the maximum\n         * multiplier that must be used to normalize an operation involving\n         * all of them.\n         */\n        correctionFactor: function () {\n            var args = Array.prototype.slice.call(arguments);\n\n            return args.reduce(function(accum, next) {\n                var mn = _.multiplier(next);\n                return accum > mn ? accum : mn;\n            }, 1);\n        },\n        /**\n         * Implementation of toFixed() that treats floats more like decimals\n         *\n         * Fixes binary rounding issues (eg. (0.615).toFixed(2) === '0.61') that present\n         * problems for accounting- and finance-related software.\n         */\n        toFixed: function(value, maxDecimals, roundingFunction, optionals) {\n            var splitValue = value.toString().split('.'),\n                minDecimals = maxDecimals - (optionals || 0),\n                boundedPrecision,\n                optionalsRegExp,\n                power,\n                output;\n\n            // Use the smallest precision value possible to avoid errors from floating point representation\n            if (splitValue.length === 2) {\n              boundedPrecision = Math.min(Math.max(splitValue[1].length, minDecimals), maxDecimals);\n            } else {\n              boundedPrecision = minDecimals;\n            }\n\n            power = Math.pow(10, boundedPrecision);\n\n            // Multiply up by precision, round accurately, then divide and use native toFixed():\n            output = (roundingFunction(value + 'e+' + boundedPrecision) / power).toFixed(boundedPrecision);\n\n            if (optionals > maxDecimals - boundedPrecision) {\n                optionalsRegExp = new RegExp('\\\\.?0{1,' + (optionals - (maxDecimals - boundedPrecision)) + '}$');\n                output = output.replace(optionalsRegExp, '');\n            }\n\n            return output;\n        }\n    };\n\n    // avaliable options\n    numeral.options = options;\n\n    // avaliable formats\n    numeral.formats = formats;\n\n    // avaliable formats\n    numeral.locales = locales;\n\n    // This function sets the current locale.  If\n    // no arguments are passed in, it will simply return the current global\n    // locale key.\n    numeral.locale = function(key) {\n        if (key) {\n            options.currentLocale = key.toLowerCase();\n        }\n\n        return options.currentLocale;\n    };\n\n    // This function provides access to the loaded locale data.  If\n    // no arguments are passed in, it will simply return the current\n    // global locale object.\n    numeral.localeData = function(key) {\n        if (!key) {\n            return locales[options.currentLocale];\n        }\n\n        key = key.toLowerCase();\n\n        if (!locales[key]) {\n            throw new Error('Unknown locale : ' + key);\n        }\n\n        return locales[key];\n    };\n\n    numeral.reset = function() {\n        for (var property in defaults) {\n            options[property] = defaults[property];\n        }\n    };\n\n    numeral.zeroFormat = function(format) {\n        options.zeroFormat = typeof(format) === 'string' ? format : null;\n    };\n\n    numeral.nullFormat = function (format) {\n        options.nullFormat = typeof(format) === 'string' ? format : null;\n    };\n\n    numeral.defaultFormat = function(format) {\n        options.defaultFormat = typeof(format) === 'string' ? format : '0.0';\n    };\n\n    numeral.register = function(type, name, format) {\n        name = name.toLowerCase();\n\n        if (this[type + 's'][name]) {\n            throw new TypeError(name + ' ' + type + ' already registered.');\n        }\n\n        this[type + 's'][name] = format;\n\n        return format;\n    };\n\n\n    numeral.validate = function(val, culture) {\n        var _decimalSep,\n            _thousandSep,\n            _currSymbol,\n            _valArray,\n            _abbrObj,\n            _thousandRegEx,\n            localeData,\n            temp;\n\n        //coerce val to string\n        if (typeof val !== 'string') {\n            val += '';\n\n            if (console.warn) {\n                console.warn('Numeral.js: Value is not string. It has been co-erced to: ', val);\n            }\n        }\n\n        //trim whitespaces from either sides\n        val = val.trim();\n\n        //if val is just digits return true\n        if (!!val.match(/^\\d+$/)) {\n            return true;\n        }\n\n        //if val is empty return false\n        if (val === '') {\n            return false;\n        }\n\n        //get the decimal and thousands separator from numeral.localeData\n        try {\n            //check if the culture is understood by numeral. if not, default it to current locale\n            localeData = numeral.localeData(culture);\n        } catch (e) {\n            localeData = numeral.localeData(numeral.locale());\n        }\n\n        //setup the delimiters and currency symbol based on culture/locale\n        _currSymbol = localeData.currency.symbol;\n        _abbrObj = localeData.abbreviations;\n        _decimalSep = localeData.delimiters.decimal;\n        if (localeData.delimiters.thousands === '.') {\n            _thousandSep = '\\\\.';\n        } else {\n            _thousandSep = localeData.delimiters.thousands;\n        }\n\n        // validating currency symbol\n        temp = val.match(/^[^\\d]+/);\n        if (temp !== null) {\n            val = val.substr(1);\n            if (temp[0] !== _currSymbol) {\n                return false;\n            }\n        }\n\n        //validating abbreviation symbol\n        temp = val.match(/[^\\d]+$/);\n        if (temp !== null) {\n            val = val.slice(0, -1);\n            if (temp[0] !== _abbrObj.thousand && temp[0] !== _abbrObj.million && temp[0] !== _abbrObj.billion && temp[0] !== _abbrObj.trillion) {\n                return false;\n            }\n        }\n\n        _thousandRegEx = new RegExp(_thousandSep + '{2}');\n\n        if (!val.match(/[^\\d.,]/g)) {\n            _valArray = val.split(_decimalSep);\n            if (_valArray.length > 2) {\n                return false;\n            } else {\n                if (_valArray.length < 2) {\n                    return ( !! _valArray[0].match(/^\\d+.*\\d$/) && !_valArray[0].match(_thousandRegEx));\n                } else {\n                    if (_valArray[0].length === 1) {\n                        return ( !! _valArray[0].match(/^\\d+$/) && !_valArray[0].match(_thousandRegEx) && !! _valArray[1].match(/^\\d+$/));\n                    } else {\n                        return ( !! _valArray[0].match(/^\\d+.*\\d$/) && !_valArray[0].match(_thousandRegEx) && !! _valArray[1].match(/^\\d+$/));\n                    }\n                }\n            }\n        }\n\n        return false;\n    };\n\n\n    /************************************\n        Numeral Prototype\n    ************************************/\n\n    numeral.fn = Numeral.prototype = {\n        clone: function() {\n            return numeral(this);\n        },\n        format: function(inputString, roundingFunction) {\n            var value = this._value,\n                format = inputString || options.defaultFormat,\n                kind,\n                output,\n                formatFunction;\n\n            // make sure we have a roundingFunction\n            roundingFunction = roundingFunction || Math.round;\n\n            // format based on value\n            if (value === 0 && options.zeroFormat !== null) {\n                output = options.zeroFormat;\n            } else if (value === null && options.nullFormat !== null) {\n                output = options.nullFormat;\n            } else {\n                for (kind in formats) {\n                    if (format.match(formats[kind].regexps.format)) {\n                        formatFunction = formats[kind].format;\n\n                        break;\n                    }\n                }\n\n                formatFunction = formatFunction || numeral._.numberToFormat;\n\n                output = formatFunction(value, format, roundingFunction);\n            }\n\n            return output;\n        },\n        value: function() {\n            return this._value;\n        },\n        input: function() {\n            return this._input;\n        },\n        set: function(value) {\n            this._value = Number(value);\n\n            return this;\n        },\n        add: function(value) {\n            var corrFactor = _.correctionFactor.call(null, this._value, value);\n\n            function cback(accum, curr, currI, O) {\n                return accum + Math.round(corrFactor * curr);\n            }\n\n            this._value = _.reduce([this._value, value], cback, 0) / corrFactor;\n\n            return this;\n        },\n        subtract: function(value) {\n            var corrFactor = _.correctionFactor.call(null, this._value, value);\n\n            function cback(accum, curr, currI, O) {\n                return accum - Math.round(corrFactor * curr);\n            }\n\n            this._value = _.reduce([value], cback, Math.round(this._value * corrFactor)) / corrFactor;\n\n            return this;\n        },\n        multiply: function(value) {\n            function cback(accum, curr, currI, O) {\n                var corrFactor = _.correctionFactor(accum, curr);\n                return Math.round(accum * corrFactor) * Math.round(curr * corrFactor) / Math.round(corrFactor * corrFactor);\n            }\n\n            this._value = _.reduce([this._value, value], cback, 1);\n\n            return this;\n        },\n        divide: function(value) {\n            function cback(accum, curr, currI, O) {\n                var corrFactor = _.correctionFactor(accum, curr);\n                return Math.round(accum * corrFactor) / Math.round(curr * corrFactor);\n            }\n\n            this._value = _.reduce([this._value, value], cback);\n\n            return this;\n        },\n        difference: function(value) {\n            return Math.abs(numeral(this._value).subtract(value).value());\n        }\n    };\n\n    /************************************\n        Default Locale && Format\n    ************************************/\n\n    numeral.register('locale', 'en', {\n        delimiters: {\n            thousands: ',',\n            decimal: '.'\n        },\n        abbreviations: {\n            thousand: 'k',\n            million: 'm',\n            billion: 'b',\n            trillion: 't'\n        },\n        ordinal: function(number) {\n            var b = number % 10;\n            return (~~(number % 100 / 10) === 1) ? 'th' :\n                (b === 1) ? 'st' :\n                (b === 2) ? 'nd' :\n                (b === 3) ? 'rd' : 'th';\n        },\n        currency: {\n            symbol: '$'\n        }\n    });\n\n    \n\n(function() {\n        numeral.register('format', 'bps', {\n            regexps: {\n                format: /(BPS)/,\n                unformat: /(BPS)/\n            },\n            format: function(value, format, roundingFunction) {\n                var space = numeral._.includes(format, ' BPS') ? ' ' : '',\n                    output;\n\n                value = value * 10000;\n\n                // check for space before BPS\n                format = format.replace(/\\s?BPS/, '');\n\n                output = numeral._.numberToFormat(value, format, roundingFunction);\n\n                if (numeral._.includes(output, ')')) {\n                    output = output.split('');\n\n                    output.splice(-1, 0, space + 'BPS');\n\n                    output = output.join('');\n                } else {\n                    output = output + space + 'BPS';\n                }\n\n                return output;\n            },\n            unformat: function(string) {\n                return +(numeral._.stringToNumber(string) * 0.0001).toFixed(15);\n            }\n        });\n})();\n\n\n(function() {\n        var decimal = {\n            base: 1000,\n            suffixes: ['B', 'KB', 'MB', 'GB', 'TB', 'PB', 'EB', 'ZB', 'YB']\n        },\n        binary = {\n            base: 1024,\n            suffixes: ['B', 'KiB', 'MiB', 'GiB', 'TiB', 'PiB', 'EiB', 'ZiB', 'YiB']\n        };\n\n    var allSuffixes =  decimal.suffixes.concat(binary.suffixes.filter(function (item) {\n            return decimal.suffixes.indexOf(item) < 0;\n        }));\n        var unformatRegex = allSuffixes.join('|');\n        // Allow support for BPS (http://www.investopedia.com/terms/b/basispoint.asp)\n        unformatRegex = '(' + unformatRegex.replace('B', 'B(?!PS)') + ')';\n\n    numeral.register('format', 'bytes', {\n        regexps: {\n            format: /([0\\s]i?b)/,\n            unformat: new RegExp(unformatRegex)\n        },\n        format: function(value, format, roundingFunction) {\n            var output,\n                bytes = numeral._.includes(format, 'ib') ? binary : decimal,\n                suffix = numeral._.includes(format, ' b') || numeral._.includes(format, ' ib') ? ' ' : '',\n                power,\n                min,\n                max;\n\n            // check for space before\n            format = format.replace(/\\s?i?b/, '');\n\n            for (power = 0; power <= bytes.suffixes.length; power++) {\n                min = Math.pow(bytes.base, power);\n                max = Math.pow(bytes.base, power + 1);\n\n                if (value === null || value === 0 || value >= min && value < max) {\n                    suffix += bytes.suffixes[power];\n\n                    if (min > 0) {\n                        value = value / min;\n                    }\n\n                    break;\n                }\n            }\n\n            output = numeral._.numberToFormat(value, format, roundingFunction);\n\n            return output + suffix;\n        },\n        unformat: function(string) {\n            var value = numeral._.stringToNumber(string),\n                power,\n                bytesMultiplier;\n\n            if (value) {\n                for (power = decimal.suffixes.length - 1; power >= 0; power--) {\n                    if (numeral._.includes(string, decimal.suffixes[power])) {\n                        bytesMultiplier = Math.pow(decimal.base, power);\n\n                        break;\n                    }\n\n                    if (numeral._.includes(string, binary.suffixes[power])) {\n                        bytesMultiplier = Math.pow(binary.base, power);\n\n                        break;\n                    }\n                }\n\n                value *= (bytesMultiplier || 1);\n            }\n\n            return value;\n        }\n    });\n})();\n\n\n(function() {\n        numeral.register('format', 'currency', {\n        regexps: {\n            format: /(\\$)/\n        },\n        format: function(value, format, roundingFunction) {\n            var locale = numeral.locales[numeral.options.currentLocale],\n                symbols = {\n                    before: format.match(/^([\\+|\\-|\\(|\\s|\\$]*)/)[0],\n                    after: format.match(/([\\+|\\-|\\)|\\s|\\$]*)$/)[0]\n                },\n                output,\n                symbol,\n                i;\n\n            // strip format of spaces and $\n            format = format.replace(/\\s?\\$\\s?/, '');\n\n            // format the number\n            output = numeral._.numberToFormat(value, format, roundingFunction);\n\n            // update the before and after based on value\n            if (value >= 0) {\n                symbols.before = symbols.before.replace(/[\\-\\(]/, '');\n                symbols.after = symbols.after.replace(/[\\-\\)]/, '');\n            } else if (value < 0 && (!numeral._.includes(symbols.before, '-') && !numeral._.includes(symbols.before, '('))) {\n                symbols.before = '-' + symbols.before;\n            }\n\n            // loop through each before symbol\n            for (i = 0; i < symbols.before.length; i++) {\n                symbol = symbols.before[i];\n\n                switch (symbol) {\n                    case '$':\n                        output = numeral._.insert(output, locale.currency.symbol, i);\n                        break;\n                    case ' ':\n                        output = numeral._.insert(output, ' ', i + locale.currency.symbol.length - 1);\n                        break;\n                }\n            }\n\n            // loop through each after symbol\n            for (i = symbols.after.length - 1; i >= 0; i--) {\n                symbol = symbols.after[i];\n\n                switch (symbol) {\n                    case '$':\n                        output = i === symbols.after.length - 1 ? output + locale.currency.symbol : numeral._.insert(output, locale.currency.symbol, -(symbols.after.length - (1 + i)));\n                        break;\n                    case ' ':\n                        output = i === symbols.after.length - 1 ? output + ' ' : numeral._.insert(output, ' ', -(symbols.after.length - (1 + i) + locale.currency.symbol.length - 1));\n                        break;\n                }\n            }\n\n\n            return output;\n        }\n    });\n})();\n\n\n(function() {\n        numeral.register('format', 'exponential', {\n        regexps: {\n            format: /(e\\+|e-)/,\n            unformat: /(e\\+|e-)/\n        },\n        format: function(value, format, roundingFunction) {\n            var output,\n                exponential = typeof value === 'number' && !numeral._.isNaN(value) ? value.toExponential() : '0e+0',\n                parts = exponential.split('e');\n\n            format = format.replace(/e[\\+|\\-]{1}0/, '');\n\n            output = numeral._.numberToFormat(Number(parts[0]), format, roundingFunction);\n\n            return output + 'e' + parts[1];\n        },\n        unformat: function(string) {\n            var parts = numeral._.includes(string, 'e+') ? string.split('e+') : string.split('e-'),\n                value = Number(parts[0]),\n                power = Number(parts[1]);\n\n            power = numeral._.includes(string, 'e-') ? power *= -1 : power;\n\n            function cback(accum, curr, currI, O) {\n                var corrFactor = numeral._.correctionFactor(accum, curr),\n                    num = (accum * corrFactor) * (curr * corrFactor) / (corrFactor * corrFactor);\n                return num;\n            }\n\n            return numeral._.reduce([value, Math.pow(10, power)], cback, 1);\n        }\n    });\n})();\n\n\n(function() {\n        numeral.register('format', 'ordinal', {\n        regexps: {\n            format: /(o)/\n        },\n        format: function(value, format, roundingFunction) {\n            var locale = numeral.locales[numeral.options.currentLocale],\n                output,\n                ordinal = numeral._.includes(format, ' o') ? ' ' : '';\n\n            // check for space before\n            format = format.replace(/\\s?o/, '');\n\n            ordinal += locale.ordinal(value);\n\n            output = numeral._.numberToFormat(value, format, roundingFunction);\n\n            return output + ordinal;\n        }\n    });\n})();\n\n\n(function() {\n        numeral.register('format', 'percentage', {\n        regexps: {\n            format: /(%)/,\n            unformat: /(%)/\n        },\n        format: function(value, format, roundingFunction) {\n            var space = numeral._.includes(format, ' %') ? ' ' : '',\n                output;\n\n            if (numeral.options.scalePercentBy100) {\n                value = value * 100;\n            }\n\n            // check for space before %\n            format = format.replace(/\\s?\\%/, '');\n\n            output = numeral._.numberToFormat(value, format, roundingFunction);\n\n            if (numeral._.includes(output, ')')) {\n                output = output.split('');\n\n                output.splice(-1, 0, space + '%');\n\n                output = output.join('');\n            } else {\n                output = output + space + '%';\n            }\n\n            return output;\n        },\n        unformat: function(string) {\n            var number = numeral._.stringToNumber(string);\n            if (numeral.options.scalePercentBy100) {\n                return number * 0.01;\n            }\n            return number;\n        }\n    });\n})();\n\n\n(function() {\n        numeral.register('format', 'time', {\n        regexps: {\n            format: /(:)/,\n            unformat: /(:)/\n        },\n        format: function(value, format, roundingFunction) {\n            var hours = Math.floor(value / 60 / 60),\n                minutes = Math.floor((value - (hours * 60 * 60)) / 60),\n                seconds = Math.round(value - (hours * 60 * 60) - (minutes * 60));\n\n            return hours + ':' + (minutes < 10 ? '0' + minutes : minutes) + ':' + (seconds < 10 ? '0' + seconds : seconds);\n        },\n        unformat: function(string) {\n            var timeArray = string.split(':'),\n                seconds = 0;\n\n            // turn hours and minutes into seconds and add them all up\n            if (timeArray.length === 3) {\n                // hours\n                seconds = seconds + (Number(timeArray[0]) * 60 * 60);\n                // minutes\n                seconds = seconds + (Number(timeArray[1]) * 60);\n                // seconds\n                seconds = seconds + Number(timeArray[2]);\n            } else if (timeArray.length === 2) {\n                // minutes\n                seconds = seconds + (Number(timeArray[0]) * 60);\n                // seconds\n                seconds = seconds + Number(timeArray[1]);\n            }\n            return Number(seconds);\n        }\n    });\n})();\n\nreturn numeral;\n}));\n","// Copyright Joyent, Inc. and other Node contributors.\n//\n// Permission is hereby granted, free of charge, to any person obtaining a\n// copy of this software and associated documentation files (the\n// \"Software\"), to deal in the Software without restriction, including\n// without limitation the rights to use, copy, modify, merge, publish,\n// distribute, sublicense, and/or sell copies of the Software, and to permit\n// persons to whom the Software is furnished to do so, subject to the\n// following conditions:\n//\n// The above copyright notice and this permission notice shall be included\n// in all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS\n// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN\n// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,\n// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR\n// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE\n// USE OR OTHER DEALINGS IN THE SOFTWARE.\n\nvar getOwnPropertyDescriptors = Object.getOwnPropertyDescriptors ||\n  function getOwnPropertyDescriptors(obj) {\n    var keys = Object.keys(obj);\n    var descriptors = {};\n    for (var i = 0; i < keys.length; i++) {\n      descriptors[keys[i]] = Object.getOwnPropertyDescriptor(obj, keys[i]);\n    }\n    return descriptors;\n  };\n\nvar formatRegExp = /%[sdj%]/g;\nexports.format = function(f) {\n  if (!isString(f)) {\n    var objects = [];\n    for (var i = 0; i < arguments.length; i++) {\n      objects.push(inspect(arguments[i]));\n    }\n    return objects.join(' ');\n  }\n\n  var i = 1;\n  var args = arguments;\n  var len = args.length;\n  var str = String(f).replace(formatRegExp, function(x) {\n    if (x === '%%') return '%';\n    if (i >= len) return x;\n    switch (x) {\n      case '%s': return String(args[i++]);\n      case '%d': return Number(args[i++]);\n      case '%j':\n        try {\n          return JSON.stringify(args[i++]);\n        } catch (_) {\n          return '[Circular]';\n        }\n      default:\n        return x;\n    }\n  });\n  for (var x = args[i]; i < len; x = args[++i]) {\n    if (isNull(x) || !isObject(x)) {\n      str += ' ' + x;\n    } else {\n      str += ' ' + inspect(x);\n    }\n  }\n  return str;\n};\n\n\n// Mark that a method should not be used.\n// Returns a modified function which warns once by default.\n// If --no-deprecation is set, then it is a no-op.\nexports.deprecate = function(fn, msg) {\n  if (typeof process !== 'undefined' && process.noDeprecation === true) {\n    return fn;\n  }\n\n  // Allow for deprecating things in the process of starting up.\n  if (typeof process === 'undefined') {\n    return function() {\n      return exports.deprecate(fn, msg).apply(this, arguments);\n    };\n  }\n\n  var warned = false;\n  function deprecated() {\n    if (!warned) {\n      if (process.throwDeprecation) {\n        throw new Error(msg);\n      } else if (process.traceDeprecation) {\n        console.trace(msg);\n      } else {\n        console.error(msg);\n      }\n      warned = true;\n    }\n    return fn.apply(this, arguments);\n  }\n\n  return deprecated;\n};\n\n\nvar debugs = {};\nvar debugEnviron;\nexports.debuglog = function(set) {\n  if (isUndefined(debugEnviron))\n    debugEnviron = process.env.NODE_DEBUG || '';\n  set = set.toUpperCase();\n  if (!debugs[set]) {\n    if (new RegExp('\\\\b' + set + '\\\\b', 'i').test(debugEnviron)) {\n      var pid = process.pid;\n      debugs[set] = function() {\n        var msg = exports.format.apply(exports, arguments);\n        console.error('%s %d: %s', set, pid, msg);\n      };\n    } else {\n      debugs[set] = function() {};\n    }\n  }\n  return debugs[set];\n};\n\n\n/**\n * Echos the value of a value. Trys to print the value out\n * in the best way possible given the different types.\n *\n * @param {Object} obj The object to print out.\n * @param {Object} opts Optional options object that alters the output.\n */\n/* legacy: obj, showHidden, depth, colors*/\nfunction inspect(obj, opts) {\n  // default options\n  var ctx = {\n    seen: [],\n    stylize: stylizeNoColor\n  };\n  // legacy...\n  if (arguments.length >= 3) ctx.depth = arguments[2];\n  if (arguments.length >= 4) ctx.colors = arguments[3];\n  if (isBoolean(opts)) {\n    // legacy...\n    ctx.showHidden = opts;\n  } else if (opts) {\n    // got an \"options\" object\n    exports._extend(ctx, opts);\n  }\n  // set default options\n  if (isUndefined(ctx.showHidden)) ctx.showHidden = false;\n  if (isUndefined(ctx.depth)) ctx.depth = 2;\n  if (isUndefined(ctx.colors)) ctx.colors = false;\n  if (isUndefined(ctx.customInspect)) ctx.customInspect = true;\n  if (ctx.colors) ctx.stylize = stylizeWithColor;\n  return formatValue(ctx, obj, ctx.depth);\n}\nexports.inspect = inspect;\n\n\n// http://en.wikipedia.org/wiki/ANSI_escape_code#graphics\ninspect.colors = {\n  'bold' : [1, 22],\n  'italic' : [3, 23],\n  'underline' : [4, 24],\n  'inverse' : [7, 27],\n  'white' : [37, 39],\n  'grey' : [90, 39],\n  'black' : [30, 39],\n  'blue' : [34, 39],\n  'cyan' : [36, 39],\n  'green' : [32, 39],\n  'magenta' : [35, 39],\n  'red' : [31, 39],\n  'yellow' : [33, 39]\n};\n\n// Don't use 'blue' not visible on cmd.exe\ninspect.styles = {\n  'special': 'cyan',\n  'number': 'yellow',\n  'boolean': 'yellow',\n  'undefined': 'grey',\n  'null': 'bold',\n  'string': 'green',\n  'date': 'magenta',\n  // \"name\": intentionally not styling\n  'regexp': 'red'\n};\n\n\nfunction stylizeWithColor(str, styleType) {\n  var style = inspect.styles[styleType];\n\n  if (style) {\n    return '\\u001b[' + inspect.colors[style][0] + 'm' + str +\n           '\\u001b[' + inspect.colors[style][1] + 'm';\n  } else {\n    return str;\n  }\n}\n\n\nfunction stylizeNoColor(str, styleType) {\n  return str;\n}\n\n\nfunction arrayToHash(array) {\n  var hash = {};\n\n  array.forEach(function(val, idx) {\n    hash[val] = true;\n  });\n\n  return hash;\n}\n\n\nfunction formatValue(ctx, value, recurseTimes) {\n  // Provide a hook for user-specified inspect functions.\n  // Check that value is an object with an inspect function on it\n  if (ctx.customInspect &&\n      value &&\n      isFunction(value.inspect) &&\n      // Filter out the util module, it's inspect function is special\n      value.inspect !== exports.inspect &&\n      // Also filter out any prototype objects using the circular check.\n      !(value.constructor && value.constructor.prototype === value)) {\n    var ret = value.inspect(recurseTimes, ctx);\n    if (!isString(ret)) {\n      ret = formatValue(ctx, ret, recurseTimes);\n    }\n    return ret;\n  }\n\n  // Primitive types cannot have properties\n  var primitive = formatPrimitive(ctx, value);\n  if (primitive) {\n    return primitive;\n  }\n\n  // Look up the keys of the object.\n  var keys = Object.keys(value);\n  var visibleKeys = arrayToHash(keys);\n\n  if (ctx.showHidden) {\n    keys = Object.getOwnPropertyNames(value);\n  }\n\n  // IE doesn't make error fields non-enumerable\n  // http://msdn.microsoft.com/en-us/library/ie/dww52sbt(v=vs.94).aspx\n  if (isError(value)\n      && (keys.indexOf('message') >= 0 || keys.indexOf('description') >= 0)) {\n    return formatError(value);\n  }\n\n  // Some type of object without properties can be shortcutted.\n  if (keys.length === 0) {\n    if (isFunction(value)) {\n      var name = value.name ? ': ' + value.name : '';\n      return ctx.stylize('[Function' + name + ']', 'special');\n    }\n    if (isRegExp(value)) {\n      return ctx.stylize(RegExp.prototype.toString.call(value), 'regexp');\n    }\n    if (isDate(value)) {\n      return ctx.stylize(Date.prototype.toString.call(value), 'date');\n    }\n    if (isError(value)) {\n      return formatError(value);\n    }\n  }\n\n  var base = '', array = false, braces = ['{', '}'];\n\n  // Make Array say that they are Array\n  if (isArray(value)) {\n    array = true;\n    braces = ['[', ']'];\n  }\n\n  // Make functions say that they are functions\n  if (isFunction(value)) {\n    var n = value.name ? ': ' + value.name : '';\n    base = ' [Function' + n + ']';\n  }\n\n  // Make RegExps say that they are RegExps\n  if (isRegExp(value)) {\n    base = ' ' + RegExp.prototype.toString.call(value);\n  }\n\n  // Make dates with properties first say the date\n  if (isDate(value)) {\n    base = ' ' + Date.prototype.toUTCString.call(value);\n  }\n\n  // Make error with message first say the error\n  if (isError(value)) {\n    base = ' ' + formatError(value);\n  }\n\n  if (keys.length === 0 && (!array || value.length == 0)) {\n    return braces[0] + base + braces[1];\n  }\n\n  if (recurseTimes < 0) {\n    if (isRegExp(value)) {\n      return ctx.stylize(RegExp.prototype.toString.call(value), 'regexp');\n    } else {\n      return ctx.stylize('[Object]', 'special');\n    }\n  }\n\n  ctx.seen.push(value);\n\n  var output;\n  if (array) {\n    output = formatArray(ctx, value, recurseTimes, visibleKeys, keys);\n  } else {\n    output = keys.map(function(key) {\n      return formatProperty(ctx, value, recurseTimes, visibleKeys, key, array);\n    });\n  }\n\n  ctx.seen.pop();\n\n  return reduceToSingleString(output, base, braces);\n}\n\n\nfunction formatPrimitive(ctx, value) {\n  if (isUndefined(value))\n    return ctx.stylize('undefined', 'undefined');\n  if (isString(value)) {\n    var simple = '\\'' + JSON.stringify(value).replace(/^\"|\"$/g, '')\n                                             .replace(/'/g, \"\\\\'\")\n                                             .replace(/\\\\\"/g, '\"') + '\\'';\n    return ctx.stylize(simple, 'string');\n  }\n  if (isNumber(value))\n    return ctx.stylize('' + value, 'number');\n  if (isBoolean(value))\n    return ctx.stylize('' + value, 'boolean');\n  // For some reason typeof null is \"object\", so special case here.\n  if (isNull(value))\n    return ctx.stylize('null', 'null');\n}\n\n\nfunction formatError(value) {\n  return '[' + Error.prototype.toString.call(value) + ']';\n}\n\n\nfunction formatArray(ctx, value, recurseTimes, visibleKeys, keys) {\n  var output = [];\n  for (var i = 0, l = value.length; i < l; ++i) {\n    if (hasOwnProperty(value, String(i))) {\n      output.push(formatProperty(ctx, value, recurseTimes, visibleKeys,\n          String(i), true));\n    } else {\n      output.push('');\n    }\n  }\n  keys.forEach(function(key) {\n    if (!key.match(/^\\d+$/)) {\n      output.push(formatProperty(ctx, value, recurseTimes, visibleKeys,\n          key, true));\n    }\n  });\n  return output;\n}\n\n\nfunction formatProperty(ctx, value, recurseTimes, visibleKeys, key, array) {\n  var name, str, desc;\n  desc = Object.getOwnPropertyDescriptor(value, key) || { value: value[key] };\n  if (desc.get) {\n    if (desc.set) {\n      str = ctx.stylize('[Getter/Setter]', 'special');\n    } else {\n      str = ctx.stylize('[Getter]', 'special');\n    }\n  } else {\n    if (desc.set) {\n      str = ctx.stylize('[Setter]', 'special');\n    }\n  }\n  if (!hasOwnProperty(visibleKeys, key)) {\n    name = '[' + key + ']';\n  }\n  if (!str) {\n    if (ctx.seen.indexOf(desc.value) < 0) {\n      if (isNull(recurseTimes)) {\n        str = formatValue(ctx, desc.value, null);\n      } else {\n        str = formatValue(ctx, desc.value, recurseTimes - 1);\n      }\n      if (str.indexOf('\\n') > -1) {\n        if (array) {\n          str = str.split('\\n').map(function(line) {\n            return '  ' + line;\n          }).join('\\n').substr(2);\n        } else {\n          str = '\\n' + str.split('\\n').map(function(line) {\n            return '   ' + line;\n          }).join('\\n');\n        }\n      }\n    } else {\n      str = ctx.stylize('[Circular]', 'special');\n    }\n  }\n  if (isUndefined(name)) {\n    if (array && key.match(/^\\d+$/)) {\n      return str;\n    }\n    name = JSON.stringify('' + key);\n    if (name.match(/^\"([a-zA-Z_][a-zA-Z_0-9]*)\"$/)) {\n      name = name.substr(1, name.length - 2);\n      name = ctx.stylize(name, 'name');\n    } else {\n      name = name.replace(/'/g, \"\\\\'\")\n                 .replace(/\\\\\"/g, '\"')\n                 .replace(/(^\"|\"$)/g, \"'\");\n      name = ctx.stylize(name, 'string');\n    }\n  }\n\n  return name + ': ' + str;\n}\n\n\nfunction reduceToSingleString(output, base, braces) {\n  var numLinesEst = 0;\n  var length = output.reduce(function(prev, cur) {\n    numLinesEst++;\n    if (cur.indexOf('\\n') >= 0) numLinesEst++;\n    return prev + cur.replace(/\\u001b\\[\\d\\d?m/g, '').length + 1;\n  }, 0);\n\n  if (length > 60) {\n    return braces[0] +\n           (base === '' ? '' : base + '\\n ') +\n           ' ' +\n           output.join(',\\n  ') +\n           ' ' +\n           braces[1];\n  }\n\n  return braces[0] + base + ' ' + output.join(', ') + ' ' + braces[1];\n}\n\n\n// NOTE: These type checking functions intentionally don't use `instanceof`\n// because it is fragile and can be easily faked with `Object.create()`.\nfunction isArray(ar) {\n  return Array.isArray(ar);\n}\nexports.isArray = isArray;\n\nfunction isBoolean(arg) {\n  return typeof arg === 'boolean';\n}\nexports.isBoolean = isBoolean;\n\nfunction isNull(arg) {\n  return arg === null;\n}\nexports.isNull = isNull;\n\nfunction isNullOrUndefined(arg) {\n  return arg == null;\n}\nexports.isNullOrUndefined = isNullOrUndefined;\n\nfunction isNumber(arg) {\n  return typeof arg === 'number';\n}\nexports.isNumber = isNumber;\n\nfunction isString(arg) {\n  return typeof arg === 'string';\n}\nexports.isString = isString;\n\nfunction isSymbol(arg) {\n  return typeof arg === 'symbol';\n}\nexports.isSymbol = isSymbol;\n\nfunction isUndefined(arg) {\n  return arg === void 0;\n}\nexports.isUndefined = isUndefined;\n\nfunction isRegExp(re) {\n  return isObject(re) && objectToString(re) === '[object RegExp]';\n}\nexports.isRegExp = isRegExp;\n\nfunction isObject(arg) {\n  return typeof arg === 'object' && arg !== null;\n}\nexports.isObject = isObject;\n\nfunction isDate(d) {\n  return isObject(d) && objectToString(d) === '[object Date]';\n}\nexports.isDate = isDate;\n\nfunction isError(e) {\n  return isObject(e) &&\n      (objectToString(e) === '[object Error]' || e instanceof Error);\n}\nexports.isError = isError;\n\nfunction isFunction(arg) {\n  return typeof arg === 'function';\n}\nexports.isFunction = isFunction;\n\nfunction isPrimitive(arg) {\n  return arg === null ||\n         typeof arg === 'boolean' ||\n         typeof arg === 'number' ||\n         typeof arg === 'string' ||\n         typeof arg === 'symbol' ||  // ES6 symbol\n         typeof arg === 'undefined';\n}\nexports.isPrimitive = isPrimitive;\n\nexports.isBuffer = require('./support/isBuffer');\n\nfunction objectToString(o) {\n  return Object.prototype.toString.call(o);\n}\n\n\nfunction pad(n) {\n  return n < 10 ? '0' + n.toString(10) : n.toString(10);\n}\n\n\nvar months = ['Jan', 'Feb', 'Mar', 'Apr', 'May', 'Jun', 'Jul', 'Aug', 'Sep',\n              'Oct', 'Nov', 'Dec'];\n\n// 26 Feb 16:19:34\nfunction timestamp() {\n  var d = new Date();\n  var time = [pad(d.getHours()),\n              pad(d.getMinutes()),\n              pad(d.getSeconds())].join(':');\n  return [d.getDate(), months[d.getMonth()], time].join(' ');\n}\n\n\n// log is just a thin wrapper to console.log that prepends a timestamp\nexports.log = function() {\n  console.log('%s - %s', timestamp(), exports.format.apply(exports, arguments));\n};\n\n\n/**\n * Inherit the prototype methods from one constructor into another.\n *\n * The Function.prototype.inherits from lang.js rewritten as a standalone\n * function (not on Function.prototype). NOTE: If this file is to be loaded\n * during bootstrapping this function needs to be rewritten using some native\n * functions as prototype setup using normal JavaScript does not work as\n * expected during bootstrapping (see mirror.js in r114903).\n *\n * @param {function} ctor Constructor function which needs to inherit the\n *     prototype.\n * @param {function} superCtor Constructor function to inherit prototype from.\n */\nexports.inherits = require('inherits');\n\nexports._extend = function(origin, add) {\n  // Don't do anything if add isn't an object\n  if (!add || !isObject(add)) return origin;\n\n  var keys = Object.keys(add);\n  var i = keys.length;\n  while (i--) {\n    origin[keys[i]] = add[keys[i]];\n  }\n  return origin;\n};\n\nfunction hasOwnProperty(obj, prop) {\n  return Object.prototype.hasOwnProperty.call(obj, prop);\n}\n\nvar kCustomPromisifiedSymbol = typeof Symbol !== 'undefined' ? Symbol('util.promisify.custom') : undefined;\n\nexports.promisify = function promisify(original) {\n  if (typeof original !== 'function')\n    throw new TypeError('The \"original\" argument must be of type Function');\n\n  if (kCustomPromisifiedSymbol && original[kCustomPromisifiedSymbol]) {\n    var fn = original[kCustomPromisifiedSymbol];\n    if (typeof fn !== 'function') {\n      throw new TypeError('The \"util.promisify.custom\" argument must be of type Function');\n    }\n    Object.defineProperty(fn, kCustomPromisifiedSymbol, {\n      value: fn, enumerable: false, writable: false, configurable: true\n    });\n    return fn;\n  }\n\n  function fn() {\n    var promiseResolve, promiseReject;\n    var promise = new Promise(function (resolve, reject) {\n      promiseResolve = resolve;\n      promiseReject = reject;\n    });\n\n    var args = [];\n    for (var i = 0; i < arguments.length; i++) {\n      args.push(arguments[i]);\n    }\n    args.push(function (err, value) {\n      if (err) {\n        promiseReject(err);\n      } else {\n        promiseResolve(value);\n      }\n    });\n\n    try {\n      original.apply(this, args);\n    } catch (err) {\n      promiseReject(err);\n    }\n\n    return promise;\n  }\n\n  Object.setPrototypeOf(fn, Object.getPrototypeOf(original));\n\n  if (kCustomPromisifiedSymbol) Object.defineProperty(fn, kCustomPromisifiedSymbol, {\n    value: fn, enumerable: false, writable: false, configurable: true\n  });\n  return Object.defineProperties(\n    fn,\n    getOwnPropertyDescriptors(original)\n  );\n}\n\nexports.promisify.custom = kCustomPromisifiedSymbol\n\nfunction callbackifyOnRejected(reason, cb) {\n  // `!reason` guard inspired by bluebird (Ref: https://goo.gl/t5IS6M).\n  // Because `null` is a special error value in callbacks which means \"no error\n  // occurred\", we error-wrap so the callback consumer can distinguish between\n  // \"the promise rejected with null\" or \"the promise fulfilled with undefined\".\n  if (!reason) {\n    var newReason = new Error('Promise was rejected with a falsy value');\n    newReason.reason = reason;\n    reason = newReason;\n  }\n  return cb(reason);\n}\n\nfunction callbackify(original) {\n  if (typeof original !== 'function') {\n    throw new TypeError('The \"original\" argument must be of type Function');\n  }\n\n  // We DO NOT return the promise as it gives the user a false sense that\n  // the promise is actually somehow related to the callback's execution\n  // and that the callback throwing will reject the promise.\n  function callbackified() {\n    var args = [];\n    for (var i = 0; i < arguments.length; i++) {\n      args.push(arguments[i]);\n    }\n\n    var maybeCb = args.pop();\n    if (typeof maybeCb !== 'function') {\n      throw new TypeError('The last argument must be of type Function');\n    }\n    var self = this;\n    var cb = function() {\n      return maybeCb.apply(self, arguments);\n    };\n    // In true node style we process the callback on `nextTick` with all the\n    // implications (stack, `uncaughtException`, `async_hooks`)\n    original.apply(this, args)\n      .then(function(ret) { process.nextTick(cb, null, ret) },\n            function(rej) { process.nextTick(callbackifyOnRejected, rej, cb) });\n  }\n\n  Object.setPrototypeOf(callbackified, Object.getPrototypeOf(original));\n  Object.defineProperties(callbackified,\n                          getOwnPropertyDescriptors(original));\n  return callbackified;\n}\nexports.callbackify = callbackify;\n","// shim for using process in browser\nvar process = module.exports = {};\n\n// cached from whatever global is present so that test runners that stub it\n// don't break things.  But we need to wrap it in a try catch in case it is\n// wrapped in strict mode code which doesn't define any globals.  It's inside a\n// function because try/catches deoptimize in certain engines.\n\nvar cachedSetTimeout;\nvar cachedClearTimeout;\n\nfunction defaultSetTimout() {\n    throw new Error('setTimeout has not been defined');\n}\nfunction defaultClearTimeout () {\n    throw new Error('clearTimeout has not been defined');\n}\n(function () {\n    try {\n        if (typeof setTimeout === 'function') {\n            cachedSetTimeout = setTimeout;\n        } else {\n            cachedSetTimeout = defaultSetTimout;\n        }\n    } catch (e) {\n        cachedSetTimeout = defaultSetTimout;\n    }\n    try {\n        if (typeof clearTimeout === 'function') {\n            cachedClearTimeout = clearTimeout;\n        } else {\n            cachedClearTimeout = defaultClearTimeout;\n        }\n    } catch (e) {\n        cachedClearTimeout = defaultClearTimeout;\n    }\n} ())\nfunction runTimeout(fun) {\n    if (cachedSetTimeout === setTimeout) {\n        //normal enviroments in sane situations\n        return setTimeout(fun, 0);\n    }\n    // if setTimeout wasn't available but was latter defined\n    if ((cachedSetTimeout === defaultSetTimout || !cachedSetTimeout) && setTimeout) {\n        cachedSetTimeout = setTimeout;\n        return setTimeout(fun, 0);\n    }\n    try {\n        // when when somebody has screwed with setTimeout but no I.E. maddness\n        return cachedSetTimeout(fun, 0);\n    } catch(e){\n        try {\n            // When we are in I.E. but the script has been evaled so I.E. doesn't trust the global object when called normally\n            return cachedSetTimeout.call(null, fun, 0);\n        } catch(e){\n            // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error\n            return cachedSetTimeout.call(this, fun, 0);\n        }\n    }\n\n\n}\nfunction runClearTimeout(marker) {\n    if (cachedClearTimeout === clearTimeout) {\n        //normal enviroments in sane situations\n        return clearTimeout(marker);\n    }\n    // if clearTimeout wasn't available but was latter defined\n    if ((cachedClearTimeout === defaultClearTimeout || !cachedClearTimeout) && clearTimeout) {\n        cachedClearTimeout = clearTimeout;\n        return clearTimeout(marker);\n    }\n    try {\n        // when when somebody has screwed with setTimeout but no I.E. maddness\n        return cachedClearTimeout(marker);\n    } catch (e){\n        try {\n            // When we are in I.E. but the script has been evaled so I.E. doesn't  trust the global object when called normally\n            return cachedClearTimeout.call(null, marker);\n        } catch (e){\n            // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error.\n            // Some versions of I.E. have different rules for clearTimeout vs setTimeout\n            return cachedClearTimeout.call(this, marker);\n        }\n    }\n\n\n\n}\nvar queue = [];\nvar draining = false;\nvar currentQueue;\nvar queueIndex = -1;\n\nfunction cleanUpNextTick() {\n    if (!draining || !currentQueue) {\n        return;\n    }\n    draining = false;\n    if (currentQueue.length) {\n        queue = currentQueue.concat(queue);\n    } else {\n        queueIndex = -1;\n    }\n    if (queue.length) {\n        drainQueue();\n    }\n}\n\nfunction drainQueue() {\n    if (draining) {\n        return;\n    }\n    var timeout = runTimeout(cleanUpNextTick);\n    draining = true;\n\n    var len = queue.length;\n    while(len) {\n        currentQueue = queue;\n        queue = [];\n        while (++queueIndex < len) {\n            if (currentQueue) {\n                currentQueue[queueIndex].run();\n            }\n        }\n        queueIndex = -1;\n        len = queue.length;\n    }\n    currentQueue = null;\n    draining = false;\n    runClearTimeout(timeout);\n}\n\nprocess.nextTick = function (fun) {\n    var args = new Array(arguments.length - 1);\n    if (arguments.length > 1) {\n        for (var i = 1; i < arguments.length; i++) {\n            args[i - 1] = arguments[i];\n        }\n    }\n    queue.push(new Item(fun, args));\n    if (queue.length === 1 && !draining) {\n        runTimeout(drainQueue);\n    }\n};\n\n// v8 likes predictible objects\nfunction Item(fun, array) {\n    this.fun = fun;\n    this.array = array;\n}\nItem.prototype.run = function () {\n    this.fun.apply(null, this.array);\n};\nprocess.title = 'browser';\nprocess.browser = true;\nprocess.env = {};\nprocess.argv = [];\nprocess.version = ''; // empty string to avoid regexp issues\nprocess.versions = {};\n\nfunction noop() {}\n\nprocess.on = noop;\nprocess.addListener = noop;\nprocess.once = noop;\nprocess.off = noop;\nprocess.removeListener = noop;\nprocess.removeAllListeners = noop;\nprocess.emit = noop;\nprocess.prependListener = noop;\nprocess.prependOnceListener = noop;\n\nprocess.listeners = function (name) { return [] }\n\nprocess.binding = function (name) {\n    throw new Error('process.binding is not supported');\n};\n\nprocess.cwd = function () { return '/' };\nprocess.chdir = function (dir) {\n    throw new Error('process.chdir is not supported');\n};\nprocess.umask = function() { return 0; };\n","module.exports = function isBuffer(arg) {\n  return arg && typeof arg === 'object'\n    && typeof arg.copy === 'function'\n    && typeof arg.fill === 'function'\n    && typeof arg.readUInt8 === 'function';\n}","if (typeof Object.create === 'function') {\n  // implementation from standard node.js 'util' module\n  module.exports = function inherits(ctor, superCtor) {\n    ctor.super_ = superCtor\n    ctor.prototype = Object.create(superCtor.prototype, {\n      constructor: {\n        value: ctor,\n        enumerable: false,\n        writable: true,\n        configurable: true\n      }\n    });\n  };\n} else {\n  // old school shim for old browsers\n  module.exports = function inherits(ctor, superCtor) {\n    ctor.super_ = superCtor\n    var TempCtor = function () {}\n    TempCtor.prototype = superCtor.prototype\n    ctor.prototype = new TempCtor()\n    ctor.prototype.constructor = ctor\n  }\n}\n"],"sourceRoot":""}